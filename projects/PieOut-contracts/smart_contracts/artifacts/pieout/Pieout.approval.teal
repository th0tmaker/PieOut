#pragma version 10
#pragma typetrack false

// smart_contracts.pieout.contract.Pieout.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 32 2 TMPL_GEN_UNIX TMPL_DELETABLE
    bytecblock "game_id" 0x00 0x151f7c75 0x0a 0x675f 0x705f
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/pieout/contract.py:54
    // self.game_id = UInt64(0)
    bytec_0 // "game_id"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/pieout/contract.py:39
    // class Pieout(ARC4Contract):
    txn NumAppArgs
    bz main_after_if_else@11
    pushbytess 0x137d1094 0x5be219f0 0x4ece0cfd 0x34d1c23d 0x26c71091 0x5ff16da4 // method "calc_single_box_fee(uint8,uint16)uint64", method "generate()void", method "get_gen_unix()uint64", method "new_game(uint64,pay,pay)void", method "join_game(uint64)void", method "terminate()void"
    txna ApplicationArgs 0
    match main_calc_single_box_fee_route@5 main_generate_route@6 main_get_gen_unix_route@7 main_new_game_route@8 main_join_game_route@9 main_terminate_route@10

main_after_if_else@11:
    // smart_contracts/pieout/contract.py:39
    // class Pieout(ARC4Contract):
    intc_1 // 0
    return

main_terminate_route@10:
    // smart_contracts/pieout/contract.py:448-449
    // # Allow application creator to delete the smart contract client
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub terminate
    intc_0 // 1
    return

main_join_game_route@9:
    // smart_contracts/pieout/contract.py:143
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:39
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:143
    // @arc4.abimethod
    callsub join_game
    intc_0 // 1
    return

main_new_game_route@8:
    // smart_contracts/pieout/contract.py:86
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:39
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_3 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:86
    // @arc4.abimethod
    callsub new_game
    intc_0 // 1
    return

main_get_gen_unix_route@7:
    // smart_contracts/pieout/contract.py:81-82
    // # Retrieve the genesis (creation) timestamp of the contract in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:84
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 4 // TMPL_GEN_UNIX
    // smart_contracts/pieout/contract.py:81-82
    // # Retrieve the genesis (creation) timestamp of the contract in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_generate_route@6:
    // smart_contracts/pieout/contract.py:71-72
    // # Generate the smart contract application client with default values
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return

main_calc_single_box_fee_route@5:
    // smart_contracts/pieout/contract.py:56-57
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:39
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pieout/contract.py:56-57
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_fee
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.pieout.contract.Pieout.calc_single_box_fee(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_fee:
    // smart_contracts/pieout/contract.py:56-60
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_fee(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/pieout/contract.py:65
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/pieout/contract.py:64
    // size_fee = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/pieout/contract.py:64-66
    // size_fee = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/pieout/contract.py:68-69
    // # Return single box fee
    // return base_fee.native + size_fee
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.pieout.contract.Pieout.generate() -> void:
generate:
    // smart_contracts/pieout/contract.py:78
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/pieout/contract.py:76-79
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    retsub


// smart_contracts.pieout.contract.Pieout.new_game(max_players: uint64, box_g_pay: uint64, box_p_pay: uint64) -> void:
new_game:
    // smart_contracts/pieout/contract.py:86-92
    // @arc4.abimethod
    // def new_game(
    //     self,
    //     max_players: UInt64,
    //     box_g_pay: gtxn.PaymentTransaction,
    //     box_p_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 3 0
    // smart_contracts/pieout/contract.py:93-94
    // # Method scope cache commonly used values
    // txn_sender = Txn.sender
    txn Sender
    // smart_contracts/pieout/contract.py:95
    // app_address = Global.current_application_address
    global CurrentApplicationAddress
    // smart_contracts/pieout/contract.py:93-94
    // # Method scope cache commonly used values
    // txn_sender = Txn.sender
    txn Sender
    // smart_contracts/pieout/contract.py:98
    // key_size=arc4.UInt8(10), value_size=arc4.UInt16(46)
    bytec_3 // 0x0a
    pushbytes 0x002e
    // smart_contracts/pieout/contract.py:97-99
    // box_g_fee = self.calc_single_box_fee(
    //     key_size=arc4.UInt8(10), value_size=arc4.UInt16(46)
    // )
    callsub calc_single_box_fee
    // smart_contracts/pieout/contract.py:101
    // key_size=arc4.UInt8(10), value_size=arc4.UInt16(32 * max_players)
    intc_2 // 32
    frame_dig -3
    *
    dup
    cover 3
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    bytec_3 // 0x0a
    // smart_contracts/pieout/contract.py:100-102
    // box_p_fee = self.calc_single_box_fee(
    //     key_size=arc4.UInt8(10), value_size=arc4.UInt16(32 * max_players)
    // )
    swap
    callsub calc_single_box_fee
    // smart_contracts/pieout/contract.py:106
    // max_players <= MAX_PLAYERS
    frame_dig -3
    pushint 10 // 10
    <=
    // smart_contracts/pieout/contract.py:104-107
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     max_players <= MAX_PLAYERS
    // ), "new_game(): Max players limit (currently at 10) exceeded."
    assert // new_game(): Max players limit (currently at 10) exceeded.
    // smart_contracts/pieout/contract.py:110
    // box_g_pay.amount >= box_g_fee
    frame_dig -2
    gtxns Amount
    uncover 2
    >=
    // smart_contracts/pieout/contract.py:109-111
    // assert (
    //     box_g_pay.amount >= box_g_fee
    // ), "new_game(): Insufficient amount. Box g_ pay amount is not enough to cover application MBR."
    assert // new_game(): Insufficient amount. Box g_ pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:114
    // box_p_pay.amount >= box_p_fee
    frame_dig -1
    gtxns Amount
    <=
    // smart_contracts/pieout/contract.py:113-115
    // assert (
    //     box_p_pay.amount >= box_p_fee
    // ), "new_game(): Insufficient amount. Box p_ pay amount is not enough to cover application MBR."
    assert // new_game(): Insufficient amount. Box p_ pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:118
    // txn_sender == box_g_pay.sender and txn_sender == box_p_pay.sender
    frame_dig -2
    gtxns Sender
    ==
    bz new_game_bool_false@3
    frame_dig -1
    gtxns Sender
    frame_dig 0
    ==
    bz new_game_bool_false@3
    intc_0 // 1

new_game_bool_merge@4:
    // smart_contracts/pieout/contract.py:117-119
    // assert (
    //     txn_sender == box_g_pay.sender and txn_sender == box_p_pay.sender
    // ), "new_game(): Box g_ and p_ payment sender address must match transaction sender address."
    assert // new_game(): Box g_ and p_ payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:122
    // app_address == box_g_pay.receiver and app_address == box_p_pay.receiver
    frame_dig -2
    gtxns Receiver
    frame_dig 1
    ==
    bz new_game_bool_false@7
    frame_dig -1
    gtxns Receiver
    frame_dig 1
    ==
    bz new_game_bool_false@7
    intc_0 // 1

new_game_bool_merge@8:
    // smart_contracts/pieout/contract.py:121-123
    // assert (
    //     app_address == box_g_pay.receiver and app_address == box_p_pay.receiver
    // ), "new_game(): Box g_ and p_ payment reciever address must match application address."
    assert // new_game(): Box g_ and p_ payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:131
    // max_players=arc4.UInt8(max_players),
    frame_dig -3
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/pieout/contract.py:136
    // winner_address=arc4.Address(Global.zero_address),
    global ZeroAddress
    // smart_contracts/pieout/contract.py:127-137
    // self.box_game[self.game_id] = GameBoxVal(
    //     creator_stake_status=is_false,
    //     staking_finalized=is_false,
    //     prize_pool_claimed=is_false,
    //     max_players=arc4.UInt8(max_players),
    //     total_players=arc4.UInt8(0),
    //     high_score=arc4.UInt8(0),
    //     offset_box_p_=arc4.UInt16(0),
    //     prize_pool=arc4.UInt64(0),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    bytec_1 // 0x00
    uncover 2
    concat
    // smart_contracts/pieout/contract.py:132
    // total_players=arc4.UInt8(0),
    bytec_1 // 0x00
    // smart_contracts/pieout/contract.py:127-137
    // self.box_game[self.game_id] = GameBoxVal(
    //     creator_stake_status=is_false,
    //     staking_finalized=is_false,
    //     prize_pool_claimed=is_false,
    //     max_players=arc4.UInt8(max_players),
    //     total_players=arc4.UInt8(0),
    //     high_score=arc4.UInt8(0),
    //     offset_box_p_=arc4.UInt16(0),
    //     prize_pool=arc4.UInt64(0),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:133
    // high_score=arc4.UInt8(0),
    bytec_1 // 0x00
    // smart_contracts/pieout/contract.py:127-137
    // self.box_game[self.game_id] = GameBoxVal(
    //     creator_stake_status=is_false,
    //     staking_finalized=is_false,
    //     prize_pool_claimed=is_false,
    //     max_players=arc4.UInt8(max_players),
    //     total_players=arc4.UInt8(0),
    //     high_score=arc4.UInt8(0),
    //     offset_box_p_=arc4.UInt16(0),
    //     prize_pool=arc4.UInt64(0),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:134
    // offset_box_p_=arc4.UInt16(0),
    pushbytes 0x0000
    // smart_contracts/pieout/contract.py:127-137
    // self.box_game[self.game_id] = GameBoxVal(
    //     creator_stake_status=is_false,
    //     staking_finalized=is_false,
    //     prize_pool_claimed=is_false,
    //     max_players=arc4.UInt8(max_players),
    //     total_players=arc4.UInt8(0),
    //     high_score=arc4.UInt8(0),
    //     offset_box_p_=arc4.UInt16(0),
    //     prize_pool=arc4.UInt64(0),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:135
    // prize_pool=arc4.UInt64(0),
    pushbytes 0x0000000000000000
    // smart_contracts/pieout/contract.py:127-137
    // self.box_game[self.game_id] = GameBoxVal(
    //     creator_stake_status=is_false,
    //     staking_finalized=is_false,
    //     prize_pool_claimed=is_false,
    //     max_players=arc4.UInt8(max_players),
    //     total_players=arc4.UInt8(0),
    //     high_score=arc4.UInt8(0),
    //     offset_box_p_=arc4.UInt16(0),
    //     prize_pool=arc4.UInt64(0),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    swap
    concat
    // smart_contracts/pieout/contract.py:127
    // self.box_game[self.game_id] = GameBoxVal(
    intc_1 // 0
    bytec_0 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec 4 // 0x675f
    swap
    concat
    // smart_contracts/pieout/contract.py:127-137
    // self.box_game[self.game_id] = GameBoxVal(
    //     creator_stake_status=is_false,
    //     staking_finalized=is_false,
    //     prize_pool_claimed=is_false,
    //     max_players=arc4.UInt8(max_players),
    //     total_players=arc4.UInt8(0),
    //     high_score=arc4.UInt8(0),
    //     offset_box_p_=arc4.UInt16(0),
    //     prize_pool=arc4.UInt64(0),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    swap
    box_put
    // smart_contracts/pieout/contract.py:139
    // self.box_players[self.game_id] = op.bzero(32 * max_players)
    intc_1 // 0
    bytec_0 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec 5 // "p_"
    swap
    concat
    frame_dig 2
    bzero
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/pieout/contract.py:141
    // self.game_id += 1
    intc_1 // 0
    bytec_0 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    intc_0 // 1
    +
    bytec_0 // "game_id"
    swap
    app_global_put
    retsub

new_game_bool_false@7:
    intc_1 // 0
    b new_game_bool_merge@8

new_game_bool_false@3:
    intc_1 // 0
    b new_game_bool_merge@4


// smart_contracts.pieout.contract.Pieout.join_game(game_id: uint64) -> void:
join_game:
    // smart_contracts/pieout/contract.py:143-144
    // @arc4.abimethod
    // def join_game(self, game_id: UInt64) -> None:
    proto 1 0
    // smart_contracts/pieout/contract.py:145
    // txn_sender = Txn.sender
    txn Sender
    // smart_contracts/pieout/contract.py:147
    // game = self.box_game[game_id].copy()
    frame_dig -1
    itob
    bytec 4 // 0x675f
    dig 1
    concat
    dup
    box_get
    assert // check self.box_game entry exists
    // smart_contracts/pieout/contract.py:149
    // max_size = 32 * game.max_players.native
    dup
    intc_0 // 1
    getbyte
    intc_2 // 32
    *
    // smart_contracts/pieout/contract.py:151
    // assert game_id in self.box_game, "No Game with such ID."
    dig 2
    box_len
    bury 1
    assert // No Game with such ID.
    // smart_contracts/pieout/contract.py:153
    // assert game.offset_box_p_.native < max_size, "Game lobby is full."
    dig 1
    pushint 4 // 4
    extract_uint16
    dup
    uncover 2
    <
    assert // Game lobby is full.
    // smart_contracts/pieout/contract.py:155
    // box_p_name = b"p_" + op.itob(game_id)
    bytec 5 // 0x705f
    uncover 4
    concat
    // smart_contracts/pieout/contract.py:156-160
    // op.Box.replace(
    //     box_p_name,
    //     game.offset_box_p_.native,
    //     txn_sender.bytes,
    // )
    dig 1
    uncover 5
    box_replace
    // smart_contracts/pieout/contract.py:162
    // game.offset_box_p_ = arc4.UInt16(game.offset_box_p_.native + 32)
    intc_2 // 32
    +
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    replace2 4
    // smart_contracts/pieout/contract.py:164
    // game.total_players = arc4.UInt8(game.total_players.native + 1)
    dup
    intc_3 // 2
    getbyte
    intc_0 // 1
    +
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    replace2 2
    // smart_contracts/pieout/contract.py:166
    // self.box_game[game_id] = game.copy()
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.terminate() -> void:
terminate:
    // smart_contracts/pieout/contract.py:453
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/pieout/contract.py:451-454
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:456-458
    // assert TemplateVar[bool](
    //     "DELETABLE"
    // ), "Template variable 'DELETABLE' needs to be 'True' at deploy-time."
    intc 5 // TMPL_DELETABLE
    assert // Template variable 'DELETABLE' needs to be 'True' at deploy-time.
    retsub
