#pragma version 10
#pragma typetrack false

// smart_contracts.pieout.contract.Pieout.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 2 32 19300 3600 1000 6364136223846793005 1442695040888963407 4294967295 67300 65535 TMPL_GEN_UNIX TMPL_DELETABLE
    bytecblock 0x00 0x745f "p_" "s_" "c_" 0x151f7c75 "game_id" "commit_rand_salt_id" "ath_address" "ath_score" 0x0000000000000000000000000000000000000000000000000000000000000000 0x0020 0x068101
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txn NumAppArgs
    bz main_after_if_else@22
    pushbytess 0x137d1094 0xb66d2f56 0x627a73af 0x7401ca83 0x5be219f0 0xa27df65d 0xb9949f70 0xda7b6785 0x71af966e 0x74c7e053 0x642beee8 0x62cd6e4a 0x1a789ed0 0x0c558d9a 0x102875e7 0x1898a02e 0x5ff16da4 // method "calc_single_box_fee(uint8,uint16)uint64", method "read_gen_unix()uint64", method "read_game_state(uint64)(uint64,bool,uint8,uint8,uint8,uint8,uint8,uint16,uint64,uint64,address,address,address,address)", method "read_game_players(uint64)address[]", method "generate()void", method "mint_trophy(pay,pay)address", method "get_trophy()void", method "new_game(uint64,pay,pay,pay)void", method "join_game(uint64,pay)void", method "get_box_commit_rand(pay)void", method "commit_rand(uint64)void", method "del_box_commit_rand()void", method "play_game(uint64)void", method "check_game_event(uint64,uint8)bool", method "reset_game(uint64,pay)void", method "delete_game(uint64)void", method "terminate()void"
    txna ApplicationArgs 0
    match main_calc_single_box_fee_route@5 main_read_gen_unix_route@6 main_read_game_state_route@7 main_read_game_players_route@8 main_generate_route@9 main_mint_trophy_route@10 main_get_trophy_route@11 main_new_game_route@12 main_join_game_route@13 main_get_box_commit_rand_route@14 main_commit_rand_route@15 main_del_box_commit_rand_route@16 main_play_game_route@17 main_check_game_event_route@18 main_reset_game_route@19 main_delete_game_route@20 main_terminate_route@21

main_after_if_else@22:
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    intc_1 // 0
    return

main_terminate_route@21:
    // smart_contracts/pieout/contract.py:662-663
    // # Allow application creator to delete the smart contract client
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub terminate
    intc_0 // 1
    return

main_delete_game_route@20:
    // smart_contracts/pieout/contract.py:599
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:599
    // @arc4.abimethod
    callsub delete_game
    intc_0 // 1
    return

main_reset_game_route@19:
    // smart_contracts/pieout/contract.py:547
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:547
    // @arc4.abimethod
    callsub reset_game
    intc_0 // 1
    return

main_check_game_event_route@18:
    // smart_contracts/pieout/contract.py:501-502
    // # Allow an active player of a game to manually check a game event status
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/pieout/contract.py:501-502
    // # Allow an active player of a game to manually check a game event status
    // @arc4.abimethod
    callsub check_game_event
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_play_game_route@17:
    // smart_contracts/pieout/contract.py:393-395
    // # NOTE: Consider sending commit rand and play game as group txn off chain
    // # Run play logic for an existing game instance
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:393-395
    // # NOTE: Consider sending commit rand and play game as group txn off chain
    // # Run play logic for an existing game instance
    // @arc4.abimethod
    callsub play_game
    intc_0 // 1
    return

main_del_box_commit_rand_route@16:
    // smart_contracts/pieout/contract.py:368-369
    // # Delete existing commit rand box and receive the MBR deposit cost back as refund
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub del_box_commit_rand
    intc_0 // 1
    return

main_commit_rand_route@15:
    // smart_contracts/pieout/contract.py:330-331
    // # Commit to obtaining the randomness seed reveal and store it in a box with sender address as key
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:330-331
    // # Commit to obtaining the randomness seed reveal and store it in a box with sender address as key
    // @arc4.abimethod
    callsub commit_rand
    intc_0 // 1
    return

main_get_box_commit_rand_route@14:
    // smart_contracts/pieout/contract.py:312-313
    // # Get box commit rand
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:312-313
    // # Get box commit rand
    // @arc4.abimethod
    callsub get_box_commit_rand
    intc_0 // 1
    return

main_join_game_route@13:
    // smart_contracts/pieout/contract.py:247-248
    // # Join existing game instance with required stake payment transaction
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:247-248
    // # Join existing game instance with required stake payment transaction
    // @arc4.abimethod
    callsub join_game
    intc_0 // 1
    return

main_new_game_route@12:
    // smart_contracts/pieout/contract.py:183-184
    // # Create new game instance with the required box storage and stake payment transactions
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:183-184
    // # Create new game instance with the required box storage and stake payment transactions
    // @arc4.abimethod
    callsub new_game
    intc_0 // 1
    return

main_get_trophy_route@11:
    // smart_contracts/pieout/contract.py:169
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_trophy
    intc_0 // 1
    return

main_mint_trophy_route@10:
    // smart_contracts/pieout/contract.py:123
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txn GroupIndex
    intc_2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:123
    // @arc4.abimethod
    callsub mint_trophy
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_generate_route@9:
    // smart_contracts/pieout/contract.py:109-110
    // # Generate the smart contract application client with default values
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return

main_read_game_players_route@8:
    // smart_contracts/pieout/contract.py:94-95
    // # Read the smart contract application game players box for given game id
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:94-95
    // # Read the smart contract application game players box for given game id
    // @arc4.abimethod(readonly=True)
    callsub read_game_players
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_game_state_route@7:
    // smart_contracts/pieout/contract.py:66-67
    // # Read the smart contract application game state box for given game id
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:66-67
    // # Read the smart contract application game state box for given game id
    // @arc4.abimethod(readonly=True)
    callsub read_game_state
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_gen_unix_route@6:
    // smart_contracts/pieout/contract.py:61-62
    // # Read the smart contract application genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:64
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 12 // TMPL_GEN_UNIX
    // smart_contracts/pieout/contract.py:61-62
    // # Read the smart contract application genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calc_single_box_fee_route@5:
    // smart_contracts/pieout/contract.py:46-47
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:31
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pieout/contract.py:46-47
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_fee
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.pieout.subroutines.payout_itxn(receiver: bytes, amount: uint64, note: bytes) -> void:
payout_itxn:
    // smart_contracts/pieout/subroutines.py:37-38
    // @subroutine
    // def payout_itxn(receiver: Account, amount: UInt64, note: String) -> None:
    proto 3 0
    // smart_contracts/pieout/subroutines.py:39-43
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     note=note,
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Note
    frame_dig -2
    itxn_field Amount
    frame_dig -3
    itxn_field Receiver
    // smart_contracts/pieout/subroutines.py:39
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/pieout/subroutines.py:39-43
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     note=note,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.pieout.subroutines.check_sender_in_game(game_id: uint64, box_game_players: bytes, player_count: uint64, clear_player: uint64) -> uint64:
check_sender_in_game:
    // smart_contracts/pieout/subroutines.py:46-53
    // # Check if transaction sender is active player in a valid game instance
    // @subroutine
    // def check_sender_in_game(
    //     game_id: UInt64,
    //     box_game_players: BoxMap[UInt64, Bytes],
    //     player_count: UInt64,
    //     clear_player: bool,  # noqa: FBT001
    // ) -> bool:
    proto 4 1
    intc_1 // 0
    pushbytes ""
    // smart_contracts/pieout/subroutines.py:54-55
    // # Calculate total byte length to iterate over based on player count and address size
    // game_players_length = player_count * cst.ADDRESS_SIZE
    frame_dig -2
    intc_3 // 32
    *
    // smart_contracts/pieout/subroutines.py:57-58
    // # Initialize flag to track if the transaction sender is found in the game
    // txn_sender_in_game = False
    intc_1 // 0
    // smart_contracts/pieout/subroutines.py:60-61
    // # Iterate through the player byte array in 32-byte chunks (one address per chunk)
    // for i in urange(0, game_players_length, cst.ADDRESS_SIZE):
    dup

check_sender_in_game_for_header@1:
    // smart_contracts/pieout/subroutines.py:60-61
    // # Iterate through the player byte array in 32-byte chunks (one address per chunk)
    // for i in urange(0, game_players_length, cst.ADDRESS_SIZE):
    frame_dig 4
    frame_dig 2
    <
    frame_dig 3
    frame_bury 1
    bz check_sender_in_game_after_for@8
    // smart_contracts/pieout/subroutines.py:62-63
    // # Extract the 32-byte player address at start index i
    // player_addr_bytes = op.extract(box_game_players[game_id], i, cst.ADDRESS_SIZE)
    frame_dig -4
    itob
    frame_dig -3
    swap
    concat
    dup
    frame_bury 0
    box_get
    assert // check BoxMap entry exists
    frame_dig 4
    intc_3 // 32
    extract3
    // smart_contracts/pieout/subroutines.py:65-66
    // # Check if the extracted player address matches the transaction sender address
    // if Txn.sender.bytes == player_addr_bytes:
    txn Sender
    ==
    bz check_sender_in_game_after_if_else@6
    // smart_contracts/pieout/subroutines.py:67
    // txn_sender_in_game = True
    intc_0 // 1
    frame_bury 3
    // smart_contracts/pieout/subroutines.py:69-70
    // # Optionally clear this player from the box by replacing their address with zero bytes
    // if clear_player:
    frame_dig -1
    bz check_sender_in_game_after_if_else@5
    // smart_contracts/pieout/subroutines.py:72
    // players_ref.replace(i, cst.ZERO_ADDR_BYTES)
    frame_dig 0
    frame_dig 4
    bytec 10 // 0x0000000000000000000000000000000000000000000000000000000000000000
    box_replace

check_sender_in_game_after_if_else@5:
    frame_dig 3
    frame_bury 1

check_sender_in_game_after_for@8:
    frame_dig 1
    // smart_contracts/pieout/subroutines.py:77-78
    // # Return True if sender was found in the game, else False
    // return txn_sender_in_game
    frame_bury 0
    retsub

check_sender_in_game_after_if_else@6:
    // smart_contracts/pieout/subroutines.py:60-61
    // # Iterate through the player byte array in 32-byte chunks (one address per chunk)
    // for i in urange(0, game_players_length, cst.ADDRESS_SIZE):
    frame_dig 4
    intc_3 // 32
    +
    frame_bury 4
    b check_sender_in_game_for_header@1


// smart_contracts.pieout.subroutines.is_game_live(game_state: bytes) -> bytes, bytes:
is_game_live:
    // smart_contracts/pieout/subroutines.py:160-162
    // # Check if game is live and execute its conditional logic
    // @subroutine
    // def is_game_live(game_state: stc.GameState) -> arc4.Bool:
    proto 1 2
    // smart_contracts/pieout/subroutines.py:165
    // game_state.expiry_ts < Global.latest_timestamp  # If deadline expired
    frame_dig -1
    extract 8 8 // on error: Index access is out of bounds
    global LatestTimestamp
    itob
    b<
    // smart_contracts/pieout/subroutines.py:165-166
    // game_state.expiry_ts < Global.latest_timestamp  # If deadline expired
    // or game_state.active_players == game_state.max_players  # If lobby full
    bnz is_game_live_if_body@2
    // smart_contracts/pieout/subroutines.py:166
    // or game_state.active_players == game_state.max_players  # If lobby full
    frame_dig -1
    extract 2 1 // on error: Index access is out of bounds
    frame_dig -1
    extract 1 1 // on error: Index access is out of bounds
    b==
    // smart_contracts/pieout/subroutines.py:165-166
    // game_state.expiry_ts < Global.latest_timestamp  # If deadline expired
    // or game_state.active_players == game_state.max_players  # If lobby full
    bz is_game_live_else_body@7

is_game_live_if_body@2:
    // smart_contracts/pieout/subroutines.py:168-169
    // # Mark join phase as complete when staking finalized evaluates True
    // game_state.staking_finalized = arc4.Bool(True)  # noqa: FBT003
    frame_dig -1
    intc_1 // 0
    intc_0 // 1
    setbit
    frame_bury -1
    // smart_contracts/pieout/subroutines.py:173
    // Global.latest_timestamp + UInt64(cst.EXPIRY_INTERVAL)
    global LatestTimestamp
    intc 5 // 3600
    +
    // smart_contracts/pieout/subroutines.py:171-174
    // # Establish game play window by setting expiry timestamp
    // game_state.expiry_ts = arc4.UInt64(
    //     Global.latest_timestamp + UInt64(cst.EXPIRY_INTERVAL)
    // )
    itob
    frame_dig -1
    swap
    replace2 8
    dup
    frame_bury -1
    // smart_contracts/pieout/subroutines.py:179
    // game_state.staking_finalized,
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/pieout/subroutines.py:180
    // game_state.expiry_ts,
    frame_dig -1
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/pieout/subroutines.py:176-181
    // # Emit ARC-28 event for off-chain tracking
    // arc4.emit(
    //     "game_live(bool,uint64)",
    //     game_state.staking_finalized,
    //     game_state.expiry_ts,
    // )
    concat
    pushbytes 0xf1f3294a // method "game_live(bool,uint64)"
    swap
    concat
    log
    // smart_contracts/pieout/subroutines.py:183
    // return arc4.Bool(True)  # noqa: FBT003
    pushbytes 0x80
    frame_dig -1
    retsub

is_game_live_else_body@7:
    // smart_contracts/pieout/subroutines.py:185
    // return arc4.Bool(False)  # noqa: FBT003
    bytec_0 // 0x00
    frame_dig -1
    retsub


// smart_contracts.pieout.contract.Pieout.calc_single_box_fee(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_fee:
    // smart_contracts/pieout/contract.py:46-50
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_fee(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/pieout/contract.py:55
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/pieout/contract.py:54
    // size_fee = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/pieout/contract.py:54-56
    // size_fee = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/pieout/contract.py:58-59
    // # Return single box fee
    // return base_fee.native + size_fee
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.pieout.contract.Pieout.read_game_state(game_id: uint64) -> bytes:
read_game_state:
    // smart_contracts/pieout/contract.py:66-68
    // # Read the smart contract application game state box for given game id
    // @arc4.abimethod(readonly=True)
    // def read_game_state(self, game_id: UInt64) -> ta.GameStateTuple:
    proto 1 1
    // smart_contracts/pieout/contract.py:71
    // game_id
    frame_dig -1
    itob
    // smart_contracts/pieout/contract.py:69-70
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[
    bytec_3 // "s_"
    // smart_contracts/pieout/contract.py:69-72
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[
    //     game_id
    // ].copy()  # Make a copy of the game state data else immutable
    dig 1
    concat
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:78
    // game_state.staking_finalized,
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/pieout/contract.py:79
    // game_state.max_players,
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:80
    // game_state.active_players,
    dig 2
    extract 2 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:81
    // game_state.first_place_score,
    dig 3
    extract 3 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:82
    // game_state.second_place_score,
    dig 4
    extract 4 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:83
    // game_state.third_place_score,
    dig 5
    extract 5 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:84
    // game_state.box_p_start_pos,
    dig 6
    extract 6 2 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:85
    // game_state.expiry_ts,
    dig 7
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:86
    // game_state.prize_pool,
    dig 8
    extract 16 8 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:87
    // game_state.manager_address,
    dig 9
    extract 24 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:88
    // game_state.first_place_address,
    dig 10
    extract 56 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:89
    // game_state.second_place_address,
    dig 11
    extract 88 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:90
    // game_state.third_place_address,
    uncover 12
    extract 120 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:74-92
    // # Return the game state as a tuple
    // return ta.GameStateTuple(
    //     (
    //         arc4.UInt64(game_id),
    //         game_state.staking_finalized,
    //         game_state.max_players,
    //         game_state.active_players,
    //         game_state.first_place_score,
    //         game_state.second_place_score,
    //         game_state.third_place_score,
    //         game_state.box_p_start_pos,
    //         game_state.expiry_ts,
    //         game_state.prize_pool,
    //         game_state.manager_address,
    //         game_state.first_place_address,
    //         game_state.second_place_address,
    //         game_state.third_place_address,
    //     )
    // )
    uncover 13
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.pieout.contract.Pieout.read_game_players(game_id: uint64) -> bytes:
read_game_players:
    // smart_contracts/pieout/contract.py:94-96
    // # Read the smart contract application game players box for given game id
    // @arc4.abimethod(readonly=True)
    // def read_game_players(self, game_id: UInt64) -> ta.GamePlayersArr:
    proto 1 1
    intc_1 // 0
    dup
    // smart_contracts/pieout/contract.py:97-98
    // # Retrieve current game players from box using the game id parameter
    // game_players = self.box_game_players[game_id]
    frame_dig -1
    itob
    bytec_2 // "p_"
    swap
    concat
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_game_players entry exists
    // smart_contracts/pieout/contract.py:100
    // players = ta.GamePlayersArr()
    pushbytes 0x0000
    swap
    // smart_contracts/pieout/contract.py:101
    // for i in urange(0, game_players.length, cst.ADDRESS_SIZE):
    len
    intc_1 // 0

read_game_players_for_header@1:
    // smart_contracts/pieout/contract.py:101
    // for i in urange(0, game_players.length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 4
    <
    bz read_game_players_after_for@6
    // smart_contracts/pieout/contract.py:102
    // player_addr_bytes = op.extract(game_players, i, cst.ADDRESS_SIZE)
    frame_dig 2
    frame_dig 5
    intc_3 // 32
    extract3
    dup
    frame_bury 0
    // smart_contracts/pieout/contract.py:103
    // if player_addr_bytes != Bytes(cst.ZERO_ADDR_BYTES):
    bytec 10 // 0x0000000000000000000000000000000000000000000000000000000000000000
    !=
    frame_dig 3
    frame_bury 1
    bz read_game_players_after_if_else@4
    // smart_contracts/pieout/contract.py:105
    // players.append(arc4.Address(player_account))
    frame_dig 3
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    intc_3 // 32
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

read_game_players_after_if_else@4:
    frame_dig 1
    frame_bury 3
    // smart_contracts/pieout/contract.py:101
    // for i in urange(0, game_players.length, cst.ADDRESS_SIZE):
    frame_dig 5
    intc_3 // 32
    +
    frame_bury 5
    b read_game_players_for_header@1

read_game_players_after_for@6:
    // smart_contracts/pieout/contract.py:107
    // return players
    frame_dig 3
    frame_bury 0
    retsub


// smart_contracts.pieout.contract.Pieout.generate() -> void:
generate:
    // smart_contracts/pieout/contract.py:114-115
    // # Fail transaction unless the assertion below evaluates True
    // assert Txn.sender == Global.creator_address, err.INVALID_CREATOR
    txn Sender
    global CreatorAddress
    ==
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:117-118
    // # Assign Global State variables with their default starting value
    // self.game_id = UInt64(0)
    bytec 6 // "game_id"
    intc_1 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:119
    // self.commit_rand_salt_id = UInt64(0)
    bytec 7 // "commit_rand_salt_id"
    intc_1 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:120
    // self.ath_score = UInt64(0)
    bytec 9 // "ath_score"
    intc_1 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:121
    // self.ath_address = Global.zero_address
    bytec 8 // "ath_address"
    global ZeroAddress
    app_global_put
    retsub


// smart_contracts.pieout.contract.Pieout.mint_trophy(box_t_pay: uint64, mint_pay: uint64) -> bytes:
mint_trophy:
    // smart_contracts/pieout/contract.py:123-128
    // @arc4.abimethod
    // def mint_trophy(
    //     self,
    //     box_t_pay: gtxn.PaymentTransaction,
    //     mint_pay: gtxn.PaymentTransaction,
    // ) -> arc4.Address:
    proto 2 1
    // smart_contracts/pieout/contract.py:132
    // assert box_t_pay.amount >= cst.BOX_C_T_FEE, err.INVALID_BOX_PAY_FEE
    frame_dig -2
    gtxns Amount
    intc 4 // 19300
    >=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:133
    // assert box_t_pay.sender == Global.creator_address, err.INVALID_BOX_PAY_SENDER
    frame_dig -2
    gtxns Sender
    global CreatorAddress
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:135
    // box_t_pay.receiver == Global.current_application_address
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:134-136
    // assert (
    //     box_t_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:139
    // mint_pay.amount >= Global.asset_create_min_balance
    frame_dig -1
    gtxns Amount
    global AssetCreateMinBalance
    >=
    // smart_contracts/pieout/contract.py:138-140
    // assert (
    //     mint_pay.amount >= Global.asset_create_min_balance
    // ), err.INVALID_MINT_PAY_FEE
    assert // Insufficient funds. Mint pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:141
    // assert mint_pay.sender == Global.creator_address, err.INVALID_MINT_PAY_SENDER
    frame_dig -1
    gtxns Sender
    global CreatorAddress
    ==
    assert // Mint payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:143
    // mint_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:142-144
    // assert (
    //     mint_pay.receiver == Global.current_application_address
    // ), err.INVALID_MINT_PAY_RECEIVER
    assert // Mint payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:146-158
    // acfg_itxn = itxn.AssetConfig(
    //     total=1,
    //     unit_name="TRFY",
    //     asset_name="Gamename-ATH-Trophy",
    //     decimals=0,
    //     default_frozen=False,
    //     # url=,
    //     # metadata_hash=,
    //     manager=Global.current_application_address,
    //     # reserve=,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    // ).submit()
    itxn_begin
    // smart_contracts/pieout/contract.py:152-154
    // # url=,
    // # metadata_hash=,
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/pieout/contract.py:155-157
    // # reserve=,
    // freeze=Global.current_application_address,
    // clawback=Global.current_application_address,
    dupn 2
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetManager
    // smart_contracts/pieout/contract.py:151
    // default_frozen=False,
    intc_1 // 0
    itxn_field ConfigAssetDefaultFrozen
    // smart_contracts/pieout/contract.py:150
    // decimals=0,
    intc_1 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/pieout/contract.py:149
    // asset_name="Gamename-ATH-Trophy",
    pushbytes "Gamename-ATH-Trophy"
    itxn_field ConfigAssetName
    // smart_contracts/pieout/contract.py:148
    // unit_name="TRFY",
    pushbytes "TRFY"
    itxn_field ConfigAssetUnitName
    // smart_contracts/pieout/contract.py:147
    // total=1,
    intc_0 // 1
    itxn_field ConfigAssetTotal
    // smart_contracts/pieout/contract.py:146
    // acfg_itxn = itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/pieout/contract.py:146-158
    // acfg_itxn = itxn.AssetConfig(
    //     total=1,
    //     unit_name="TRFY",
    //     asset_name="Gamename-ATH-Trophy",
    //     decimals=0,
    //     default_frozen=False,
    //     # url=,
    //     # metadata_hash=,
    //     manager=Global.current_application_address,
    //     # reserve=,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/pieout/contract.py:160-161
    // # Create the box game trophy and Store the created asset ID as its as value
    // self.box_game_trophy.create()
    bytec_1 // 0x745f
    pushint 40 // 40
    box_create
    pop
    // smart_contracts/pieout/contract.py:163
    // asset_id=arc4.UInt64(acfg_itxn.created_asset.id),
    itob
    // smart_contracts/pieout/contract.py:164
    // owner_address=arc4.Address(Global.zero_address),
    global ZeroAddress
    // smart_contracts/pieout/contract.py:162-165
    // self.box_game_trophy.value = stc.GameTrophy(
    //     asset_id=arc4.UInt64(acfg_itxn.created_asset.id),
    //     owner_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:162
    // self.box_game_trophy.value = stc.GameTrophy(
    bytec_1 // 0x745f
    // smart_contracts/pieout/contract.py:162-165
    // self.box_game_trophy.value = stc.GameTrophy(
    //     asset_id=arc4.UInt64(acfg_itxn.created_asset.id),
    //     owner_address=arc4.Address(Global.zero_address),
    // )
    swap
    box_put
    // smart_contracts/pieout/contract.py:167
    // return self.box_game_trophy.value.owner_address
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    extract 8 32 // on error: Index access is out of bounds
    retsub


// smart_contracts.pieout.contract.Pieout.get_trophy() -> void:
get_trophy:
    // smart_contracts/pieout/contract.py:171
    // assert Global.group_size == 1, err.STANDALONE_TXN_ONLY
    global GroupSize
    intc_0 // 1
    ==
    assert // Invalid group size. This app call only appproves standalone transactions.
    // smart_contracts/pieout/contract.py:172-173
    // # assert Txn.sender == self.ath_address, "Only ATH address can be trophy receiver"
    // assert Txn.sender.is_opted_in(
    txn Sender
    // smart_contracts/pieout/contract.py:174
    // Asset(self.box_game_trophy.value.asset_id.native)
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    intc_1 // 0
    extract_uint64
    // smart_contracts/pieout/contract.py:172-175
    // # assert Txn.sender == self.ath_address, "Only ATH address can be trophy receiver"
    // assert Txn.sender.is_opted_in(
    //     Asset(self.box_game_trophy.value.asset_id.native)
    // ), "Sender needs to be opt-in to receieve trophy"
    asset_holding_get AssetBalance
    bury 1
    assert // Sender needs to be opt-in to receieve trophy
    // smart_contracts/pieout/contract.py:177-181
    // itxn.AssetTransfer(
    //     xfer_asset=self.box_game_trophy.value.asset_id.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=1,
    // ).submit()
    itxn_begin
    // smart_contracts/pieout/contract.py:178
    // xfer_asset=self.box_game_trophy.value.asset_id.native,
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    intc_1 // 0
    extract_uint64
    // smart_contracts/pieout/contract.py:179
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/pieout/contract.py:180
    // asset_amount=1,
    intc_0 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/pieout/contract.py:177
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/pieout/contract.py:177-181
    // itxn.AssetTransfer(
    //     xfer_asset=self.box_game_trophy.value.asset_id.native,
    //     asset_receiver=Txn.sender,
    //     asset_amount=1,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.pieout.contract.Pieout.new_game(max_players: uint64, box_s_pay: uint64, box_p_pay: uint64, stake_pay: uint64) -> void:
new_game:
    // smart_contracts/pieout/contract.py:183-191
    // # Create new game instance with the required box storage and stake payment transactions
    // @arc4.abimethod
    // def new_game(
    //     self,
    //     max_players: UInt64,
    //     box_s_pay: gtxn.PaymentTransaction,
    //     box_p_pay: gtxn.PaymentTransaction,
    //     stake_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 4 0
    // smart_contracts/pieout/contract.py:195
    // assert max_players <= cst.PLAYER_CAP, err.PLAYER_CAP_OVERFLOW
    frame_dig -4
    pushint 10 // 10
    <=
    assert // Player cap overflow. Max players limit must not be exceeded.
    // smart_contracts/pieout/contract.py:197
    // assert stake_pay.amount >= cst.STAKE_AMOUNT_MANAGER, err.INVALID_STAKE_PAY_FEE
    frame_dig -1
    gtxns Amount
    dup
    intc 6 // 1000
    >=
    assert // Insufficient funds. Stake pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:198
    // assert box_s_pay.amount >= cst.BOX_S_FEE, err.INVALID_BOX_PAY_FEE
    frame_dig -3
    gtxns Amount
    intc 10 // 67300
    >=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:199
    // assert box_p_pay.amount >= self.calc_single_box_fee(
    frame_dig -2
    gtxns Amount
    // smart_contracts/pieout/contract.py:201
    // value_size=arc4.UInt16(cst.ADDRESS_SIZE * max_players),
    intc_3 // 32
    frame_dig -4
    *
    dup
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/pieout/contract.py:200
    // key_size=arc4.UInt8(10),
    pushbytes 0x0a
    // smart_contracts/pieout/contract.py:199-202
    // assert box_p_pay.amount >= self.calc_single_box_fee(
    //     key_size=arc4.UInt8(10),
    //     value_size=arc4.UInt16(cst.ADDRESS_SIZE * max_players),
    // ), err.INVALID_BOX_PAY_FEE
    swap
    callsub calc_single_box_fee
    uncover 2
    <=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:204
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:205
    // assert box_s_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:206
    // assert box_p_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:209
    // stake_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:208-210
    // assert (
    //     stake_pay.receiver == Global.current_application_address
    // ), err.INVALID_STAKE_PAY_RECEIVER
    assert // Stake payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:212
    // box_s_pay.receiver == Global.current_application_address
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:211-213
    // assert (
    //     box_s_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:215
    // box_p_pay.receiver == Global.current_application_address
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:214-216
    // assert (
    //     box_p_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:221
    // max_players=arc4.UInt8(max_players),
    frame_dig -4
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/pieout/contract.py:227
    // expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    global LatestTimestamp
    intc 5 // 3600
    +
    itob
    // smart_contracts/pieout/contract.py:228
    // prize_pool=arc4.UInt64(stake_pay.amount),
    uncover 3
    itob
    // smart_contracts/pieout/contract.py:229
    // manager_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/pieout/contract.py:230
    // first_place_address=arc4.Address(Global.zero_address),
    global ZeroAddress
    // smart_contracts/pieout/contract.py:231-232
    // second_place_address=arc4.Address(Global.zero_address),
    // third_place_address=arc4.Address(Global.zero_address),
    dupn 2
    // smart_contracts/pieout/contract.py:220
    // staking_finalized=arc4.Bool(False),  # noqa: FBT003
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    uncover 7
    concat
    // smart_contracts/pieout/contract.py:222
    // active_players=arc4.UInt8(1),
    pushbytes 0x01
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:223
    // first_place_score=arc4.UInt8(0),
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:224
    // second_place_score=arc4.UInt8(0),
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:225
    // third_place_score=arc4.UInt8(0),
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:226
    // box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    bytec 11 // 0x0020
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/pieout/contract.py:218-219
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    intc_1 // 0
    bytec 6 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec_3 // "s_"
    swap
    concat
    // smart_contracts/pieout/contract.py:218-233
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(max_players),
    //     active_players=arc4.UInt8(1),
    //     first_place_score=arc4.UInt8(0),
    //     second_place_score=arc4.UInt8(0),
    //     third_place_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.EXPIRY_INTERVAL),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     first_place_address=arc4.Address(Global.zero_address),
    //     second_place_address=arc4.Address(Global.zero_address),
    //     third_place_address=arc4.Address(Global.zero_address),
    // )
    swap
    box_put
    // smart_contracts/pieout/contract.py:235-236
    // # Initialize box game players with zeroed bytes to store all player addresses (32 bytes per player)
    // self.box_game_players[self.game_id] = op.bzero(cst.ADDRESS_SIZE * max_players)
    bzero
    intc_1 // 0
    bytec 6 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec_2 // "p_"
    swap
    concat
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/pieout/contract.py:240
    // key=self.box_game_players.key_prefix + op.itob(self.game_id)
    intc_1 // 0
    bytec 6 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:238-241
    // # For game players box, replace the sender's address at index 0
    // game_players_bref = BoxRef(
    //     key=self.box_game_players.key_prefix + op.itob(self.game_id)
    // )
    swap
    // smart_contracts/pieout/contract.py:240
    // key=self.box_game_players.key_prefix + op.itob(self.game_id)
    concat
    // smart_contracts/pieout/contract.py:242
    // game_players_bref.replace(0, Txn.sender.bytes)
    intc_1 // 0
    txn Sender
    box_replace
    // smart_contracts/pieout/contract.py:244-245
    // # Increment game id by 1 for next new game instance
    // self.game_id += 1
    intc_1 // 0
    bytec 6 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    intc_0 // 1
    +
    bytec 6 // "game_id"
    swap
    app_global_put
    retsub


// smart_contracts.pieout.contract.Pieout.join_game(game_id: uint64, stake_pay: uint64) -> void:
join_game:
    // smart_contracts/pieout/contract.py:247-253
    // # Join existing game instance with required stake payment transaction
    // @arc4.abimethod
    // def join_game(
    //     self,
    //     game_id: UInt64,
    //     stake_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 2 0
    // smart_contracts/pieout/contract.py:254-256
    // # Fail transaction unless the assertion below evaluates True
    // # assert Global.group_size == 3, err.INVALID_GROUP_SIZE
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -2
    itob
    bytec_3 // "s_"
    dig 1
    concat
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:258
    // assert stake_pay.amount >= cst.STAKE_AMOUNT_OTHER, err.INVALID_STAKE_PAY_FEE
    frame_dig -1
    gtxns Amount
    dup
    pushint 258400 // 258400
    >=
    assert // Insufficient funds. Stake pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:259
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:261
    // stake_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:260-262
    // assert (
    //     stake_pay.receiver == Global.current_application_address
    // ), err.INVALID_STAKE_PAY_RECEIVER
    assert // Stake payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:264-267
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[
    //     game_id
    // ].copy()  # Make a copy of the game state else immutable
    dig 1
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:273
    // player_count=self.box_game_state[game_id].active_players.native,
    dig 2
    box_get
    assert // check self.box_game_state entry exists
    intc_2 // 2
    getbyte
    // smart_contracts/pieout/contract.py:270-275
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    // )
    frame_dig -2
    // smart_contracts/pieout/contract.py:272
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:270-275
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    // )
    uncover 2
    // smart_contracts/pieout/contract.py:274
    // clear_player=False,
    intc_1 // 0
    // smart_contracts/pieout/contract.py:270-275
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    // )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:270-276
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    // )
    // == False
    !
    // smart_contracts/pieout/contract.py:269-277
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=self.box_game_state[game_id].active_players.native,
    //         clear_player=False,
    //     )
    //     == False
    // ), err.PLAYER_ACTIVE
    assert // Transaction sender is already recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:279
    // assert game_state.staking_finalized == False, err.STAKING_FINAL  # noqa: E712
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    !
    assert // Game state staking finalized value mismatch.
    // smart_contracts/pieout/contract.py:280
    // assert game_state.expiry_ts >= Global.latest_timestamp, err.DEADLINE_EXPIRED
    dup
    extract 8 8 // on error: Index access is out of bounds
    global LatestTimestamp
    itob
    b>=
    assert // Phase deadline expired. Latest block timestamp must not exceed expiry timestamp.
    // smart_contracts/pieout/contract.py:281
    // assert game_state.active_players <= game_state.max_players, err.FULL_GAME_LOBBY
    dup
    extract 2 1 // on error: Index access is out of bounds
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    b<=
    assert // Number of active players must not exceed number of max players.
    // smart_contracts/pieout/contract.py:283
    // game_state.box_p_start_pos.native
    dup
    pushint 6 // 6
    extract_uint16
    // smart_contracts/pieout/contract.py:284
    // < cst.ADDRESS_SIZE * game_state.max_players.native
    dig 1
    intc_0 // 1
    getbyte
    intc_3 // 32
    *
    // smart_contracts/pieout/contract.py:283-284
    // game_state.box_p_start_pos.native
    // < cst.ADDRESS_SIZE * game_state.max_players.native
    dig 1
    >
    // smart_contracts/pieout/contract.py:282-285
    // assert (
    //     game_state.box_p_start_pos.native
    //     < cst.ADDRESS_SIZE * game_state.max_players.native
    // ), err.BOX_P_START_POS_OVERFLOW
    assert // Players box start position index overflow. Can not store more addresses.
    // smart_contracts/pieout/contract.py:289
    // key=self.box_game_players.key_prefix + op.itob(game_id)
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:287-290
    // # For game players box, store the sender's address at the current game state box p_ start position
    // game_players_bref = BoxRef(
    //     key=self.box_game_players.key_prefix + op.itob(game_id)
    // )
    uncover 5
    // smart_contracts/pieout/contract.py:289
    // key=self.box_game_players.key_prefix + op.itob(game_id)
    concat
    // smart_contracts/pieout/contract.py:291
    // game_players_bref.replace(game_state.box_p_start_pos.native, Txn.sender.bytes)
    txn Sender
    swap
    cover 2
    box_replace
    // smart_contracts/pieout/contract.py:293-294
    // # Increment number of active players by 1
    // game_state.active_players = arc4.UInt8(game_state.active_players.native + 1)
    dup
    intc_2 // 2
    getbyte
    intc_0 // 1
    +
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    replace2 2
    // smart_contracts/pieout/contract.py:298
    // game_state.box_p_start_pos.native + cst.ADDRESS_SIZE
    dup
    pushint 6 // 6
    extract_uint16
    intc_3 // 32
    +
    // smart_contracts/pieout/contract.py:296-299
    // # Increment current game players box offset by 32 so that next player address can be stored
    // game_state.box_p_start_pos = arc4.UInt16(
    //     game_state.box_p_start_pos.native + cst.ADDRESS_SIZE
    // )
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    replace2 6
    // smart_contracts/pieout/contract.py:303
    // game_state.prize_pool.native + stake_pay.amount
    dup
    pushint 16 // 16
    extract_uint64
    uncover 2
    +
    // smart_contracts/pieout/contract.py:301-304
    // # Increment prize pool by stake payment amount
    // game_state.prize_pool = arc4.UInt64(
    //     game_state.prize_pool.native + stake_pay.amount
    // )
    itob
    replace2 16
    // smart_contracts/pieout/contract.py:306-307
    // # Check if game is live on every call
    // srt.is_game_live(game_state)
    callsub is_game_live
    bury 1
    // smart_contracts/pieout/contract.py:309-310
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.get_box_commit_rand(box_c_pay: uint64) -> void:
get_box_commit_rand:
    // smart_contracts/pieout/contract.py:312-314
    // # Get box commit rand
    // @arc4.abimethod
    // def get_box_commit_rand(self, box_c_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/pieout/contract.py:315-317
    // # Fail transaction unless the assertion below evaluates True
    // # assert Global.group_size == 2, err.INVALID_GROUP_SIZE
    // assert Txn.sender not in self.box_commit_rand, err.COMMIT_RAND_BOX_MISSING
    bytec 4 // "c_"
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Box commit rand not found for sender address. Ensure commit rand was called.
    // smart_contracts/pieout/contract.py:319
    // assert box_c_pay.amount >= cst.BOX_C_T_FEE, err.INVALID_BOX_PAY_FEE
    frame_dig -1
    gtxns Amount
    intc 4 // 19300
    >=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:320
    // assert box_c_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:322
    // box_c_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:321-323
    // assert (
    //     box_c_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:325-326
    // # Initialize box commit rand with default commit round value
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    bytec 4 // "c_"
    txn Sender
    concat
    // smart_contracts/pieout/contract.py:327
    // commit_round=arc4.UInt64(0),
    pushbytes 0x0000000000000000
    // smart_contracts/pieout/contract.py:325-328
    // # Initialize box commit rand with default commit round value
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    //     commit_round=arc4.UInt64(0),
    // )
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.commit_rand(game_id: uint64) -> void:
commit_rand:
    // smart_contracts/pieout/contract.py:330-335
    // # Commit to obtaining the randomness seed reveal and store it in a box with sender address as key
    // @arc4.abimethod
    // def commit_rand(
    //     self,
    //     game_id: UInt64,
    // ) -> None:
    proto 1 0
    // smart_contracts/pieout/contract.py:336-337
    // # Fail transaction unless the assertion below evaluate True
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -1
    itob
    bytec_3 // "s_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:338
    // assert Txn.sender in self.box_commit_rand, err.COMMIT_RAND_BOX_MISSING
    bytec 4 // "c_"
    txn Sender
    concat
    box_len
    bury 1
    assert // Box commit rand not found for sender address. Ensure commit rand was called.
    // smart_contracts/pieout/contract.py:341
    // self.box_game_state[game_id].staking_finalized == True  # noqa: E712
    dup
    box_get
    assert // check self.box_game_state entry exists
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    // smart_contracts/pieout/contract.py:340-342
    // assert (
    //     self.box_game_state[game_id].staking_finalized == True  # noqa: E712
    // ), err.STAKING_FINAL
    assert // Game state staking finalized value mismatch.
    // smart_contracts/pieout/contract.py:348
    // player_count=self.box_game_state[game_id].max_players.native,
    box_get
    assert // check self.box_game_state entry exists
    intc_0 // 1
    getbyte
    // smart_contracts/pieout/contract.py:345-350
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    // )
    frame_dig -1
    // smart_contracts/pieout/contract.py:347
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:345-350
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    // )
    uncover 2
    // smart_contracts/pieout/contract.py:349
    // clear_player=False,
    intc_1 // 0
    // smart_contracts/pieout/contract.py:345-350
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    // )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:351
    // == True
    intc_0 // 1
    // smart_contracts/pieout/contract.py:345-351
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    // )
    // == True
    ==
    // smart_contracts/pieout/contract.py:344-352
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=self.box_game_state[game_id].max_players.native,
    //         clear_player=False,
    //     )
    //     == True
    // ), err.INVALID_PLAYER
    assert // Transaction sender is not recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:356
    // op.btoi(op.extract(op.sha256(Txn.tx_id + op.itob(Global.round)), 16, 2)) % 3
    txn TxID
    global Round
    itob
    concat
    sha256
    pushint 16 // 16
    extract_uint16
    pushint 3 // 3
    %
    // smart_contracts/pieout/contract.py:357
    // + 4
    pushint 4 // 4
    // smart_contracts/pieout/contract.py:356-357
    // op.btoi(op.extract(op.sha256(Txn.tx_id + op.itob(Global.round)), 16, 2)) % 3
    // + 4
    +
    // smart_contracts/pieout/contract.py:360-361
    // # Define commit rand commit round by adding round offset to current round
    // commit_round = Global.round + round_offset
    global Round
    +
    // smart_contracts/pieout/contract.py:365
    // commit_round=arc4.UInt64(commit_round),
    itob
    // smart_contracts/pieout/contract.py:363-364
    // # Store the commit round in the commit rand box
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    bytec 4 // "c_"
    txn Sender
    concat
    // smart_contracts/pieout/contract.py:363-366
    // # Store the commit round in the commit rand box
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    //     commit_round=arc4.UInt64(commit_round),
    // )
    swap
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.del_box_commit_rand() -> void:
del_box_commit_rand:
    // smart_contracts/pieout/contract.py:371-372
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 1, err.STANDALONE_TXN_ONLY
    global GroupSize
    intc_0 // 1
    ==
    assert // Invalid group size. This app call only appproves standalone transactions.
    // smart_contracts/pieout/contract.py:373
    // assert Txn.sender in self.box_commit_rand, err.COMMIT_RAND_BOX_MISSING
    bytec 4 // "c_"
    txn Sender
    concat
    box_len
    bury 1
    assert // Box commit rand not found for sender address. Ensure commit rand was called.
    // smart_contracts/pieout/contract.py:381-382
    // # Delete sender box commit rand box from contract storage
    // del self.box_commit_rand[Txn.sender]
    bytec 4 // "c_"
    txn Sender
    concat
    box_del
    pop
    // smart_contracts/pieout/contract.py:386
    // receiver=Txn.sender,
    txn Sender
    // smart_contracts/pieout/contract.py:387
    // amount=UInt64(cst.BOX_C_T_FEE),
    intc 4 // 19300
    // smart_contracts/pieout/contract.py:388-390
    // note=String(
    //     "sender:app_address,receiver:sender_address,concern:box_commit_rand_deletion"
    // ),
    pushbytes "sender:app_address,receiver:sender_address,concern:box_commit_rand_deletion"
    // smart_contracts/pieout/contract.py:384-391
    // # Submit inner transaction that refunds box commit MBR to sender address
    // srt.payout_itxn(
    //     receiver=Txn.sender,
    //     amount=UInt64(cst.BOX_C_T_FEE),
    //     note=String(
    //         "sender:app_address,receiver:sender_address,concern:box_commit_rand_deletion"
    //     ),
    // )
    callsub payout_itxn
    retsub


// smart_contracts.pieout.contract.Pieout.play_game(game_id: uint64) -> void:
play_game:
    // smart_contracts/pieout/contract.py:393-396
    // # NOTE: Consider sending commit rand and play game as group txn off chain
    // # Run play logic for an existing game instance
    // @arc4.abimethod
    // def play_game(self, game_id: UInt64) -> None:
    proto 1 0
    intc_1 // 0
    dupn 6
    pushbytes ""
    dupn 8

play_game_while_top@11:
    pushint 19610 // 19610
    global OpcodeBudget
    >
    bz play_game_after_while@16
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 12 // 0x068101
    itxn_field ApprovalProgram
    bytec 12 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b play_game_while_top@11

play_game_after_while@16:
    // smart_contracts/pieout/contract.py:400-402
    // # Fail transaction unless the assertion below evaluates True
    // # assert Global.group_size == 1, err.STANDALONE_TXN_ONLY
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -1
    itob
    dup
    frame_bury 1
    bytec_3 // "s_"
    swap
    concat
    dup
    frame_bury 0
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:403
    // assert Txn.sender in self.box_commit_rand, err.COMMIT_RAND_BOX_MISSING
    bytec 4 // "c_"
    txn Sender
    concat
    box_len
    bury 1
    assert // Box commit rand not found for sender address. Ensure commit rand was called.
    // smart_contracts/pieout/contract.py:409
    // player_count=self.box_game_state[game_id].max_players.native,
    dup
    box_get
    assert // check self.box_game_state entry exists
    intc_0 // 1
    getbyte
    // smart_contracts/pieout/contract.py:406-411
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    // )
    frame_dig -1
    // smart_contracts/pieout/contract.py:408
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:406-411
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    // )
    uncover 2
    // smart_contracts/pieout/contract.py:410
    // clear_player=True,
    intc_0 // 1
    // smart_contracts/pieout/contract.py:406-411
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    // )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:412
    // == True
    intc_0 // 1
    // smart_contracts/pieout/contract.py:406-412
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    // )
    // == True
    ==
    // smart_contracts/pieout/contract.py:405-413
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=self.box_game_state[game_id].max_players.native,
    //         clear_player=True,
    //     )
    //     == True
    // ), err.INVALID_PLAYER
    assert // Transaction sender is not recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:415-418
    // # Retrieve the game state value from its corresponding box using the game id parameter
    // game_state = self.box_game_state[
    //     game_id
    // ].copy()  # Make a copy of the game state else immutable
    box_get
    swap
    dup
    cover 2
    frame_bury 2
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:420-421
    // # Fail transaction unless the assertions below evaluate True
    // assert game_state.staking_finalized == True, err.STAKING_FINAL  # noqa: E712
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    assert // Game state staking finalized value mismatch.
    // smart_contracts/pieout/contract.py:422
    // assert game_state.expiry_ts >= Global.latest_timestamp, err.DEADLINE_EXPIRED
    extract 8 8 // on error: Index access is out of bounds
    global LatestTimestamp
    itob
    b>=
    assert // Phase deadline expired. Latest block timestamp must not exceed expiry timestamp.
    // smart_contracts/pieout/contract.py:424
    // assert self.box_game_trophy, "Trophy has not yet been minted."
    bytec_1 // 0x745f
    box_len
    bury 1
    assert // Trophy has not yet been minted.
    // smart_contracts/pieout/contract.py:425
    // assert self.box_game_trophy.value.asset_id != UInt64(0), "Asset must have valid ID."
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    extract 0 8 // on error: Index access is out of bounds
    intc_1 // 0
    itob
    b!=
    assert // Asset must have valid ID.
    // smart_contracts/pieout/contract.py:454
    // commit_rand_salt_id=self.commit_rand_salt_id,
    intc_1 // 0
    bytec 7 // "commit_rand_salt_id"
    app_global_get_ex
    swap
    frame_bury 9
    assert // check self.commit_rand_salt_id exists
    // smart_contracts/pieout/contract.py:456
    // player=Txn.sender,
    txn Sender
    frame_bury 4
    // smart_contracts/pieout/contract.py:457
    // seed=Txn.tx_id,  # Use VRF output as seed in TestNet/production case, else use Txn.tx_id
    txn TxID
    // smart_contracts/pieout/subroutines.py:90-91
    // # Initialize the PCG pseudo-random generator state using 8 bytes from the given seed
    // state = pcg16_init(seed=op.extract(seed, 16, 8))
    dup
    extract 16 8
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:21
    // assert seed.length == 8
    len
    pushint 8 // 8
    ==
    assert
    pushint 16 // 16
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    extract_uint64
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:155
    // state = __pcg32_step(UInt64(0), incr)
    intc_1 // 0
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:269
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    intc 7 // 6364136223846793005
    mulw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    intc 8 // 1442695040888963407
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:270
    // _high_add, low_add = op.addw(low_mul, incr)
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:156
    // _high_addw, state = op.addw(state, initial_state)
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:269
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    intc 7 // 6364136223846793005
    mulw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    intc 8 // 1442695040888963407
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:270
    // _high_add, low_add = op.addw(low_mul, incr)
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:198
    // result += arc4.UInt16(length).bytes
    pushbytes 0x00ff
    frame_bury 5
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:292
    // _addw_high, addw_low = op.addw(~value, 1)
    pushint 18446744073709486080 // 18446744073709486080
    intc_0 // 1
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:300
    // return value & ((1 << 32) - 1)
    intc 9 // 4294967295
    &
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:219
    // absolute_bound = (1 << bit_size) - lower_bound
    intc 11 // 65535
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:221
    // threshold = __mask_to_uint32(__uint64_twos(absolute_bound)) % absolute_bound
    %
    frame_bury 13
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    intc_1 // 0
    frame_bury 10
    frame_bury 12

play_game_for_header@20:
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    frame_dig 10
    // smart_contracts/pieout/subroutines.py:98
    // length=UInt64(255),  # Number of values generated is 255
    pushint 255 // 255
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    <
    bz play_game_after_for@25

play_game_while_top@22:
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:269
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    frame_dig 12
    dup
    intc 7 // 6364136223846793005
    mulw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:254
    // return __pcg32_step(state, UInt64(PCG_FIRST_INCREMENT)), __pcg32_output(state)
    intc 8 // 1442695040888963407
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:270
    // _high_add, low_add = op.addw(low_mul, incr)
    addw
    cover 2
    pop
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:279
    // __mask_to_uint32(((state >> 18) ^ state) >> 27), state >> 59
    dup
    pushint 18 // 18
    shr
    dig 1
    ^
    pushint 27 // 27
    shr
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:300
    // return value & ((1 << 32) - 1)
    intc 9 // 4294967295
    &
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:279
    // __mask_to_uint32(((state >> 18) ^ state) >> 27), state >> 59
    swap
    pushint 59 // 59
    shr
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:286
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    dup2
    shr
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:292
    // _addw_high, addw_low = op.addw(~value, 1)
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:286
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:300
    // return value & ((1 << 32) - 1)
    intc 9 // 4294967295
    &
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:286
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    |
    dup
    frame_bury 8
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:226
    // if candidate >= threshold:
    frame_dig 13
    >=
    bz play_game_after_if_else@24
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:228
    // op.itob((candidate % absolute_bound) + lower_bound),
    frame_dig 8
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:219
    // absolute_bound = (1 << bit_size) - lower_bound
    intc 11 // 65535
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:228
    // op.itob((candidate % absolute_bound) + lower_bound),
    %
    // smart_contracts/pieout/subroutines.py:96
    // lower_bound=UInt64(1),  # Lower bound is 1 (to disallow 0 as a value)
    intc_0 // 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:228
    // op.itob((candidate % absolute_bound) + lower_bound),
    +
    itob
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:227-231
    // result += op.extract(
    //     op.itob((candidate % absolute_bound) + lower_bound),
    //     truncate_start_cached,
    //     byte_size,
    // )
    extract 6 2
    frame_dig 5
    swap
    concat
    frame_bury 5
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    frame_dig 10
    intc_0 // 1
    +
    frame_bury 10
    frame_bury 12
    b play_game_for_header@20

play_game_after_if_else@24:
    frame_bury 12
    b play_game_while_top@22

play_game_after_for@25:
    // smart_contracts/pieout/subroutines.py:101-102
    // # Initialize the player's score
    // score = UInt64(0)
    intc_1 // 0
    frame_bury 11
    // smart_contracts/pieout/subroutines.py:104-105
    // # Iterate through the sequence as a byte array starting at byte index 2 (skip array header bytes)
    // for i in urange(2, sequence.bytes.length, 2):
    frame_dig 5
    len
    frame_bury 15
    intc_2 // 2
    frame_bury 10

play_game_for_header@27:
    // smart_contracts/pieout/subroutines.py:104-105
    // # Iterate through the sequence as a byte array starting at byte index 2 (skip array header bytes)
    // for i in urange(2, sequence.bytes.length, 2):
    frame_dig 10
    frame_dig 15
    <
    bz play_game_after_for@30
    // smart_contracts/pieout/subroutines.py:106-107
    // # Extract a 16-bit unsigned integer from the byte sequence
    // roll = op.extract_uint16(sequence.bytes[2:], i)
    intc_2 // 2
    frame_dig 15
    dup
    cover 2
    >=
    intc_2 // 2
    dig 2
    uncover 2
    select
    frame_dig 5
    swap
    uncover 2
    substring3
    frame_dig 10
    extract_uint16
    // smart_contracts/pieout/subroutines.py:109-110
    // # Stop accumulating score if the roll is below or equal to the elimination threshold
    // if roll <= cst.ELIM_THRESHOLD:
    pushint 10992 // 10992
    <=
    bnz play_game_after_for@30
    // smart_contracts/pieout/subroutines.py:113-114
    // # Increment score for each roll above the threshold
    // score += 1
    frame_dig 11
    intc_0 // 1
    +
    frame_bury 11
    // smart_contracts/pieout/subroutines.py:104-105
    // # Iterate through the sequence as a byte array starting at byte index 2 (skip array header bytes)
    // for i in urange(2, sequence.bytes.length, 2):
    frame_dig 10
    intc_2 // 2
    +
    frame_bury 10
    b play_game_for_header@27

play_game_after_for@30:
    // smart_contracts/pieout/subroutines.py:120
    // commit_rand_salt_id,
    frame_dig 9
    itob
    // smart_contracts/pieout/subroutines.py:122
    // arc4.UInt8(score),
    frame_dig 11
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    dup
    frame_bury 6
    // smart_contracts/pieout/subroutines.py:116-123
    // # Emit ARC-28 event for off-chain tracking
    // arc4.emit(
    //     "player_score(uint64,uint64,address,uint8)",
    //     game_id,
    //     commit_rand_salt_id,
    //     player,
    //     arc4.UInt8(score),
    // )
    frame_dig 1
    uncover 2
    concat
    frame_dig 4
    concat
    swap
    concat
    pushbytes 0x1cc2af51 // method "player_score(uint64,uint64,address,uint8)"
    swap
    concat
    log
    // smart_contracts/pieout/subroutines.py:127-128
    // # First Place
    // game_state.first_place_address == arc4.Address(Global.zero_address)
    frame_dig 2
    extract 56 32 // on error: Index access is out of bounds
    global ZeroAddress
    ==
    // smart_contracts/pieout/subroutines.py:127-129
    // # First Place
    // game_state.first_place_address == arc4.Address(Global.zero_address)
    // or score > game_state.first_place_score.native
    bnz play_game_if_body@32
    // smart_contracts/pieout/subroutines.py:129
    // or score > game_state.first_place_score.native
    frame_dig 2
    pushint 3 // 3
    getbyte
    frame_dig 11
    <
    // smart_contracts/pieout/subroutines.py:127-129
    // # First Place
    // game_state.first_place_address == arc4.Address(Global.zero_address)
    // or score > game_state.first_place_score.native
    bz play_game_else_body@33

play_game_if_body@32:
    // smart_contracts/pieout/subroutines.py:131-132
    // # Assign: Second -> Third
    // game_state.third_place_score = game_state.second_place_score
    frame_dig 2
    dup
    extract 4 1 // on error: Index access is out of bounds
    replace2 5
    // smart_contracts/pieout/subroutines.py:133
    // game_state.third_place_address = game_state.second_place_address
    dup
    extract 88 32 // on error: Index access is out of bounds
    replace2 120
    // smart_contracts/pieout/subroutines.py:134-135
    // # Assign: First -> Second
    // game_state.second_place_score = game_state.first_place_score
    dup
    extract 3 1 // on error: Index access is out of bounds
    replace2 4
    // smart_contracts/pieout/subroutines.py:136
    // game_state.second_place_address = game_state.first_place_address
    dup
    extract 56 32 // on error: Index access is out of bounds
    replace2 88
    // smart_contracts/pieout/subroutines.py:137-138
    // # Assign: Score -> First
    // game_state.first_place_score = arc4.UInt8(score)
    frame_dig 6
    replace2 3
    // smart_contracts/pieout/subroutines.py:139
    // game_state.first_place_address = arc4.Address(player)
    frame_dig 4
    replace2 56
    frame_bury 2

play_game_after_if_else@41:
    // smart_contracts/pieout/contract.py:460-461
    // # Increment commit rand salt id by 1
    // self.commit_rand_salt_id += 1
    intc_1 // 0
    bytec 7 // "commit_rand_salt_id"
    app_global_get_ex
    assert // check self.commit_rand_salt_id exists
    intc_0 // 1
    +
    bytec 7 // "commit_rand_salt_id"
    swap
    app_global_put
    // smart_contracts/pieout/contract.py:463-464
    // # If game state first place score is higher than the ath score
    // if game_state.first_place_score.native > self.ath_score:
    frame_dig 2
    pushint 3 // 3
    getbyte
    dup
    frame_bury 14
    intc_1 // 0
    bytec 9 // "ath_score"
    app_global_get_ex
    assert // check self.ath_score exists
    >
    bz play_game_after_if_else@7
    // smart_contracts/pieout/contract.py:465-466
    // # Update ath score, game state first place score is the new ath score
    // self.ath_score = game_state.first_place_score.native
    bytec 9 // "ath_score"
    frame_dig 14
    app_global_put
    // smart_contracts/pieout/contract.py:468-469
    // # If ath address is not equal to empty address, clawback trophy asset
    // if self.ath_address != Global.zero_address:
    intc_1 // 0
    bytec 8 // "ath_address"
    app_global_get_ex
    assert // check self.ath_address exists
    global ZeroAddress
    !=
    bz play_game_after_if_else@6
    // smart_contracts/pieout/contract.py:472
    // self.box_game_trophy.value.owner_address.native,
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:473
    // self.box_game_trophy.value.asset_id.native,
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    intc_1 // 0
    extract_uint64
    // smart_contracts/pieout/contract.py:470-474
    // # Look up an asset by its ID and retrieve its balance for the specified account
    // balance, did_exist = op.AssetHoldingGet.asset_balance(
    //     self.box_game_trophy.value.owner_address.native,
    //     self.box_game_trophy.value.asset_id.native,
    // )
    asset_holding_get AssetBalance
    swap
    frame_bury 7
    // smart_contracts/pieout/contract.py:476-477
    // # If asset did exist and its balance is one, perform clawback via asset transfer inner transaction
    // if did_exist and balance == 1:
    bz play_game_after_if_else@6
    frame_dig 7
    intc_0 // 1
    ==
    bz play_game_after_if_else@6
    // smart_contracts/pieout/contract.py:479
    // asset_id=self.box_game_trophy.value.asset_id.native,
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    intc_1 // 0
    extract_uint64
    // smart_contracts/pieout/contract.py:480
    // asset_sender=self.box_game_trophy.value.owner_address.native,
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:481
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/pieout/subroutines.py:29-34
    // itxn.AssetTransfer(
    //     asset_receiver=asset_receiver,
    //     xfer_asset=asset_id,
    //     asset_sender=asset_sender,
    //     asset_amount=1,
    // ).submit()
    itxn_begin
    // smart_contracts/pieout/subroutines.py:33
    // asset_amount=1,
    intc_0 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field AssetSender
    itxn_field XferAsset
    // smart_contracts/pieout/subroutines.py:29
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/pieout/subroutines.py:29-34
    // itxn.AssetTransfer(
    //     asset_receiver=asset_receiver,
    //     xfer_asset=asset_id,
    //     asset_sender=asset_sender,
    //     asset_amount=1,
    // ).submit()
    itxn_submit

play_game_after_if_else@6:
    // smart_contracts/pieout/contract.py:484-485
    // # Update ath address, transaction sender is the new ath address
    // self.ath_address = Txn.sender
    bytec 8 // "ath_address"
    txn Sender
    app_global_put
    // smart_contracts/pieout/contract.py:487-488
    // # Update trophy owner address, ath address is the new trophy asset owner address
    // self.box_game_trophy.value.owner_address = arc4.Address(self.ath_address)
    intc_1 // 0
    bytec 8 // "ath_address"
    app_global_get_ex
    assert // check self.ath_address exists
    bytec_1 // 0x745f
    box_get
    assert // check self.box_game_trophy exists
    swap
    replace2 8
    bytec_1 // 0x745f
    swap
    box_put

play_game_after_if_else@7:
    // smart_contracts/pieout/contract.py:492-493
    // # Decrement number of active players by 1
    // game_state.active_players = arc4.UInt8(game_state.active_players.native - 1)
    frame_dig 2
    dup
    intc_2 // 2
    getbyte
    intc_0 // 1
    -
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    replace2 2
    // smart_contracts/pieout/contract.py:498-499
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    frame_dig 0
    swap
    box_put
    retsub

play_game_else_body@33:
    // smart_contracts/pieout/subroutines.py:141-142
    // # Second Place
    // game_state.second_place_address == arc4.Address(Global.zero_address)
    frame_dig 2
    extract 88 32 // on error: Index access is out of bounds
    global ZeroAddress
    ==
    // smart_contracts/pieout/subroutines.py:141-143
    // # Second Place
    // game_state.second_place_address == arc4.Address(Global.zero_address)
    // or score > game_state.second_place_score.native
    bnz play_game_if_body@35
    // smart_contracts/pieout/subroutines.py:143
    // or score > game_state.second_place_score.native
    frame_dig 2
    pushint 4 // 4
    getbyte
    frame_dig 11
    <
    // smart_contracts/pieout/subroutines.py:141-143
    // # Second Place
    // game_state.second_place_address == arc4.Address(Global.zero_address)
    // or score > game_state.second_place_score.native
    bz play_game_else_body@36

play_game_if_body@35:
    // smart_contracts/pieout/subroutines.py:145-146
    // # Assign: Second -> Third
    // game_state.third_place_score = game_state.second_place_score
    frame_dig 2
    dup
    extract 4 1 // on error: Index access is out of bounds
    replace2 5
    // smart_contracts/pieout/subroutines.py:147
    // game_state.third_place_address = game_state.second_place_address
    dup
    extract 88 32 // on error: Index access is out of bounds
    replace2 120
    // smart_contracts/pieout/subroutines.py:148-149
    // # Assign: Score -> Second
    // game_state.second_place_score = arc4.UInt8(score)
    frame_dig 6
    replace2 4
    // smart_contracts/pieout/subroutines.py:150
    // game_state.second_place_address = arc4.Address(player)
    frame_dig 4
    replace2 88
    frame_bury 3

play_game_after_if_else@40:
    frame_dig 3
    frame_bury 2
    b play_game_after_if_else@41

play_game_else_body@36:
    // smart_contracts/pieout/subroutines.py:152-153
    // # Third Place
    // game_state.third_place_address == arc4.Address(Global.zero_address)
    frame_dig 2
    extract 120 32 // on error: Index access is out of bounds
    global ZeroAddress
    ==
    // smart_contracts/pieout/subroutines.py:152-154
    // # Third Place
    // game_state.third_place_address == arc4.Address(Global.zero_address)
    // or score > game_state.third_place_score.native
    bnz play_game_if_body@38
    // smart_contracts/pieout/subroutines.py:154
    // or score > game_state.third_place_score.native
    frame_dig 2
    dup
    pushint 5 // 5
    getbyte
    frame_dig 11
    <
    swap
    frame_bury 3
    // smart_contracts/pieout/subroutines.py:152-154
    // # Third Place
    // game_state.third_place_address == arc4.Address(Global.zero_address)
    // or score > game_state.third_place_score.native
    bz play_game_after_if_else@40

play_game_if_body@38:
    // smart_contracts/pieout/subroutines.py:156-157
    // # Assign: Score -> Third
    // game_state.third_place_score = arc4.UInt8(score)
    frame_dig 2
    frame_dig 6
    replace2 5
    // smart_contracts/pieout/subroutines.py:158
    // game_state.third_place_address = arc4.Address(player)
    frame_dig 4
    replace2 120
    frame_bury 3
    b play_game_after_if_else@40


// smart_contracts.pieout.contract.Pieout.check_game_event(game_id: uint64, game_event_id: bytes) -> bytes:
check_game_event:
    // smart_contracts/pieout/contract.py:501-503
    // # Allow an active player of a game to manually check a game event status
    // @arc4.abimethod
    // def check_game_event(self, game_id: UInt64, game_event_id: arc4.UInt8) -> arc4.Bool:
    proto 2 1
    intc_1 // 0
    // smart_contracts/pieout/contract.py:504-505
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 1, err.STANDALONE_TXN_ONLY
    global GroupSize
    intc_0 // 1
    ==
    assert // Invalid group size. This app call only appproves standalone transactions.
    // smart_contracts/pieout/contract.py:506
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -2
    itob
    dup
    bytec_3 // "s_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:508-511
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[
    //     game_id
    // ].copy()  # Make a copy of the game state else immutable
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:513-514
    // # If Game Event ID corresponds with event: Game Live
    // if game_event_id.native == 0:
    frame_dig -1
    btoi
    dup
    bnz check_game_event_else_body@2
    // smart_contracts/pieout/contract.py:519
    // player_count=game_state.max_players.native,
    frame_dig 2
    dup
    intc_0 // 1
    getbyte
    // smart_contracts/pieout/contract.py:516-521
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=game_state.max_players.native,
    //     clear_player=True,
    // )
    frame_dig -2
    // smart_contracts/pieout/contract.py:518
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:516-521
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=game_state.max_players.native,
    //     clear_player=True,
    // )
    uncover 2
    // smart_contracts/pieout/contract.py:520
    // clear_player=True,
    intc_0 // 1
    // smart_contracts/pieout/contract.py:516-521
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=game_state.max_players.native,
    //     clear_player=True,
    // )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:522
    // == True
    intc_0 // 1
    // smart_contracts/pieout/contract.py:516-522
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=game_state.max_players.native,
    //     clear_player=True,
    // )
    // == True
    ==
    // smart_contracts/pieout/contract.py:515-523
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=game_state.max_players.native,
    //         clear_player=True,
    //     )
    //     == True
    // ), err.INVALID_PLAYER
    assert // Transaction sender is not recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:525-526
    // # Check if game is live
    // is_game_live = srt.is_game_live(game_state)
    callsub is_game_live
    pop
    // smart_contracts/pieout/contract.py:527
    // return is_game_live
    frame_bury 0
    retsub

check_game_event_else_body@2:
    // smart_contracts/pieout/contract.py:529-530
    // # If Game Event ID corresponds with event: Game Over
    // elif game_event_id.native == 2:
    frame_dig 3
    intc_2 // 2
    ==
    assert // Game event not found. Check if Game Event ID is valid
    // smart_contracts/pieout/contract.py:531
    // assert game_state.staking_finalized == True, err.STAKING_FINAL  # noqa: E712
    frame_dig 2
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    assert // Game state staking finalized value mismatch.
    // smart_contracts/pieout/contract.py:532
    // assert game_state.expiry_ts < Global.latest_timestamp, err.DEADLINE_EXPIRED
    dup
    extract 8 8 // on error: Index access is out of bounds
    dup
    frame_bury 0
    global LatestTimestamp
    itob
    b<
    assert // Phase deadline expired. Latest block timestamp must not exceed expiry timestamp.
    // smart_contracts/pieout/contract.py:534
    // game_state.manager_address == Txn.sender
    extract 24 32 // on error: Index access is out of bounds
    txn Sender
    ==
    // smart_contracts/pieout/contract.py:534-537
    // game_state.manager_address == Txn.sender
    // or game_state.first_place_address == Txn.sender
    // or game_state.second_place_address == Txn.sender
    // or game_state.third_place_address == Txn.sender
    bnz check_game_event_bool_true@7
    // smart_contracts/pieout/contract.py:535
    // or game_state.first_place_address == Txn.sender
    frame_dig 2
    extract 56 32 // on error: Index access is out of bounds
    txn Sender
    ==
    // smart_contracts/pieout/contract.py:534-537
    // game_state.manager_address == Txn.sender
    // or game_state.first_place_address == Txn.sender
    // or game_state.second_place_address == Txn.sender
    // or game_state.third_place_address == Txn.sender
    bnz check_game_event_bool_true@7
    // smart_contracts/pieout/contract.py:536
    // or game_state.second_place_address == Txn.sender
    frame_dig 2
    extract 88 32 // on error: Index access is out of bounds
    txn Sender
    ==
    // smart_contracts/pieout/contract.py:534-537
    // game_state.manager_address == Txn.sender
    // or game_state.first_place_address == Txn.sender
    // or game_state.second_place_address == Txn.sender
    // or game_state.third_place_address == Txn.sender
    bnz check_game_event_bool_true@7
    // smart_contracts/pieout/contract.py:537
    // or game_state.third_place_address == Txn.sender
    frame_dig 2
    extract 120 32 // on error: Index access is out of bounds
    txn Sender
    ==
    // smart_contracts/pieout/contract.py:534-537
    // game_state.manager_address == Txn.sender
    // or game_state.first_place_address == Txn.sender
    // or game_state.second_place_address == Txn.sender
    // or game_state.third_place_address == Txn.sender
    bz check_game_event_bool_false@8

check_game_event_bool_true@7:
    intc_0 // 1

check_game_event_bool_merge@9:
    // smart_contracts/pieout/contract.py:533-538
    // assert (
    //     game_state.manager_address == Txn.sender
    //     or game_state.first_place_address == Txn.sender
    //     or game_state.second_place_address == Txn.sender
    //     or game_state.third_place_address == Txn.sender
    // ), err.UNAUTH_ADDR
    assert // Transaction sender is not an authorized caller.
    // smart_contracts/pieout/subroutines.py:195
    // game_state.expiry_ts < Global.latest_timestamp  # If deadline expired
    global LatestTimestamp
    itob
    frame_dig 0
    b>
    // smart_contracts/pieout/subroutines.py:195-196
    // game_state.expiry_ts < Global.latest_timestamp  # If deadline expired
    // or game_state.active_players.native == 0  # If no more active players
    bnz check_game_event_if_body@13
    // smart_contracts/pieout/subroutines.py:196
    // or game_state.active_players.native == 0  # If no more active players
    frame_dig 2
    intc_2 // 2
    getbyte
    // smart_contracts/pieout/subroutines.py:195-196
    // game_state.expiry_ts < Global.latest_timestamp  # If deadline expired
    // or game_state.active_players.native == 0  # If no more active players
    bnz check_game_event_else_body@14

check_game_event_if_body@13:
    // smart_contracts/pieout/subroutines.py:200
    // cst.ADDRESS_SIZE * game_state.max_players.native
    frame_dig 2
    dup
    intc_0 // 1
    getbyte
    intc_3 // 32
    *
    // smart_contracts/pieout/subroutines.py:198-201
    // # Clear box game players data by setting its value to all zeroes
    // box_game_players[game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * game_state.max_players.native
    // )
    bzero
    // smart_contracts/pieout/contract.py:540-541
    // # Check if game is over
    // is_game_over = srt.is_game_over(game_id, game_state, self.box_game_players)
    bytec_2 // "p_"
    // smart_contracts/pieout/subroutines.py:198-199
    // # Clear box game players data by setting its value to all zeroes
    // box_game_players[game_id] = op.bzero(
    frame_dig 1
    concat
    // smart_contracts/pieout/subroutines.py:198-201
    // # Clear box game players data by setting its value to all zeroes
    // box_game_players[game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * game_state.max_players.native
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/pieout/subroutines.py:203-204
    // # Mark game as over by setting active players to zero
    // game_state.active_players = arc4.UInt8(0)
    bytec_0 // 0x00
    replace2 2
    // smart_contracts/pieout/subroutines.py:209
    // game_state.first_place_score,
    dup
    extract 3 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/subroutines.py:210
    // game_state.first_place_address,
    dig 1
    extract 56 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/subroutines.py:211
    // game_state.second_place_address,
    dig 2
    extract 88 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/subroutines.py:212
    // game_state.third_place_address,
    dig 3
    extract 120 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/subroutines.py:206-213
    // # Emit ARC-28 event for off-chain tracking
    // arc4.emit(
    //     "game_over(uint8,address,address,address)",
    //     game_state.first_place_score,
    //     game_state.first_place_address,
    //     game_state.second_place_address,
    //     game_state.third_place_address,
    // )
    uncover 3
    dig 3
    concat
    dig 2
    concat
    dig 1
    concat
    pushbytes 0x410b2150 // method "game_over(uint8,address,address,address)"
    swap
    concat
    log
    // smart_contracts/pieout/subroutines.py:217
    // game_state.prize_pool.native * UInt64(50) // UInt64(100)
    uncover 3
    pushint 16 // 16
    extract_uint64
    dup
    pushint 50 // 50
    *
    pushint 100 // 100
    /
    // smart_contracts/pieout/subroutines.py:220
    // game_state.prize_pool.native * UInt64(30) // UInt64(100)
    dig 1
    pushint 30 // 30
    *
    pushint 100 // 100
    /
    // smart_contracts/pieout/subroutines.py:223
    // game_state.prize_pool.native - first_win_share - second_win_share
    uncover 2
    dig 2
    -
    // smart_contracts/pieout/subroutines.py:222-224
    // third_win_share = (
    //     game_state.prize_pool.native - first_win_share - second_win_share
    // )  # Third place gets remainder
    dig 1
    // smart_contracts/pieout/subroutines.py:223
    // game_state.prize_pool.native - first_win_share - second_win_share
    -
    // smart_contracts/pieout/subroutines.py:226-233
    // # Issue payouts to 1st, 2nd and 3rd place accounts
    // payout_itxn(
    //     receiver=game_state.first_place_address.native,
    //     amount=first_win_share,
    //     note=String(
    //         "sender:app_address,reciever:first_place_address,concern:prize_pool_first_win_share_payout"
    //     ),
    // )
    uncover 5
    uncover 3
    // smart_contracts/pieout/subroutines.py:230-232
    // note=String(
    //     "sender:app_address,reciever:first_place_address,concern:prize_pool_first_win_share_payout"
    // ),
    pushbytes "sender:app_address,reciever:first_place_address,concern:prize_pool_first_win_share_payout"
    // smart_contracts/pieout/subroutines.py:226-233
    // # Issue payouts to 1st, 2nd and 3rd place accounts
    // payout_itxn(
    //     receiver=game_state.first_place_address.native,
    //     amount=first_win_share,
    //     note=String(
    //         "sender:app_address,reciever:first_place_address,concern:prize_pool_first_win_share_payout"
    //     ),
    // )
    callsub payout_itxn
    // smart_contracts/pieout/subroutines.py:234-240
    // payout_itxn(
    //     receiver=game_state.second_place_address.native,
    //     amount=second_win_share,
    //     note=String(
    //         "sender:app_address,reciever:second_place_address,concern:prize_pool_second_win_share_payout"
    //     ),
    // )
    uncover 3
    uncover 2
    // smart_contracts/pieout/subroutines.py:237-239
    // note=String(
    //     "sender:app_address,reciever:second_place_address,concern:prize_pool_second_win_share_payout"
    // ),
    pushbytes "sender:app_address,reciever:second_place_address,concern:prize_pool_second_win_share_payout"
    // smart_contracts/pieout/subroutines.py:234-240
    // payout_itxn(
    //     receiver=game_state.second_place_address.native,
    //     amount=second_win_share,
    //     note=String(
    //         "sender:app_address,reciever:second_place_address,concern:prize_pool_second_win_share_payout"
    //     ),
    // )
    callsub payout_itxn
    // smart_contracts/pieout/subroutines.py:244-246
    // note=String(
    //     "sender:app_address,reciever:third_place_address,concern:prize_pool_third_win_share_payout"
    // ),
    pushbytes "sender:app_address,reciever:third_place_address,concern:prize_pool_third_win_share_payout"
    // smart_contracts/pieout/subroutines.py:241-247
    // payout_itxn(
    //     receiver=game_state.third_place_address.native,
    //     amount=third_win_share,
    //     note=String(
    //         "sender:app_address,reciever:third_place_address,concern:prize_pool_third_win_share_payout"
    //     ),
    // )
    callsub payout_itxn
    // smart_contracts/pieout/subroutines.py:252
    // return arc4.Bool(True)  # noqa: FBT003
    pushbytes 0x80

check_game_event_after_inlined_smart_contracts.pieout.subroutines.is_game_over@15:
    // smart_contracts/pieout/contract.py:542
    // return is_game_over
    frame_bury 0
    retsub

check_game_event_else_body@14:
    // smart_contracts/pieout/subroutines.py:254
    // return arc4.Bool(False)  # noqa: FBT003
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:540-541
    // # Check if game is over
    // is_game_over = srt.is_game_over(game_id, game_state, self.box_game_players)
    b check_game_event_after_inlined_smart_contracts.pieout.subroutines.is_game_over@15

check_game_event_bool_false@8:
    intc_1 // 0
    b check_game_event_bool_merge@9


// smart_contracts.pieout.contract.Pieout.reset_game(game_id: uint64, stake_pay: uint64) -> void:
reset_game:
    // smart_contracts/pieout/contract.py:547-552
    // @arc4.abimethod
    // def reset_game(
    //     self,
    //     game_id: UInt64,
    //     stake_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 2 0
    // smart_contracts/pieout/contract.py:553-554
    // # Fail transaction unless the assertions below evaluate True
    // assert Global.group_size == 2, err.INVALID_GROUP_SIZE
    global GroupSize
    intc_2 // 2
    ==
    assert // Invalid group size. Ensure number of transaction in group is within bounds.
    // smart_contracts/pieout/contract.py:555
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -2
    itob
    bytec_3 // "s_"
    dig 1
    concat
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:557
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:559
    // stake_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/pieout/contract.py:558-560
    // assert (
    //     stake_pay.receiver == Global.current_application_address
    // ), err.INVALID_STAKE_PAY_RECEIVER
    assert // Stake payment receiver address must match application address.
    // smart_contracts/pieout/contract.py:561
    // assert stake_pay.amount >= cst.STAKE_AMOUNT_MANAGER, err.INVALID_STAKE_PAY_FEE
    frame_dig -1
    gtxns Amount
    intc 6 // 1000
    >=
    assert // Insufficient funds. Stake pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:563-566
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[
    //     game_id
    // ].copy()  # Make a copy of the game state else immutable
    dup
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:568-569
    // # Fail transaction unless the assertion below evaluates True
    // assert game_state.staking_finalized == True, err.STAKING_FINAL  # noqa: E712
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    assert // Game state staking finalized value mismatch.
    // smart_contracts/pieout/contract.py:570
    // assert game_state.manager_address == Txn.sender, err.INVALID_MANAGER
    dup
    extract 24 32 // on error: Index access is out of bounds
    txn Sender
    ==
    assert // Transaction sender is not recognized as valid manager address for this game.
    // smart_contracts/pieout/contract.py:571
    // assert game_state.prize_pool.native == 0, err.NON_ZERO_PRIZE_POOL
    dup
    pushint 16 // 16
    extract_uint64
    !
    assert // Prize pool not empty. Amount in prize pool must be zero.
    // smart_contracts/pieout/contract.py:572
    // assert game_state.active_players.native == 0, err.NON_ZERO_ACTIVE_PLAYERS
    dup
    intc_2 // 2
    getbyte
    !
    assert // Game lobby not empty. Number of active players must be zero.
    // smart_contracts/pieout/contract.py:576
    // key=self.box_game_players.key_prefix + op.itob(game_id)
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:574-577
    // # For game players box, replace the sender's address at start index 0
    // game_players_bref = BoxRef(
    //     key=self.box_game_players.key_prefix + op.itob(game_id)
    // )
    uncover 3
    // smart_contracts/pieout/contract.py:576
    // key=self.box_game_players.key_prefix + op.itob(game_id)
    concat
    // smart_contracts/pieout/contract.py:578
    // game_players_bref.replace(0, Txn.sender.bytes)
    intc_1 // 0
    txn Sender
    box_replace
    // smart_contracts/pieout/contract.py:580
    // game_state.staking_finalized = arc4.Bool(False)  # noqa: FBT003
    intc_1 // 0
    dup
    setbit
    // smart_contracts/pieout/contract.py:581
    // game_state.active_players = arc4.UInt8(1)
    pushbytes 0x01
    replace2 2
    // smart_contracts/pieout/contract.py:582
    // game_state.first_place_score = arc4.UInt8(0)
    bytec_0 // 0x00
    replace2 3
    // smart_contracts/pieout/contract.py:583
    // game_state.second_place_score = arc4.UInt8(0)
    bytec_0 // 0x00
    replace2 4
    // smart_contracts/pieout/contract.py:584
    // game_state.third_place_score = arc4.UInt8(0)
    bytec_0 // 0x00
    replace2 5
    // smart_contracts/pieout/contract.py:585
    // game_state.box_p_start_pos = arc4.UInt16(cst.ADDRESS_SIZE)
    bytec 11 // 0x0020
    replace2 6
    // smart_contracts/pieout/contract.py:587
    // Global.latest_timestamp + cst.EXPIRY_INTERVAL
    global LatestTimestamp
    intc 5 // 3600
    +
    // smart_contracts/pieout/contract.py:586-588
    // game_state.expiry_ts = arc4.UInt64(
    //     Global.latest_timestamp + cst.EXPIRY_INTERVAL
    // )
    itob
    replace2 8
    // smart_contracts/pieout/contract.py:590
    // game_state.prize_pool.native + cst.STAKE_AMOUNT_MANAGER
    dup
    pushint 16 // 16
    extract_uint64
    intc 6 // 1000
    +
    // smart_contracts/pieout/contract.py:589-591
    // game_state.prize_pool = arc4.UInt64(
    //     game_state.prize_pool.native + cst.STAKE_AMOUNT_MANAGER
    // )
    itob
    replace2 16
    // smart_contracts/pieout/contract.py:592
    // game_state.first_place_address = arc4.Address(Global.zero_address)
    global ZeroAddress
    replace2 56
    // smart_contracts/pieout/contract.py:593
    // game_state.second_place_address = arc4.Address(Global.zero_address)
    global ZeroAddress
    replace2 88
    // smart_contracts/pieout/contract.py:594
    // game_state.third_place_address = arc4.Address(Global.zero_address)
    global ZeroAddress
    replace2 120
    // smart_contracts/pieout/contract.py:596-597
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.delete_game(game_id: uint64) -> void:
delete_game:
    // smart_contracts/pieout/contract.py:599-603
    // @arc4.abimethod
    // def delete_game(
    //     self,
    //     game_id: UInt64,
    // ) -> None:
    proto 1 0
    // smart_contracts/pieout/contract.py:604-605
    // # Fail transaction unless the assertions below evaluate True
    // assert Global.group_size == 1, err.STANDALONE_TXN_ONLY
    global GroupSize
    intc_0 // 1
    ==
    assert // Invalid group size. This app call only appproves standalone transactions.
    // smart_contracts/pieout/contract.py:606
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -1
    itob
    dup
    bytec_3 // "s_"
    swap
    concat
    dupn 2
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:608-611
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[
    //     game_id
    // ].copy()  # Make a copy of the game state else immutable
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:613-614
    // # Fail transaction unless the assertion below evaluates True
    // assert game_state.manager_address == Txn.sender, err.INVALID_MANAGER
    dup
    extract 24 32 // on error: Index access is out of bounds
    txn Sender
    ==
    assert // Transaction sender is not recognized as valid manager address for this game.
    // smart_contracts/pieout/contract.py:618
    // if game_state.active_players.native == 1:
    intc_2 // 2
    getbyte
    dup
    intc_0 // 1
    ==
    bz delete_game_else_body@2
    // smart_contracts/pieout/contract.py:619-624
    // txn_sender_in_game = srt.check_sender_in_game(
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=UInt64(1),
    //     clear_player=False,
    // )
    frame_dig -1
    // smart_contracts/pieout/contract.py:621
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:622
    // player_count=UInt64(1),
    intc_0 // 1
    // smart_contracts/pieout/contract.py:623
    // clear_player=False,
    intc_1 // 0
    // smart_contracts/pieout/contract.py:619-624
    // txn_sender_in_game = srt.check_sender_in_game(
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=UInt64(1),
    //     clear_player=False,
    // )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:626-627
    // # Fail transaction unless the assertion below evaluates True
    // assert txn_sender_in_game == True, err.MANAGER_SOLE_PLAYER  # noqa: E712
    intc_0 // 1
    ==
    assert // Manager account must be sole active player in game.
    // smart_contracts/pieout/contract.py:631
    // receiver=Txn.sender,
    txn Sender
    // smart_contracts/pieout/contract.py:632
    // amount=game_state.prize_pool.native,
    frame_dig 2
    pushint 16 // 16
    extract_uint64
    // smart_contracts/pieout/contract.py:633-635
    // note=String(
    //     "sender:app_address,receiver:manager_address,concern:prize_pool_payout"
    // ),
    pushbytes "sender:app_address,receiver:manager_address,concern:prize_pool_payout"
    // smart_contracts/pieout/contract.py:629-636
    // # Submit payout inner transaction
    // srt.payout_itxn(
    //     receiver=Txn.sender,
    //     amount=game_state.prize_pool.native,
    //     note=String(
    //         "sender:app_address,receiver:manager_address,concern:prize_pool_payout"
    //     ),
    // )
    callsub payout_itxn

delete_game_after_if_else@3:
    // smart_contracts/pieout/contract.py:643-644
    // # Delete box game state and box game players from contract storage
    // del self.box_game_state[game_id]
    frame_dig 1
    box_del
    pop
    // smart_contracts/pieout/contract.py:645
    // del self.box_game_players[game_id]
    bytec_2 // "p_"
    frame_dig 0
    concat
    box_del
    pop
    // smart_contracts/pieout/contract.py:650
    // value_size=arc4.UInt16(cst.ADDRESS_SIZE * game_state.max_players.native),
    frame_dig 2
    intc_0 // 1
    getbyte
    intc_3 // 32
    *
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/pieout/contract.py:649
    // key_size=arc4.UInt8(10),
    pushbytes 0x0a
    // smart_contracts/pieout/contract.py:647-651
    // # Calculate box game players fee
    // box_p_fee = self.calc_single_box_fee(
    //     key_size=arc4.UInt8(10),
    //     value_size=arc4.UInt16(cst.ADDRESS_SIZE * game_state.max_players.native),
    // )
    swap
    callsub calc_single_box_fee
    // smart_contracts/pieout/contract.py:655
    // receiver=Txn.sender,
    txn Sender
    // smart_contracts/pieout/contract.py:656
    // amount=cst.BOX_S_FEE + box_p_fee,
    intc 10 // 67300
    uncover 2
    +
    // smart_contracts/pieout/contract.py:657-659
    // note=String(
    //     "sender:app_address,receiver:manager_address,concern:box_s_refund,box_p_refund"
    // ),
    pushbytes "sender:app_address,receiver:manager_address,concern:box_s_refund,box_p_refund"
    // smart_contracts/pieout/contract.py:653-660
    // # Submit payout inner transaction
    // srt.payout_itxn(
    //     receiver=Txn.sender,
    //     amount=cst.BOX_S_FEE + box_p_fee,
    //     note=String(
    //         "sender:app_address,receiver:manager_address,concern:box_s_refund,box_p_refund"
    //     ),
    // )
    callsub payout_itxn
    retsub

delete_game_else_body@2:
    // smart_contracts/pieout/contract.py:639-640
    // # Fail transaction unless the assertion below evaluates True
    // assert game_state.active_players.native == 0, err.NON_ZERO_ACTIVE_PLAYERS
    frame_dig 3
    !
    assert // Game lobby not empty. Number of active players must be zero.
    // smart_contracts/pieout/contract.py:641
    // assert game_state.prize_pool.native == 0, err.NON_ZERO_PRIZE_POOL
    frame_dig 2
    pushint 16 // 16
    extract_uint64
    !
    assert // Prize pool not empty. Amount in prize pool must be zero.
    b delete_game_after_if_else@3


// smart_contracts.pieout.contract.Pieout.terminate() -> void:
terminate:
    // smart_contracts/pieout/contract.py:665-666
    // # Fail transaction unless the assertions below evaluate True
    // assert Txn.sender == Global.creator_address, err.INVALID_CREATOR
    txn Sender
    global CreatorAddress
    ==
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:667
    // assert TemplateVar[bool]("DELETABLE"), err.DELETEABLE_NOT_TRUE
    intc 13 // TMPL_DELETABLE
    assert // Template variable 'DELETABLE' needs to be 'True' at deploy-time.
    // smart_contracts/pieout/contract.py:669
    // del self.box_game_trophy.value
    bytec_1 // 0x745f
    box_del
    pop
    // smart_contracts/pieout/contract.py:673
    // receiver=Txn.sender,
    txn Sender
    // smart_contracts/pieout/contract.py:674
    // amount=UInt64(cst.BOX_C_T_FEE),
    intc 4 // 19300
    // smart_contracts/pieout/contract.py:675-677
    // note=String(
    //     "sender:app_address,receiver:manager_address,concern:box_t_refund"
    // ),
    pushbytes "sender:app_address,receiver:manager_address,concern:box_t_refund"
    // smart_contracts/pieout/contract.py:671-678
    // # Submit payout inner transaction
    // srt.payout_itxn(
    //     receiver=Txn.sender,
    //     amount=UInt64(cst.BOX_C_T_FEE),
    //     note=String(
    //         "sender:app_address,receiver:manager_address,concern:box_t_refund"
    //     ),
    // )
    callsub payout_itxn
    retsub
