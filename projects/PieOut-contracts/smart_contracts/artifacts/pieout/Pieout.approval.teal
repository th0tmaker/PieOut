#pragma version 10
#pragma typetrack false

// smart_contracts.pieout.contract.Pieout.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 2 32 6364136223846793005 1442695040888963407 4294967295 740600 65535 TMPL_GEN_UNIX TMPL_DELETABLE
    bytecblock 0x00 "s_" "p_" "game_id" 0x151f7c75 0x0000000000000000000000000000000000000000000000000000000000000000 0x0020 0x068101
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txn NumAppArgs
    bz main_after_if_else@17
    pushbytess 0x137d1094 0xb66d2f56 0xee030db4 0x7401ca83 0x5be219f0 0x102875e7 0xda7b6785 0x71af966e 0xc2d68aff 0x1a789ed0 0x8e856f92 0x5ff16da4 // method "calc_single_box_fee(uint8,uint16)uint64", method "read_gen_unix()uint64", method "read_game_state(uint64)(uint64,bool,uint8,uint8,uint8,uint16,uint64,address,address)", method "read_game_players(uint64)address[]", method "generate()void", method "reset_game(uint64,pay)void", method "new_game(uint64,pay,pay,pay)void", method "join_game(uint64,pay)void", method "commit_rand(uint64,pay)void", method "play_game(uint64)void", method "claim_prize_pool(uint64)void", method "terminate()void"
    txna ApplicationArgs 0
    match main_calc_single_box_fee_route@5 main_read_gen_unix_route@6 main_read_game_state_route@7 main_read_game_players_route@8 main_generate_route@9 main_reset_game_route@10 main_new_game_route@11 main_join_game_route@12 main_commit_rand_route@13 main_play_game_route@14 main_claim_prize_pool_route@15 main_terminate_route@16

main_after_if_else@17:
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    intc_1 // 0
    return

main_terminate_route@16:
    // smart_contracts/pieout/contract.py:639-640
    // # Allow application creator to delete the smart contract client
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub terminate
    intc_0 // 1
    return

main_claim_prize_pool_route@15:
    // smart_contracts/pieout/contract.py:331
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:331
    // @arc4.abimethod
    callsub claim_prize_pool
    intc_0 // 1
    return

main_play_game_route@14:
    // smart_contracts/pieout/contract.py:275
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:275
    // @arc4.abimethod
    callsub play_game
    intc_0 // 1
    return

main_commit_rand_route@13:
    // smart_contracts/pieout/contract.py:237
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:237
    // @arc4.abimethod
    callsub commit_rand
    intc_0 // 1
    return

main_join_game_route@12:
    // smart_contracts/pieout/contract.py:185
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:185
    // @arc4.abimethod
    callsub join_game
    intc_0 // 1
    return

main_new_game_route@11:
    // smart_contracts/pieout/contract.py:137
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:137
    // @arc4.abimethod
    callsub new_game
    intc_0 // 1
    return

main_reset_game_route@10:
    // smart_contracts/pieout/contract.py:106
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:106
    // @arc4.abimethod
    callsub reset_game
    intc_0 // 1
    return

main_generate_route@9:
    // smart_contracts/pieout/contract.py:94-95
    // # Generate the smart contract application client with default values
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return

main_read_game_players_route@8:
    // smart_contracts/pieout/contract.py:79-80
    // # Read the smart contract application game players box for given game id
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:79-80
    // # Read the smart contract application game players box for given game id
    // @arc4.abimethod(readonly=True)
    callsub read_game_players
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_game_state_route@7:
    // smart_contracts/pieout/contract.py:60-61
    // # Read the smart contract application game state box for given game id
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pieout/contract.py:60-61
    // # Read the smart contract application game state box for given game id
    // @arc4.abimethod(readonly=True)
    callsub read_game_state
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_gen_unix_route@6:
    // smart_contracts/pieout/contract.py:55-56
    // # Read the smart contract application genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:58
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 9 // TMPL_GEN_UNIX
    // smart_contracts/pieout/contract.py:55-56
    // # Read the smart contract application genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calc_single_box_fee_route@5:
    // smart_contracts/pieout/contract.py:40-41
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:28
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pieout/contract.py:40-41
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_fee
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.pieout.subroutines.check_sender_in_game(game_id: uint64, box_game_players: bytes, player_count: uint64, clear_player: uint64) -> uint64:
check_sender_in_game:
    // smart_contracts/pieout/subroutines.py:9-15
    // @subroutine
    // def check_sender_in_game(
    //     game_id: UInt64,
    //     box_game_players: BoxMap[UInt64, Bytes],
    //     player_count: UInt64,
    //     clear_player: bool,  # noqa: FBT001
    // ) -> bool:
    proto 4 1
    pushbytes ""
    // smart_contracts/pieout/subroutines.py:16-17
    // # Retrieve current players addresses from box using the game id parameter
    // game_players = box_game_players[game_id]
    frame_dig -4
    itob
    frame_dig -3
    swap
    concat
    dup
    box_get
    assert // check BoxMap entry exists
    // smart_contracts/pieout/subroutines.py:19
    // game_players_length = player_count * cst.ADDRESS_SIZE
    frame_dig -2
    intc_3 // 32
    *
    // smart_contracts/pieout/subroutines.py:21-22
    // # Check if transaction sender is a recognized player of this game instance
    // txn_sender_in_game = False  # Flag to track if sender is already in game
    intc_1 // 0
    // smart_contracts/pieout/subroutines.py:24-25
    // # Iterate through the players box value, 32 bytes at a time, in order to access each player address
    // for i in urange(0, game_players_length, cst.ADDRESS_SIZE):
    dup

check_sender_in_game_for_header@1:
    // smart_contracts/pieout/subroutines.py:24-25
    // # Iterate through the players box value, 32 bytes at a time, in order to access each player address
    // for i in urange(0, game_players_length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 3
    <
    frame_dig 4
    frame_bury 0
    bz check_sender_in_game_after_for@8
    // smart_contracts/pieout/subroutines.py:26-27
    // # From players box value byte array, starting at position i, extract 32 bytes
    // player_addr_bytes = op.extract(game_players, i, cst.ADDRESS_SIZE)
    frame_dig 2
    frame_dig 5
    intc_3 // 32
    extract3
    // smart_contracts/pieout/subroutines.py:29-30
    // # If match between sender address bytes and player address bytes exists
    // if Txn.sender.bytes == player_addr_bytes:
    txn Sender
    ==
    bz check_sender_in_game_after_if_else@6
    // smart_contracts/pieout/subroutines.py:31
    // txn_sender_in_game = True  # Sender is already in game
    intc_0 // 1
    frame_bury 4
    // smart_contracts/pieout/subroutines.py:33-34
    // # Replace the player address bytes data with 32 zeroed bytes at position i
    // if clear_player:
    frame_dig -1
    bz check_sender_in_game_after_if_else@5
    // smart_contracts/pieout/subroutines.py:36
    // players_ref.replace(i, cst.ZERO_ADDR_BYTES)
    frame_dig 1
    frame_dig 5
    bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
    box_replace

check_sender_in_game_after_if_else@5:
    frame_dig 4
    frame_bury 0

check_sender_in_game_after_for@8:
    // smart_contracts/pieout/subroutines.py:40
    // return txn_sender_in_game
    retsub

check_sender_in_game_after_if_else@6:
    // smart_contracts/pieout/subroutines.py:24-25
    // # Iterate through the players box value, 32 bytes at a time, in order to access each player address
    // for i in urange(0, game_players_length, cst.ADDRESS_SIZE):
    frame_dig 5
    intc_3 // 32
    +
    frame_bury 5
    b check_sender_in_game_for_header@1


// smart_contracts.pieout.contract.Pieout.calc_single_box_fee(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_fee:
    // smart_contracts/pieout/contract.py:40-44
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_fee(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/pieout/contract.py:49
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/pieout/contract.py:48
    // size_fee = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/pieout/contract.py:48-50
    // size_fee = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/pieout/contract.py:52-53
    // # Return single box fee
    // return base_fee.native + size_fee
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.pieout.contract.Pieout.read_game_state(game_id: uint64) -> bytes:
read_game_state:
    // smart_contracts/pieout/contract.py:60-62
    // # Read the smart contract application game state box for given game id
    // @arc4.abimethod(readonly=True)
    // def read_game_state(self, game_id: UInt64) -> taa.GameStateTuple:
    proto 1 1
    // smart_contracts/pieout/contract.py:63-64
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[game_id].copy()  # Make a copy of the game state data else immutable
    frame_dig -1
    itob
    bytec_1 // "s_"
    dig 1
    concat
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:69
    // game_state.staking_finalized,
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/pieout/contract.py:70
    // game_state.max_players,
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:71
    // game_state.active_players,
    dig 2
    extract 2 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:72
    // game_state.high_score,
    dig 3
    extract 3 1 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:73
    // game_state.box_p_start_pos,
    dig 4
    extract 4 2 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:74
    // game_state.prize_pool,
    dig 5
    extract 6 8 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:75
    // game_state.manager_address,
    dig 6
    extract 14 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:76
    // game_state.winner_address,
    uncover 7
    extract 46 32 // on error: Index access is out of bounds
    // smart_contracts/pieout/contract.py:66-77
    // # Return the game state as a tuple
    // return taa.GameStateTuple((
    //     arc4.UInt64(game_id),
    //     game_state.staking_finalized,
    //     game_state.max_players,
    //     game_state.active_players,
    //     game_state.high_score,
    //     game_state.box_p_start_pos,
    //     game_state.prize_pool,
    //     game_state.manager_address,
    //     game_state.winner_address,
    // ))
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.pieout.contract.Pieout.read_game_players(game_id: uint64) -> bytes:
read_game_players:
    // smart_contracts/pieout/contract.py:79-81
    // # Read the smart contract application game players box for given game id
    // @arc4.abimethod(readonly=True)
    // def read_game_players(self, game_id: UInt64) -> taa.GamePlayersArr:
    proto 1 1
    intc_1 // 0
    dup
    // smart_contracts/pieout/contract.py:82-83
    // # Retrieve current game players from box using the game id parameter
    // game_players = self.box_game_players[game_id]
    frame_dig -1
    itob
    bytec_2 // "p_"
    swap
    concat
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_game_players entry exists
    // smart_contracts/pieout/contract.py:85
    // players = taa.GamePlayersArr()
    pushbytes 0x0000
    swap
    // smart_contracts/pieout/contract.py:86
    // for i in urange(0, game_players.length, cst.ADDRESS_SIZE):
    len
    intc_1 // 0

read_game_players_for_header@1:
    // smart_contracts/pieout/contract.py:86
    // for i in urange(0, game_players.length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 4
    <
    bz read_game_players_after_for@6
    // smart_contracts/pieout/contract.py:87
    // player_addr_bytes = op.extract(game_players, i, cst.ADDRESS_SIZE)
    frame_dig 2
    frame_dig 5
    intc_3 // 32
    extract3
    dup
    frame_bury 0
    // smart_contracts/pieout/contract.py:88
    // if player_addr_bytes != Bytes(cst.ZERO_ADDR_BYTES):
    bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
    !=
    frame_dig 3
    frame_bury 1
    bz read_game_players_after_if_else@4
    // smart_contracts/pieout/contract.py:90
    // players.append(arc4.Address(player_account))
    frame_dig 3
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    intc_3 // 32
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

read_game_players_after_if_else@4:
    frame_dig 1
    frame_bury 3
    // smart_contracts/pieout/contract.py:86
    // for i in urange(0, game_players.length, cst.ADDRESS_SIZE):
    frame_dig 5
    intc_3 // 32
    +
    frame_bury 5
    b read_game_players_for_header@1

read_game_players_after_for@6:
    // smart_contracts/pieout/contract.py:92
    // return players
    frame_dig 3
    frame_bury 0
    retsub


// smart_contracts.pieout.contract.Pieout.generate() -> void:
generate:
    // smart_contracts/pieout/contract.py:99-100
    // # Fail transaction unless the assertion below evaluates True
    // assert Txn.sender == Global.creator_address, err.INVALID_CREATOR
    txn Sender
    global CreatorAddress
    ==
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:102-103
    // # Assign Global State variables with their default starting value
    // self.game_id = UInt64(0)
    bytec_3 // "game_id"
    intc_1 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:104
    // self.vrf_commit_id = UInt64(0)
    pushbytes "vrf_commit_id"
    intc_1 // 0
    app_global_put
    retsub


// smart_contracts.pieout.contract.Pieout.reset_game(game_id: uint64, stake_pay: uint64) -> void:
reset_game:
    // smart_contracts/pieout/contract.py:106-111
    // @arc4.abimethod
    // def reset_game(
    //     self,
    //     game_id: UInt64,
    //     stake_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 2 0
    // smart_contracts/pieout/contract.py:112-113
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[game_id].copy()  # Make a copy of the game state else immutable
    frame_dig -2
    itob
    bytec_1 // "s_"
    swap
    concat
    dup
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:115-116
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    dig 1
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:117
    // assert game_state.manager_address == Txn.sender, err.INVALID_MANAGER
    dup
    extract 14 32 // on error: Index access is out of bounds
    txn Sender
    ==
    assert // Transaction sender is not recognized as valid manager address for this game.
    // smart_contracts/pieout/contract.py:118
    // assert game_state.staking_finalized == True, err.STAKING_FINAL  # noqa: E712
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    assert // Game state staking finalized value missmatch.
    // smart_contracts/pieout/contract.py:119
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:120
    // assert stake_pay.receiver == Global.current_application_address, err.INVALID_STAKE_PAY_RECIEVER
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Stake payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:121
    // assert stake_pay.amount >= cst.STAKE_AMOUNT_MANAGER, err.INVALID_STAKE_PAY_FEE
    frame_dig -1
    gtxns Amount
    intc 7 // 740600
    >=
    assert // Insufficient funds. Stake pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:125
    // game_players_ref.replace(0, Txn.sender.bytes)
    txn Sender
    dig 2
    intc_1 // 0
    uncover 2
    box_replace
    // smart_contracts/pieout/contract.py:127
    // game_state.staking_finalized = arc4.Bool(False)  # noqa: FBT003
    intc_1 // 0
    dup
    setbit
    // smart_contracts/pieout/contract.py:128
    // game_state.active_players = arc4.UInt8(1)
    pushbytes 0x01
    replace2 2
    // smart_contracts/pieout/contract.py:129
    // game_state.high_score = arc4.UInt8(0)
    bytec_0 // 0x00
    replace2 3
    // smart_contracts/pieout/contract.py:130
    // game_state.box_p_start_pos = arc4.UInt16(cst.ADDRESS_SIZE)
    bytec 6 // 0x0020
    replace2 4
    // smart_contracts/pieout/contract.py:131
    // game_state.prize_pool = arc4.UInt64(cst.STAKE_AMOUNT_MANAGER)
    pushbytes 0x00000000000b4cf8
    replace2 6
    // smart_contracts/pieout/contract.py:132
    // game_state.winner_address = arc4.Address(Global.zero_address)
    global ZeroAddress
    replace2 46
    // smart_contracts/pieout/contract.py:134-135
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.new_game(total_players: uint64, box_s_pay: uint64, box_p_pay: uint64, stake_pay: uint64) -> void:
new_game:
    // smart_contracts/pieout/contract.py:137-144
    // @arc4.abimethod
    // def new_game(
    //     self,
    //     total_players: UInt64,
    //     box_s_pay: gtxn.PaymentTransaction,
    //     box_p_pay: gtxn.PaymentTransaction,
    //     stake_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 4 0
    // smart_contracts/pieout/contract.py:145-146
    // # Fail transaction unless the assertion below evaluates True
    // assert total_players <= cst.PLAYER_CAP, err.PLAYER_CAP_OVERFLOW
    frame_dig -4
    pushint 10 // 10
    <=
    assert // Player cap overflow. Max players limit must not be exceeded.
    // smart_contracts/pieout/contract.py:148
    // assert box_s_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:149
    // assert box_p_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:150
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:152
    // assert box_s_pay.receiver == Global.current_application_address, err.INVALID_BOX_PAY_RECIEVER
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Box payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:153
    // assert box_p_pay.receiver == Global.current_application_address, err.INVALID_BOX_PAY_RECIEVER
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Box payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:154
    // assert stake_pay.receiver == Global.current_application_address, err.INVALID_STAKE_PAY_RECIEVER
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Stake payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:156
    // assert box_s_pay.amount >= cst.BOX_S_FEE, err.INVALID_BOX_PAY_FEE
    frame_dig -3
    gtxns Amount
    pushint 24900 // 24900
    >=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:157
    // assert box_p_pay.amount >= self.calc_single_box_fee(
    frame_dig -2
    gtxns Amount
    // smart_contracts/pieout/contract.py:159
    // value_size=arc4.UInt16(cst.ADDRESS_SIZE * total_players)
    intc_3 // 32
    frame_dig -4
    *
    dup
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/pieout/contract.py:158
    // key_size=arc4.UInt8(10),
    pushbytes 0x0a
    // smart_contracts/pieout/contract.py:157-160
    // assert box_p_pay.amount >= self.calc_single_box_fee(
    //     key_size=arc4.UInt8(10),
    //     value_size=arc4.UInt16(cst.ADDRESS_SIZE * total_players)
    // ), err.INVALID_BOX_PAY_FEE
    swap
    callsub calc_single_box_fee
    uncover 2
    <=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:161
    // assert stake_pay.amount >= cst.STAKE_AMOUNT_MANAGER, err.INVALID_STAKE_PAY_FEE
    frame_dig -1
    gtxns Amount
    dup
    intc 7 // 740600
    >=
    assert // Insufficient funds. Stake pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:166
    // max_players=arc4.UInt8(total_players),
    frame_dig -4
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/pieout/contract.py:170
    // prize_pool=arc4.UInt64(stake_pay.amount),
    swap
    itob
    // smart_contracts/pieout/contract.py:171
    // manager_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/pieout/contract.py:172
    // winner_address=arc4.Address(Global.zero_address),
    global ZeroAddress
    // smart_contracts/pieout/contract.py:165
    // staking_finalized=arc4.Bool(False),  # noqa: FBT003
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:163-173
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(total_players),
    //     active_players=arc4.UInt8(1),
    //     high_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    uncover 4
    concat
    // smart_contracts/pieout/contract.py:167
    // active_players=arc4.UInt8(1),
    pushbytes 0x01
    // smart_contracts/pieout/contract.py:163-173
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(total_players),
    //     active_players=arc4.UInt8(1),
    //     high_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:168
    // high_score=arc4.UInt8(0),
    bytec_0 // 0x00
    // smart_contracts/pieout/contract.py:163-173
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(total_players),
    //     active_players=arc4.UInt8(1),
    //     high_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    // smart_contracts/pieout/contract.py:169
    // box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    bytec 6 // 0x0020
    // smart_contracts/pieout/contract.py:163-173
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(total_players),
    //     active_players=arc4.UInt8(1),
    //     high_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/pieout/contract.py:163-164
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    intc_1 // 0
    bytec_3 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec_1 // "s_"
    swap
    concat
    // smart_contracts/pieout/contract.py:163-173
    // # Initialize new game state by writing the default starting values and store them in game state box
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_finalized=arc4.Bool(False),  # noqa: FBT003
    //     max_players=arc4.UInt8(total_players),
    //     active_players=arc4.UInt8(1),
    //     high_score=arc4.UInt8(0),
    //     box_p_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     prize_pool=arc4.UInt64(stake_pay.amount),
    //     manager_address=arc4.Address(Txn.sender),
    //     winner_address=arc4.Address(Global.zero_address),
    // )
    swap
    box_put
    // smart_contracts/pieout/contract.py:175-176
    // # Initialize box with zeroed bytes to store all player addresses (32 bytes per player)
    // self.box_game_players[self.game_id] = op.bzero(cst.ADDRESS_SIZE * total_players)
    intc_1 // 0
    bytec_3 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec_2 // "p_"
    swap
    concat
    swap
    bzero
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/pieout/contract.py:178-179
    // # For game players box, replace the sender's address at index 0
    // game_players_ref = BoxRef(key=self.box_game_players.key_prefix + op.itob(self.game_id))
    intc_1 // 0
    bytec_3 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    itob
    bytec_2 // "p_"
    swap
    concat
    // smart_contracts/pieout/contract.py:180
    // game_players_ref.replace(0, Txn.sender.bytes)
    intc_1 // 0
    txn Sender
    box_replace
    // smart_contracts/pieout/contract.py:182-183
    // # Increment game id by 1 for next new game instance
    // self.game_id += 1
    intc_1 // 0
    bytec_3 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    intc_0 // 1
    +
    bytec_3 // "game_id"
    swap
    app_global_put
    retsub


// smart_contracts.pieout.contract.Pieout.join_game(game_id: uint64, stake_pay: uint64) -> void:
join_game:
    // smart_contracts/pieout/contract.py:185-190
    // @arc4.abimethod
    // def join_game(
    //     self,
    //     game_id: UInt64,
    //     stake_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 2 0
    // smart_contracts/pieout/contract.py:191-192
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -2
    itob
    bytec_1 // "s_"
    dig 1
    concat
    dup
    cover 2
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:194
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:195
    // assert stake_pay.receiver == Global.current_application_address, err.INVALID_STAKE_PAY_RECIEVER
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Stake payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:196
    // assert stake_pay.amount >= cst.STAKE_AMOUNT_OTHER, err.INVALID_STAKE_PAY_FEE
    frame_dig -1
    gtxns Amount
    dup
    pushint 1000000 // 1000000
    >=
    assert // Insufficient funds. Stake pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:198-199
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[game_id].copy()  # Make a copy of the game state else immutable
    dig 1
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:205
    // player_count=self.box_game_state[game_id].active_players.native,
    uncover 2
    box_get
    assert // check self.box_game_state entry exists
    intc_2 // 2
    getbyte
    // smart_contracts/pieout/contract.py:202-207
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    //     )
    frame_dig -2
    // smart_contracts/pieout/contract.py:204
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:202-207
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    //     )
    uncover 2
    // smart_contracts/pieout/contract.py:206
    // clear_player=False,
    intc_1 // 0
    // smart_contracts/pieout/contract.py:202-207
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    //     )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:202-208
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    //     )
    //     == False
    !
    // smart_contracts/pieout/contract.py:201-209
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=self.box_game_state[game_id].active_players.native,
    //         clear_player=False,
    //         )
    //         == False
    // ), err.PLAYER_ACTIVE
    assert // Transaction sender is already recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:211
    // assert game_state.active_players <= game_state.max_players, err.FULL_GAME_LOBBY
    dup
    extract 2 1 // on error: Index access is out of bounds
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    b<=
    assert // Number of active players must not exceed number of max players.
    // smart_contracts/pieout/contract.py:212
    // assert game_state.staking_finalized == False, err.STAKING_FINAL  # noqa: E712
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    !
    assert // Game state staking finalized value missmatch.
    // smart_contracts/pieout/contract.py:214
    // game_state.box_p_start_pos.native < cst.ADDRESS_SIZE * game_state.max_players.native
    dup
    pushint 4 // 4
    extract_uint16
    dig 1
    intc_0 // 1
    getbyte
    intc_3 // 32
    *
    dig 1
    >
    // smart_contracts/pieout/contract.py:213-215
    // assert (
    //     game_state.box_p_start_pos.native < cst.ADDRESS_SIZE * game_state.max_players.native
    // ), err.BOX_P_START_POS_OVERFLOW
    assert // Players box start position index overflow. Can not store more addresses.
    // smart_contracts/pieout/contract.py:217-218
    // # For game players box, store the sender's address at the current game state box p_ placement position
    // game_players_ref = BoxRef(key=self.box_game_players.key_prefix + op.itob(game_id))
    bytec_2 // "p_"
    uncover 4
    concat
    // smart_contracts/pieout/contract.py:219
    // game_players_ref.replace(game_state.box_p_start_pos.native, Txn.sender.bytes)
    txn Sender
    swap
    cover 2
    box_replace
    // smart_contracts/pieout/contract.py:221-222
    // # Increment number of active players by 1
    // game_state.active_players = arc4.UInt8(game_state.active_players.native + 1)
    dup
    intc_2 // 2
    getbyte
    intc_0 // 1
    +
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    replace2 2
    // smart_contracts/pieout/contract.py:224-225
    // # Increment current game players box offset by 32 so that next player address can be stored
    // game_state.box_p_start_pos = arc4.UInt16(game_state.box_p_start_pos.native + cst.ADDRESS_SIZE)
    dup
    pushint 4 // 4
    extract_uint16
    intc_3 // 32
    +
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    replace2 4
    // smart_contracts/pieout/contract.py:227-228
    // # Increment prize pool by stake payment amount
    // game_state.prize_pool = arc4.UInt64(game_state.prize_pool.native + stake_pay.amount)
    dup
    pushint 6 // 6
    extract_uint64
    uncover 2
    +
    itob
    replace2 6
    dupn 2
    // smart_contracts/pieout/contract.py:230-231
    // # If number of active players equals max players
    // if game_state.active_players == game_state.max_players:
    extract 2 1 // on error: Index access is out of bounds
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    b==
    bz join_game_after_if_else@2
    // smart_contracts/pieout/contract.py:232
    // game_state.staking_finalized = arc4.Bool(True)  # Finalize staking  # noqa: FBT003
    frame_dig 1
    intc_1 // 0
    intc_0 // 1
    setbit
    frame_bury 2

join_game_after_if_else@2:
    // smart_contracts/pieout/contract.py:234-235
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    frame_dig 0
    frame_dig 2
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.commit_rand(game_id: uint64, box_c_pay: uint64) -> void:
commit_rand:
    // smart_contracts/pieout/contract.py:237-242
    // @arc4.abimethod
    // def commit_rand(
    //     self,
    //     game_id: UInt64,
    //     box_c_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 2 0
    // smart_contracts/pieout/contract.py:243-244
    // # Fail transaction unless the assertions below evaluate True
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -2
    itob
    bytec_1 // "s_"
    dig 1
    concat
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:246
    // assert box_c_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:247
    // assert box_c_pay.receiver == Global.current_application_address, err.INVALID_BOX_PAY_RECIEVER
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Box payment reciever address must match application address.
    // smart_contracts/pieout/contract.py:248
    // assert box_c_pay.amount >= cst.BOX_C_FEE, err.INVALID_BOX_PAY_FEE
    frame_dig -1
    gtxns Amount
    pushint 22500 // 22500
    >=
    assert // Insufficient funds. Box pay amount is not enough to cover application MBR.
    // smart_contracts/pieout/contract.py:254
    // player_count=self.box_game_state[game_id].max_players.native,
    box_get
    assert // check self.box_game_state entry exists
    intc_0 // 1
    getbyte
    // smart_contracts/pieout/contract.py:251-256
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    //     )
    frame_dig -2
    // smart_contracts/pieout/contract.py:253
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:251-256
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    //     )
    uncover 2
    // smart_contracts/pieout/contract.py:255
    // clear_player=False,
    intc_1 // 0
    // smart_contracts/pieout/contract.py:251-256
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    //     )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:257
    // == True
    intc_0 // 1
    // smart_contracts/pieout/contract.py:251-257
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=False,
    //     )
    //     == True
    ==
    // smart_contracts/pieout/contract.py:250-258
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=self.box_game_state[game_id].max_players.native,
    //         clear_player=False,
    //         )
    //         == True
    // ), err.INVALID_PLAYER
    assert // Transaction sender is not recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:262
    // op.btoi(op.extract(op.sha256(Txn.tx_id + op.itob(Global.round)), 0, 2)) % 3
    txn TxID
    global Round
    itob
    concat
    sha256
    intc_1 // 0
    extract_uint16
    pushint 3 // 3
    %
    // smart_contracts/pieout/contract.py:263
    // + 2
    intc_2 // 2
    // smart_contracts/pieout/contract.py:262-263
    // op.btoi(op.extract(op.sha256(Txn.tx_id + op.itob(Global.round)), 0, 2)) % 3
    // + 2
    +
    // smart_contracts/pieout/contract.py:266-267
    // # Define VRF commit round by adding round offset to current round
    // commit_round = Global.round + round_offset
    global Round
    +
    // smart_contracts/pieout/contract.py:271
    // commit_round=arc4.UInt64(commit_round),
    itob
    // smart_contracts/pieout/contract.py:269-272
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    //     game_id=arc4.UInt64(game_id),
    //     commit_round=arc4.UInt64(commit_round),
    // )
    concat
    // smart_contracts/pieout/contract.py:269
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    pushbytes "c_"
    txn Sender
    concat
    // smart_contracts/pieout/contract.py:269-272
    // self.box_commit_rand[Txn.sender] = stc.CommitRand(
    //     game_id=arc4.UInt64(game_id),
    //     commit_round=arc4.UInt64(commit_round),
    // )
    swap
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.play_game(game_id: uint64) -> void:
play_game:
    // smart_contracts/pieout/contract.py:275-276
    // @arc4.abimethod
    // def play_game(self, game_id: UInt64) -> None:
    proto 1 0
    intc_1 // 0
    dupn 5
    pushbytes ""
    dupn 5

play_game_while_top@2:
    pushint 14010 // 14010
    global OpcodeBudget
    >
    bz play_game_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 7 // 0x068101
    itxn_field ApprovalProgram
    bytec 7 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b play_game_while_top@2

play_game_after_while@7:
    // smart_contracts/pieout/contract.py:280-281
    // # Fail transaction unless the assertions below evaluate True
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -1
    itob
    bytec_1 // "s_"
    swap
    concat
    dup
    frame_bury 5
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:286
    // player_count=self.box_game_state[game_id].max_players.native,
    dup
    box_get
    assert // check self.box_game_state entry exists
    intc_0 // 1
    getbyte
    // smart_contracts/pieout/contract.py:283-288
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    //     )
    frame_dig -1
    // smart_contracts/pieout/contract.py:285
    // box_game_players=self.box_game_players,
    bytec_2 // "p_"
    // smart_contracts/pieout/contract.py:283-288
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    //     )
    uncover 2
    // smart_contracts/pieout/contract.py:287
    // clear_player=True,
    intc_0 // 1
    // smart_contracts/pieout/contract.py:283-288
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    //     )
    callsub check_sender_in_game
    // smart_contracts/pieout/contract.py:289
    // == True
    intc_0 // 1
    // smart_contracts/pieout/contract.py:283-289
    // srt.check_sender_in_game(  # noqa: E712, RUF100
    //     game_id=game_id,
    //     box_game_players=self.box_game_players,
    //     player_count=self.box_game_state[game_id].max_players.native,
    //     clear_player=True,
    //     )
    //     == True
    ==
    // smart_contracts/pieout/contract.py:282-290
    // assert (
    //     srt.check_sender_in_game(  # noqa: E712, RUF100
    //         game_id=game_id,
    //         box_game_players=self.box_game_players,
    //         player_count=self.box_game_state[game_id].max_players.native,
    //         clear_player=True,
    //         )
    //         == True
    // ), err.INVALID_PLAYER
    assert // Transaction sender is not recognized as a valid player for this game.
    // smart_contracts/pieout/contract.py:292-293
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[game_id].copy()  # Make a copy of the game state else immutable
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:295-296
    // # Fail transaction unless the assertions below evaluate True
    // assert game_state.staking_finalized == True, err.STAKING_FINAL  # noqa: E712
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    assert // Game state staking finalized value missmatch.
    // smart_contracts/pieout/contract.py:298
    // srt.roll_score(Txn.tx_id, game_state, Txn.sender)
    txn TxID
    txn Sender
    frame_bury 3
    // smart_contracts/pieout/subroutines.py:45-46
    // # Take a portion of the seed to generate a sequence of random unsigned 16-bit integers
    // state = pcg16_init(seed=op.extract(seed, 16, 8))
    dup
    extract 16 8
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:21
    // assert seed.length == 8
    len
    pushint 8 // 8
    ==
    assert
    pushint 16 // 16
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    extract_uint64
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:155
    // state = __pcg32_step(UInt64(0), incr)
    intc_1 // 0
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:269
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    intc 4 // 6364136223846793005
    mulw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    intc 5 // 1442695040888963407
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:270
    // _high_add, low_add = op.addw(low_mul, incr)
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:156
    // _high_addw, state = op.addw(state, initial_state)
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:269
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    intc 4 // 6364136223846793005
    mulw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    intc 5 // 1442695040888963407
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:270
    // _high_add, low_add = op.addw(low_mul, incr)
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:198
    // result += arc4.UInt16(length).bytes
    pushbytes 0x0064
    frame_bury 4
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:292
    // _addw_high, addw_low = op.addw(~value, 1)
    pushint 18446744073709486080 // 18446744073709486080
    intc_0 // 1
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:300
    // return value & ((1 << 32) - 1)
    intc 6 // 4294967295
    &
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:219
    // absolute_bound = (1 << bit_size) - lower_bound
    intc 8 // 65535
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:221
    // threshold = __mask_to_uint32(__uint64_twos(absolute_bound)) % absolute_bound
    %
    frame_bury 10
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    intc_1 // 0
    frame_bury 7
    frame_bury 9

play_game_for_header@11:
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    frame_dig 7
    // smart_contracts/pieout/subroutines.py:51
    // length=UInt64(100),
    pushint 100 // 100
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    <
    bz play_game_after_for@16

play_game_while_top@13:
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:269
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    frame_dig 9
    dup
    intc 4 // 6364136223846793005
    mulw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:254
    // return __pcg32_step(state, UInt64(PCG_FIRST_INCREMENT)), __pcg32_output(state)
    intc 5 // 1442695040888963407
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:270
    // _high_add, low_add = op.addw(low_mul, incr)
    addw
    cover 2
    pop
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:279
    // __mask_to_uint32(((state >> 18) ^ state) >> 27), state >> 59
    dup
    pushint 18 // 18
    shr
    dig 1
    ^
    pushint 27 // 27
    shr
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:300
    // return value & ((1 << 32) - 1)
    intc 6 // 4294967295
    &
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:279
    // __mask_to_uint32(((state >> 18) ^ state) >> 27), state >> 59
    swap
    pushint 59 // 59
    shr
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:286
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    dup2
    shr
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:292
    // _addw_high, addw_low = op.addw(~value, 1)
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:286
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:300
    // return value & ((1 << 32) - 1)
    intc 6 // 4294967295
    &
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:286
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    |
    dup
    frame_bury 6
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:226
    // if candidate >= threshold:
    frame_dig 10
    >=
    bz play_game_after_if_else@15
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:228
    // op.itob((candidate % absolute_bound) + lower_bound),
    frame_dig 6
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:219
    // absolute_bound = (1 << bit_size) - lower_bound
    intc 8 // 65535
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:228
    // op.itob((candidate % absolute_bound) + lower_bound),
    %
    // smart_contracts/pieout/subroutines.py:49
    // lower_bound=UInt64(1),
    intc_0 // 1
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:228
    // op.itob((candidate % absolute_bound) + lower_bound),
    +
    itob
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:227-231
    // result += op.extract(
    //     op.itob((candidate % absolute_bound) + lower_bound),
    //     truncate_start_cached,
    //     byte_size,
    // )
    extract 6 2
    frame_dig 4
    swap
    concat
    frame_bury 4
    // .venv/Lib/site-packages/lib_pcg/pcg32.py:223
    // for i in urange(length):  # noqa: B007
    frame_dig 7
    intc_0 // 1
    +
    frame_bury 7
    frame_bury 9
    b play_game_for_header@11

play_game_after_if_else@15:
    frame_bury 9
    b play_game_while_top@13

play_game_after_for@16:
    // smart_contracts/pieout/subroutines.py:54
    // score = UInt64(0)
    intc_1 // 0
    frame_bury 8
    // smart_contracts/pieout/subroutines.py:55
    // for i in urange(2, sequence.bytes.length, 2):
    frame_dig 4
    len
    frame_bury 11
    intc_2 // 2
    frame_bury 7

play_game_for_header@18:
    // smart_contracts/pieout/subroutines.py:55
    // for i in urange(2, sequence.bytes.length, 2):
    frame_dig 7
    frame_dig 11
    <
    bz play_game_after_for@21
    // smart_contracts/pieout/subroutines.py:56
    // roll = op.extract_uint16(sequence.bytes[2:], i)
    intc_2 // 2
    frame_dig 11
    dup
    cover 2
    >=
    intc_2 // 2
    dig 2
    uncover 2
    select
    frame_dig 4
    swap
    uncover 2
    substring3
    frame_dig 7
    extract_uint16
    // smart_contracts/pieout/subroutines.py:58
    // if roll <= cst.ELIM_THRESHOLD:
    pushint 10992 // 10992
    <=
    bnz play_game_after_for@21
    // smart_contracts/pieout/subroutines.py:61
    // score += 1
    frame_dig 8
    intc_0 // 1
    +
    frame_bury 8
    // smart_contracts/pieout/subroutines.py:55
    // for i in urange(2, sequence.bytes.length, 2):
    frame_dig 7
    intc_2 // 2
    +
    frame_bury 7
    b play_game_for_header@18

play_game_after_for@21:
    // smart_contracts/pieout/subroutines.py:63
    // new_score = arc4.UInt8(score)
    frame_dig 8
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    dup
    frame_bury 2
    // smart_contracts/pieout/subroutines.py:64
    // if new_score > game_state.high_score:
    frame_dig 0
    dup
    cover 2
    extract 3 1 // on error: Index access is out of bounds
    b>
    swap
    frame_bury 1
    bz play_game_after_if_else@23
    // smart_contracts/pieout/subroutines.py:65
    // game_state.high_score = new_score
    frame_dig 0
    frame_dig 2
    replace2 3
    // smart_contracts/pieout/subroutines.py:66
    // game_state.winner_address = arc4.Address(player)
    frame_dig 3
    replace2 46
    frame_bury 1

play_game_after_if_else@23:
    frame_dig 1
    // smart_contracts/pieout/contract.py:300-301
    // # Decrement number of active players by 1
    // game_state.active_players = arc4.UInt8(game_state.active_players.native - 1)
    dup
    intc_2 // 2
    getbyte
    intc_0 // 1
    -
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    replace2 2
    // smart_contracts/pieout/contract.py:303-304
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    frame_dig 5
    swap
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.claim_prize_pool(game_id: uint64) -> void:
claim_prize_pool:
    // smart_contracts/pieout/contract.py:331-332
    // @arc4.abimethod
    // def claim_prize_pool(self, game_id: UInt64) -> None:
    proto 1 0
    // smart_contracts/pieout/contract.py:333-334
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert game_id in self.box_game_state, err.INVALID_GAME_ID
    frame_dig -1
    itob
    bytec_1 // "s_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Box game state not found. Check if Game ID is valid.
    // smart_contracts/pieout/contract.py:336-337
    // # Retrieve current game state from box using the game id parameter
    // game_state = self.box_game_state[game_id].copy()  # Make a copy of the game state else immutable
    dup
    box_get
    assert // check self.box_game_state entry exists
    // smart_contracts/pieout/contract.py:339-340
    // # Fail transaction unless the assertions below evaluate True
    // assert game_state.staking_finalized == True, err.STAKING_FINAL  # noqa: E712
    dup
    intc_1 // 0
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    assert // Game state staking finalized value missmatch.
    // smart_contracts/pieout/contract.py:341
    // assert game_state.active_players.native == 0, err.NON_ZERO_ACTIVE_PLAYERS
    dup
    intc_2 // 2
    getbyte
    !
    assert // Game lobby not empty. Number of active players must be zero.
    // smart_contracts/pieout/contract.py:342
    // assert game_state.winner_address == Txn.sender, err.INVALID_WINNER
    dup
    extract 46 32 // on error: Index access is out of bounds
    txn Sender
    ==
    assert // Transaction sender is not recognized as valid winner address for this game.
    // smart_contracts/pieout/contract.py:345-349
    // # Transaction sender (winner) recieves the prize pool amount via payment inner transaction
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=game_state.prize_pool.native,
    // ).submit()
    itxn_begin
    // smart_contracts/pieout/contract.py:347
    // receiver=Txn.sender,
    txn Sender
    // smart_contracts/pieout/contract.py:348
    // amount=game_state.prize_pool.native,
    dig 1
    pushint 6 // 6
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pieout/contract.py:345-346
    // # Transaction sender (winner) recieves the prize pool amount via payment inner transaction
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/pieout/contract.py:345-349
    // # Transaction sender (winner) recieves the prize pool amount via payment inner transaction
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=game_state.prize_pool.native,
    // ).submit()
    itxn_submit
    // smart_contracts/pieout/contract.py:351-352
    // # Set prize pool amount to zero
    // game_state.prize_pool = arc4.UInt64(0)
    pushbytes 0x0000000000000000
    replace2 6
    // smart_contracts/pieout/contract.py:354-355
    // # Copy the modified game state and store it as new value of box
    // self.box_game_state[game_id] = game_state.copy()
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.terminate() -> void:
terminate:
    // smart_contracts/pieout/contract.py:644
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/pieout/contract.py:642-645
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:647-649
    // assert TemplateVar[bool](
    //     "DELETABLE"
    // ), "Template variable 'DELETABLE' needs to be 'True' at deploy-time."
    intc 10 // TMPL_DELETABLE
    assert // Template variable 'DELETABLE' needs to be 'True' at deploy-time.
    retsub
