#pragma version 10
#pragma typetrack false

// smart_contracts.pieout.contract.Pieout.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 8 10 TMPL_GEN_UNIX TMPL_DELETABLE
    bytecblock "total_players" "players_elim" "players_pending" "pa_box_offset" "current_turn" "staking_finalized" 0x151f7c75 "total_stake" "creator_stake_status" 0x70615f 0x705f
    // smart_contracts/pieout/contract.py:30
    // class Pieout(ARC4Contract):
    txn NumAppArgs
    bz main_after_if_else@12
    pushbytess 0x137d1094 0x4ece0cfd 0x5be219f0 0xf6980206 0xd6233e1b 0x9336b098 0x5ff16da4 // method "calc_single_box_fee(uint8,uint16)uint64", method "get_gen_unix()uint64", method "generate()void", method "create_player_addrs_box(pay)void", method "stake(pay,pay)void", method "gamba()uint64", method "terminate()void"
    txna ApplicationArgs 0
    match main_calc_single_box_fee_route@5 main_get_gen_unix_route@6 main_generate_route@7 main_create_player_addrs_box_route@8 main_stake_route@9 main_gamba_route@10 main_terminate_route@11

main_after_if_else@12:
    // smart_contracts/pieout/contract.py:30
    // class Pieout(ARC4Contract):
    intc_0 // 0
    return

main_terminate_route@11:
    // smart_contracts/pieout/contract.py:273-274
    // # Allow application creator to delete the smart contract client
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub terminate
    intc_1 // 1
    return

main_gamba_route@10:
    // smart_contracts/pieout/contract.py:194-195
    // # NOTE: This method has to be called atomically in a group to prevent unfair advantages
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub gamba
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_stake_route@9:
    // smart_contracts/pieout/contract.py:115
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:30
    // class Pieout(ARC4Contract):
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:115
    // @arc4.abimethod
    callsub stake
    intc_1 // 1
    return

main_create_player_addrs_box_route@8:
    // smart_contracts/pieout/contract.py:90
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:30
    // class Pieout(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/pieout/contract.py:90
    // @arc4.abimethod
    callsub create_player_addrs_box
    intc_1 // 1
    return

main_generate_route@7:
    // smart_contracts/pieout/contract.py:71-72
    // # Generate the smart contract application client with default values
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_1 // 1
    return

main_get_gen_unix_route@6:
    // smart_contracts/pieout/contract.py:66-67
    // # Retrieve the genesis (creation) timestamp of the contract in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:69
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 4 // TMPL_GEN_UNIX
    // smart_contracts/pieout/contract.py:66-67
    // # Retrieve the genesis (creation) timestamp of the contract in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_calc_single_box_fee_route@5:
    // smart_contracts/pieout/contract.py:51-52
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pieout/contract.py:30
    // class Pieout(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pieout/contract.py:51-52
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_fee
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.pieout.contract.Pieout.calc_single_box_fee(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_fee:
    // smart_contracts/pieout/contract.py:51-55
    // # Calculate the minimum balance requirement (MBR) fee for data storage in a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_fee(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/pieout/contract.py:60
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/pieout/contract.py:59
    // size_fee = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/pieout/contract.py:59-61
    // size_fee = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/pieout/contract.py:63-64
    // # Return single box fee
    // return base_fee.native + size_fee
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.pieout.contract.Pieout.generate() -> void:
generate:
    // smart_contracts/pieout/contract.py:76
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/pieout/contract.py:74-77
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:79
    // self.total_players = UInt64(0)
    bytec_0 // "total_players"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:80
    // self.players_pending = UInt64(0)
    bytec_2 // "players_pending"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:81
    // self.players_elim = UInt64(0)
    bytec_1 // "players_elim"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:83
    // self.total_stake = UInt64(0)
    bytec 7 // "total_stake"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:84
    // self.creator_stake_status = UInt64(0)
    bytec 8 // "creator_stake_status"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:85
    // self.staking_finalized = UInt64(0)
    bytec 5 // "staking_finalized"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:87
    // self.pa_box_offset = UInt64(0)
    bytec_3 // "pa_box_offset"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:88
    // self.current_turn = UInt64(0)
    bytec 4 // "current_turn"
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.pieout.contract.Pieout.create_player_addrs_box(box_pay: uint64) -> void:
create_player_addrs_box:
    // smart_contracts/pieout/contract.py:90-91
    // @arc4.abimethod
    // def create_player_addrs_box(self, box_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/pieout/contract.py:92-93
    // # Get and store commonly used addresses
    // txn_sender = Txn.sender
    txn Sender
    // smart_contracts/pieout/contract.py:97
    // txn_sender == Global.creator_address
    dup
    global CreatorAddress
    ==
    // smart_contracts/pieout/contract.py:95-98
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     txn_sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:101
    // txn_sender == box_pay.sender
    frame_dig -1
    gtxns Sender
    ==
    // smart_contracts/pieout/contract.py:100-102
    // assert (
    //     txn_sender == box_pay.sender
    // ), "stake(): Box payment sender address must match transaction sender address."
    assert // stake(): Box payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:105
    // Global.current_application_address == box_pay.receiver
    global CurrentApplicationAddress
    frame_dig -1
    gtxns Receiver
    ==
    // smart_contracts/pieout/contract.py:104-106
    // assert (
    //     Global.current_application_address == box_pay.receiver
    // ), "stake(): Box payment reciever address must match transaction sender address."
    assert // stake(): Box payment reciever address must match transaction sender address.
    // smart_contracts/pieout/contract.py:108
    // assert box_pay.amount >= self.calc_single_box_fee(
    frame_dig -1
    gtxns Amount
    // smart_contracts/pieout/contract.py:109
    // key_size=arc4.UInt8(3), value_size=arc4.UInt16(320)
    pushbytess 0x03 0x0140 // 0x03, 0x0140
    // smart_contracts/pieout/contract.py:108-110
    // assert box_pay.amount >= self.calc_single_box_fee(
    //     key_size=arc4.UInt8(3), value_size=arc4.UInt16(320)
    // ), "stake(): Insufficient amount. Box pay amount does not cover application MBR."
    callsub calc_single_box_fee
    >=
    assert // stake(): Insufficient amount. Box pay amount does not cover application MBR.
    // smart_contracts/pieout/contract.py:112-113
    // # Create new box that will store every player address that staked
    // self.box_player_addrs[Bytes(b"pa_")] = op.bzero(320)
    pushint 320 // 320
    bzero
    bytec 9 // 0x70615f
    box_del
    pop
    bytec 9 // 0x70615f
    swap
    box_put
    retsub


// smart_contracts.pieout.contract.Pieout.stake(box_pay: uint64, stake_pay: uint64) -> void:
stake:
    // smart_contracts/pieout/contract.py:115-118
    // @arc4.abimethod
    // def stake(
    //     self, box_pay: gtxn.PaymentTransaction, stake_pay: gtxn.PaymentTransaction
    // ) -> None:
    proto 2 0
    intc_0 // 0
    // smart_contracts/pieout/contract.py:119-120
    // # Get and store commonly used addresses
    // txn_sender = Txn.sender
    txn Sender
    // smart_contracts/pieout/contract.py:121
    // app_address = Global.current_application_address
    global CurrentApplicationAddress
    // smart_contracts/pieout/contract.py:122
    // creator_address = Global.creator_address
    global CreatorAddress
    // smart_contracts/pieout/contract.py:125
    // self.staking_finalized == 0
    intc_0 // 0
    bytec 5 // "staking_finalized"
    app_global_get_ex
    assert // check self.staking_finalized exists
    !
    // smart_contracts/pieout/contract.py:124-126
    // assert (
    //     self.staking_finalized == 0
    // ), "stake(): Rejected. Can only stake when staking is not finalized."
    assert // stake(): Rejected. Can only stake when staking is not finalized.
    // smart_contracts/pieout/contract.py:128-129
    // # Fail transaction unless the assertion/s below evaluate/s True
    // if self.creator_stake_status == 0:
    intc_0 // 0
    bytec 8 // "creator_stake_status"
    app_global_get_ex
    assert // check self.creator_stake_status exists
    bnz stake_after_if_else@2
    // smart_contracts/pieout/contract.py:131
    // txn_sender == creator_address
    frame_dig 1
    frame_dig 3
    ==
    // smart_contracts/pieout/contract.py:130-132
    //     assert (
    //     txn_sender == creator_address
    // ), "stake(): Rejected. Application creator account must stake first before any other account."
    assert // stake(): Rejected. Application creator account must stake first before any other account.
    // smart_contracts/pieout/contract.py:134
    // self.creator_stake_status = UInt64(1)
    bytec 8 // "creator_stake_status"
    intc_1 // 1
    app_global_put

stake_after_if_else@2:
    // smart_contracts/pieout/contract.py:137
    // txn_sender not in self.box_player
    bytec 10 // 0x705f
    frame_dig 1
    dup
    cover 2
    concat
    dup
    frame_bury 0
    box_len
    bury 1
    !
    // smart_contracts/pieout/contract.py:136-138
    // assert (
    //     txn_sender not in self.box_player
    // ), "stake(): Transaction sender address already staked."
    assert // stake(): Transaction sender address already staked.
    // smart_contracts/pieout/contract.py:141
    // txn_sender == box_pay.sender and txn_sender == stake_pay.sender
    frame_dig -2
    gtxns Sender
    ==
    bz stake_bool_false@5
    frame_dig -1
    gtxns Sender
    frame_dig 1
    ==
    bz stake_bool_false@5
    intc_1 // 1

stake_bool_merge@6:
    // smart_contracts/pieout/contract.py:140-142
    // assert (
    //     txn_sender == box_pay.sender and txn_sender == stake_pay.sender
    // ), "stake(): Box and Stake payment sender address must match transaction sender address."
    assert // stake(): Box and Stake payment sender address must match transaction sender address.
    // smart_contracts/pieout/contract.py:145
    // app_address == box_pay.receiver and app_address == stake_pay.receiver
    frame_dig -2
    gtxns Receiver
    frame_dig 2
    ==
    bz stake_bool_false@9
    frame_dig -1
    gtxns Receiver
    frame_dig 2
    ==
    bz stake_bool_false@9
    intc_1 // 1

stake_bool_merge@10:
    // smart_contracts/pieout/contract.py:144-146
    // assert (
    //     app_address == box_pay.receiver and app_address == stake_pay.receiver
    // ), "stake(): Box and Stake payment reciever address must match transaction sender address."
    assert // stake(): Box and Stake payment reciever address must match transaction sender address.
    // smart_contracts/pieout/contract.py:148
    // assert box_pay.amount >= self.calc_single_box_fee(
    frame_dig -2
    gtxns Amount
    // smart_contracts/pieout/contract.py:149
    // key_size=arc4.UInt8(34), value_size=arc4.UInt16(3)
    pushbytess 0x22 0x0003 // 0x22, 0x0003
    // smart_contracts/pieout/contract.py:148-150
    // assert box_pay.amount >= self.calc_single_box_fee(
    //     key_size=arc4.UInt8(34), value_size=arc4.UInt16(3)
    // ), "stake(): Insufficient amount. Box pay amount does not cover application MBR."
    callsub calc_single_box_fee
    >=
    assert // stake(): Insufficient amount. Box pay amount does not cover application MBR.
    // smart_contracts/pieout/contract.py:153
    // stake_pay.amount == STAKE_AMOUNT
    frame_dig -1
    gtxns Amount
    dup
    pushint 200000 // 200000
    ==
    // smart_contracts/pieout/contract.py:152-154
    // assert (
    //     stake_pay.amount == STAKE_AMOUNT
    // ), "stake(): Insufficient amount. Stake pay amount does not cover minimum entry fee."
    assert // stake(): Insufficient amount. Stake pay amount does not cover minimum entry fee.
    // smart_contracts/pieout/contract.py:156
    // assert self.total_players < MAX_PLAYERS, "stake(): Max player limit exceeded."
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    intc_3 // 10
    <
    assert // stake(): Max player limit exceeded.
    // smart_contracts/pieout/contract.py:163
    // id=arc4.UInt8(self.total_players),
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/pieout/contract.py:164
    // turn=arc4.UInt8(self.current_turn),
    intc_0 // 0
    bytec 4 // "current_turn"
    app_global_get_ex
    assert // check self.current_turn exists
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/pieout/contract.py:162-169
    // self.box_player[txn_sender] = PlayerBoxVal(
    //     id=arc4.UInt8(self.total_players),
    //     turn=arc4.UInt8(self.current_turn),
    //     staked=is_true,
    //     pending=is_false,
    //     eliminated=is_false,
    //     winner=is_false,
    // )
    concat
    // smart_contracts/pieout/contract.py:158-160
    // # Assign a Player box to transaction sender
    // # Store sender address as box key and PlayerBoxVal struct as box value
    // is_true = arc4.Bool(True)  # noqa: FBT003
    pushbytes 0x80
    // smart_contracts/pieout/contract.py:162-169
    // self.box_player[txn_sender] = PlayerBoxVal(
    //     id=arc4.UInt8(self.total_players),
    //     turn=arc4.UInt8(self.current_turn),
    //     staked=is_true,
    //     pending=is_false,
    //     eliminated=is_false,
    //     winner=is_false,
    // )
    concat
    pushint 17 // 17
    intc_0 // 0
    setbit
    pushint 18 // 18
    intc_0 // 0
    setbit
    pushint 19 // 19
    intc_0 // 0
    setbit
    frame_dig 0
    swap
    box_put
    // smart_contracts/pieout/contract.py:171-172
    // # Increment total stake count by the stake pay amount
    // self.total_stake += stake_pay.amount
    intc_0 // 0
    bytec 7 // "total_stake"
    app_global_get_ex
    assert // check self.total_stake exists
    +
    bytec 7 // "total_stake"
    swap
    app_global_put
    // smart_contracts/pieout/contract.py:174-175
    // # Increment total players count by 1 for every new player
    // self.total_players += 1
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    intc_1 // 1
    +
    bytec_0 // "total_players"
    swap
    app_global_put
    // smart_contracts/pieout/contract.py:177-178
    // # When max number of players is reached, finalize staking and open gamba
    // if self.total_players == MAX_PLAYERS:
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    intc_3 // 10
    ==
    bz stake_after_if_else@12
    // smart_contracts/pieout/contract.py:179
    // self.staking_finalized = UInt64(1)
    bytec 5 // "staking_finalized"
    intc_1 // 1
    app_global_put

stake_after_if_else@12:
    // smart_contracts/pieout/contract.py:181-182
    // # Replace 32 bytes of zeroes in player addresses box with the transaction sender address
    // if self.pa_box_offset <= 288:
    intc_0 // 0
    bytec_3 // "pa_box_offset"
    app_global_get_ex
    assert // check self.pa_box_offset exists
    pushint 288 // 288
    <=
    bz stake_after_if_else@14
    // smart_contracts/pieout/contract.py:183
    // op.Box.replace(b"pa_", self.pa_box_offset, txn_sender.bytes)
    intc_0 // 0
    bytec_3 // "pa_box_offset"
    app_global_get_ex
    assert // check self.pa_box_offset exists
    bytec 9 // 0x70615f
    swap
    frame_dig 1
    box_replace
    // smart_contracts/pieout/contract.py:184
    // self.pa_box_offset += 32  # Increment offset by address length
    intc_0 // 0
    bytec_3 // "pa_box_offset"
    app_global_get_ex
    assert // check self.pa_box_offset exists
    pushint 32 // 32
    +
    bytec_3 // "pa_box_offset"
    swap
    app_global_put

stake_after_if_else@14:
    retsub

stake_bool_false@9:
    intc_0 // 0
    b stake_bool_merge@10

stake_bool_false@5:
    intc_0 // 0
    b stake_bool_merge@6


// smart_contracts.pieout.contract.Pieout.gamba() -> uint64:
gamba:
    // smart_contracts/pieout/contract.py:194-196
    // # NOTE: This method has to be called atomically in a group to prevent unfair advantages
    // @arc4.abimethod
    // def gamba(self) -> UInt64:
    proto 0 1
    // smart_contracts/pieout/contract.py:200
    // player = self.box_player[txn_sender].copy()
    bytec 10 // 0x705f
    // smart_contracts/pieout/contract.py:197-198
    // # Get and store commonly used addresses
    // txn_sender = Txn.sender
    txn Sender
    // smart_contracts/pieout/contract.py:200
    // player = self.box_player[txn_sender].copy()
    concat
    dup
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_player entry exists
    // smart_contracts/pieout/contract.py:201
    // current_player_turn = player.turn.native
    intc_1 // 1
    getbyte
    dup
    // smart_contracts/pieout/contract.py:204
    // self.staking_finalized == 1
    intc_0 // 0
    bytec 5 // "staking_finalized"
    app_global_get_ex
    assert // check self.staking_finalized exists
    intc_1 // 1
    ==
    // smart_contracts/pieout/contract.py:203-205
    // assert (
    //     self.staking_finalized == 1
    // ), "gamba(): Rejected. Gamba not available until staking is finalized."
    assert // gamba(): Rejected. Gamba not available until staking is finalized.
    // smart_contracts/pieout/contract.py:208
    // self.total_players > 1
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    intc_1 // 1
    >
    // smart_contracts/pieout/contract.py:207-209
    // assert (
    //     self.total_players > 1
    // ), "gamba(): Rejected. Total number of players must be greater than 1."
    assert // gamba(): Rejected. Total number of players must be greater than 1.
    // smart_contracts/pieout/contract.py:212
    // current_player_turn == self.current_turn
    intc_0 // 0
    bytec 4 // "current_turn"
    app_global_get_ex
    assert // check self.current_turn exists
    ==
    // smart_contracts/pieout/contract.py:211-213
    // assert (
    //     current_player_turn == self.current_turn
    // ), "gamba(): Rejected. Transaction sender turn is not aligned with current turn."
    assert // gamba(): Rejected. Transaction sender turn is not aligned with current turn.
    // smart_contracts/pieout/contract.py:216
    // temp_seed = op.sha256(op.itob(Global.round) + Txn.tx_id)
    global Round
    itob
    txn TxID
    concat
    sha256
    // smart_contracts/pieout/contract.py:217
    // roll = op.extract_uint16(temp_seed, 16)
    pushint 16 // 16
    extract_uint16
    dup
    // smart_contracts/pieout/contract.py:219
    // if roll >= 50333:
    pushint 50333 // 50333
    >=
    bz gamba_else_body@2
    // smart_contracts/pieout/contract.py:220
    // current_player_turn += 1
    frame_dig 2
    intc_1 // 1
    +
    dup
    frame_bury 2
    // smart_contracts/pieout/contract.py:221
    // player.turn = arc4.UInt8(current_player_turn)
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    frame_dig 1
    swap
    replace2 1
    dup
    frame_bury 1
    // smart_contracts/pieout/contract.py:222
    // self.box_player[txn_sender] = player.copy()
    frame_dig 0
    swap
    box_put

gamba_after_if_else@3:
    // smart_contracts/pieout/contract.py:245
    // self.players_pending += 1
    intc_0 // 0
    bytec_2 // "players_pending"
    app_global_get_ex
    assert // check self.players_pending exists
    intc_1 // 1
    +
    bytec_2 // "players_pending"
    swap
    app_global_put
    // smart_contracts/pieout/contract.py:247
    // if self.players_pending == self.total_players:
    intc_0 // 0
    bytec_2 // "players_pending"
    app_global_get_ex
    assert // check self.players_pending exists
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    ==
    bz gamba_after_if_else@11
    // smart_contracts/pieout/contract.py:248
    // if self.players_elim != self.total_players:
    intc_0 // 0
    bytec_1 // "players_elim"
    app_global_get_ex
    assert // check self.players_elim exists
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    !=
    bz gamba_after_if_else@10
    // smart_contracts/pieout/contract.py:249
    // self.total_players -= self.players_elim
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    intc_0 // 0
    bytec_1 // "players_elim"
    app_global_get_ex
    assert // check self.players_elim exists
    -
    bytec_0 // "total_players"
    swap
    app_global_put
    // smart_contracts/pieout/contract.py:250
    // if self.total_players == 1:
    intc_0 // 0
    bytec_0 // "total_players"
    app_global_get_ex
    assert // check self.total_players exists
    intc_1 // 1
    ==
    bz gamba_after_if_else@9
    // smart_contracts/pieout/contract.py:251
    // if player.turn == current_player_turn:
    frame_dig 1
    extract 1 1 // on error: Index access is out of bounds
    frame_dig 2
    itob
    b==
    bz gamba_after_if_else@9
    // smart_contracts/pieout/contract.py:252
    // player.id = arc4.UInt8(250)
    frame_dig 1
    pushbytes 0xfa
    replace2 0
    // smart_contracts/pieout/contract.py:253
    // self.box_player[txn_sender] = player.copy()
    frame_dig 0
    swap
    box_put

gamba_after_if_else@9:
    // smart_contracts/pieout/contract.py:254
    // self.current_turn += 1
    intc_0 // 0
    bytec 4 // "current_turn"
    app_global_get_ex
    assert // check self.current_turn exists
    intc_1 // 1
    +
    bytec 4 // "current_turn"
    swap
    app_global_put

gamba_after_if_else@10:
    // smart_contracts/pieout/contract.py:256-257
    // # RESET LOGIC
    // self.players_elim = UInt64(0)
    bytec_1 // "players_elim"
    intc_0 // 0
    app_global_put
    // smart_contracts/pieout/contract.py:258
    // self.players_pending = UInt64(0)
    bytec_2 // "players_pending"
    intc_0 // 0
    app_global_put

gamba_after_if_else@11:
    // smart_contracts/pieout/contract.py:271
    // return roll
    frame_dig 3
    frame_bury 0
    retsub

gamba_else_body@2:
    // smart_contracts/pieout/contract.py:224
    // self.players_elim += 1
    intc_0 // 0
    bytec_1 // "players_elim"
    app_global_get_ex
    assert // check self.players_elim exists
    intc_1 // 1
    +
    bytec_1 // "players_elim"
    swap
    app_global_put
    b gamba_after_if_else@3


// smart_contracts.pieout.contract.Pieout.terminate() -> void:
terminate:
    // smart_contracts/pieout/contract.py:278
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/pieout/contract.py:276-279
    // # Fail transaction unless the assertion/s below evaluate/s True
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/pieout/contract.py:281-283
    // assert TemplateVar[bool](
    //     "DELETABLE"
    // ), "Template variable 'DELETABLE' needs to be 'True' at deploy-time."
    intc 5 // TMPL_DELETABLE
    assert // Template variable 'DELETABLE' needs to be 'True' at deploy-time.
    retsub
