# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": []}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint8", "name": "key_size"}, {"type": "uint16", "name": "value_size"}], "name": "calc_single_box_cost", "returns": {"type": "uint64"}, "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "read_gen_unix", "returns": {"type": "uint64"}, "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "does_box_game_trophy_exist", "returns": {"type": "bool"}, "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "account", "name": "player"}], "name": "does_box_game_register_exist", "returns": {"type": "bool"}, "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "does_box_game_state_exist", "returns": {"type": "bool"}, "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "read_box_game_players", "returns": {"type": "address[]"}, "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": [], "create": ["NoOp"]}, "args": [], "name": "generate", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "name": "box_t_pay"}, {"type": "pay", "name": "mint_pay"}], "name": "mint_trophy", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "claim_trophy", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "name": "box_r_pay"}], "name": "get_box_game_register", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "del_box_game_register_for_self", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "account", "name": "player"}], "name": "del_box_game_register_for_other", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "bool", "name": "quick_play_enabled"}, {"type": "uint64", "name": "max_players"}, {"type": "pay", "name": "box_s_pay"}, {"type": "pay", "name": "box_p_pay"}, {"type": "pay", "name": "stake_pay"}], "name": "new_game", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}, {"type": "pay", "name": "stake_pay"}], "name": "join_game", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "field1"}, {"type": "bool", "name": "field2"}, {"type": "uint64", "name": "field3"}], "name": "game_live"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "set_game_commit", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "up_ref_budget_for_play_game", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "play_game", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "field1"}, {"type": "address", "name": "field2"}, {"type": "uint8", "name": "field3"}], "name": "player_score"}, {"args": [{"type": "uint64", "name": "field1"}, {"type": "uint8", "name": "field2"}, {"type": "uint8", "name": "field3"}, {"type": "uint8", "name": "field4"}, {"type": "address", "name": "field5"}, {"type": "address", "name": "field6"}, {"type": "address", "name": "field7"}], "name": "game_over"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}, {"type": "uint8", "name": "trigger_id"}], "name": "trigger_game_event", "returns": {"type": "void"}, "events": [{"args": [{"type": "uint64", "name": "field1"}, {"type": "uint8", "name": "field2"}, {"type": "uint8", "name": "field3"}, {"type": "uint8", "name": "field4"}, {"type": "address", "name": "field5"}, {"type": "address", "name": "field6"}, {"type": "address", "name": "field7"}], "name": "game_over"}, {"args": [{"type": "uint64", "name": "field1"}, {"type": "bool", "name": "field2"}, {"type": "uint64", "name": "field3"}], "name": "game_live"}], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}, {"type": "bool", "name": "change_quick_play"}, {"type": "bool", "name": "change_max_players"}, {"type": "uint64", "name": "new_max_players"}, {"type": "pay", "name": "stake_pay"}], "name": "reset_game", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "delete_game", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["DeleteApplication"], "create": []}, "args": [], "name": "terminate", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}], "name": "Pieout", "state": {"keys": {"box": {"box_game_trophy": {"key": "dF8=", "keyType": "AVMString", "valueType": "GameTrophy"}}, "global": {"game_id": {"key": "Z2FtZV9pZA==", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"box_game_state": {"keyType": "uint64", "valueType": "GameState", "prefix": "c18="}, "box_game_players": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": "cF8="}, "box_game_register": {"keyType": "address", "valueType": "GameRegister", "prefix": "cl8="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 1}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"GameRegister": [{"name": "hosting_game", "type": "bool"}, {"name": "best_score", "type": "uint8"}, {"name": "game_id", "type": "uint64"}, {"name": "commit_rand_round", "type": "uint64"}, {"name": "expiry_round", "type": "uint64"}], "GameState": [{"name": "staking_finalized", "type": "bool"}, {"name": "quick_play_enabled", "type": "bool"}, {"name": "max_players", "type": "uint8"}, {"name": "active_players", "type": "uint8"}, {"name": "first_place_score", "type": "uint8"}, {"name": "second_place_score", "type": "uint8"}, {"name": "third_place_score", "type": "uint8"}, {"name": "top_score", "type": "uint8"}, {"name": "box_p_start_pos", "type": "uint16"}, {"name": "expiry_ts", "type": "uint64"}, {"name": "prize_pool", "type": "uint64"}, {"name": "admin_address", "type": "address"}, {"name": "first_place_address", "type": "address"}, {"name": "second_place_address", "type": "address"}, {"name": "third_place_address", "type": "address"}, {"name": "topscorer_address", "type": "address"}], "GameTrophy": [{"name": "asset_id", "type": "uint64"}, {"name": "ath_score", "type": "uint8"}, {"name": "ath_address", "type": "address"}]}, "byteCode": {"approval": "CiAPAAECIMCEPcgB8JMJhOgBrf7V5NSF/ahYz4Keu+/v3oIU/////w/09AT//wMAACYNAnJfAQACdF8CcF8Cc18EFR98dQgAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdnYW1lX2lkBNvfT3cEGnie0AIAIAMGgQExG0EAloIPBGMzzZ0Etm0vVgQdI2o3BAS3FuEEu/qOAQSxaqlxBFviGfAEskYO9gQ65090BB+gZekE9skSUQTB2hu2BBKXhBcEca+WbgTcNJcHJwknCoIEBJ7unBgEcQ67jwQYmKAuBF/xbaQ2GgCOFQG4AacBkQF1AVsBRgE5ARkBDQD3AOsA2QClAIsAewBrAFsASAAgABAAAiJDMRmBBRJEMRhEiBKmI0MxGRREMRhENhoBF4gRUyNDMRkURDEYRDYaARc2GgIiUzYaAyJTNhoEFzEWIwlJOBAjEkSIEFEjQzEZFEQxGEQ2GgEXNhoCiA+NI0MxGRREMRhENhoBF4gLrSNDMRkURDEYRDYaAReIC0cjQzEZFEQxGEQ2GgEXiAraI0MxGRREMRhENhoBFzEWIwlJOBAjEkSICf4jQzEZFEQxGEQ2GgEiUzYaAhcxFoEDCUk4ECMSRDEWJAlJOBAjEkQxFiMJSTgQIxJEiAisI0MxGRREMRhENhoBF8AciAgAI0MxGRREMRhEiAdhI0MxGRREMRhEMRYjCUk4ECMSRIgG+iNDMRkURDEYRIgGYSNDMRkURDEYRDEWJAlJOBAjEkQxFiMJSTgQIxJEiAVgI0MxGRREMRgURIgFSCNDMRkURDEYRDYaAReIBNYnBUxQsCNDMRkURDEYRDYaAReIBLMpIk8CVCcFTFCwI0MxGRREMRhENhoBF8AciASMKSJPAlQnBUxQsCNDMRkURDEYRIgEcSkiTwJUJwVMULAjQzEZFEQxGEQhDRYnBUxQsCNDMRkURDEYRDYaATYaAogEMRYnBUxQsCNDigMAsYv/sgWL/rIIi/2yByOyECKyAbOJigMBi/0yAxNBAAyL/XMARQFBAAOL/YmL/jIDE0EADIv+cwBFAUEAA4v+iYv/MgMTQQAMi/9zAEUBQQADi/+JMQAyAxNBAAwxAHMARQFBAAMxAIkyComKBQEigACL/iULIkmLBIsCDIsDjAFBACmL+xaL/UxQSYwAvkSLBCVYi/wSQQAYI4wDi/9BAAeLAIsEJwe7iwOMAYsBjACJiwQlCIwEQv+9igECi/8jUykiTwJUIlNBABiL/1cZIDEAEkEADYv/JFUjDUEABCOL/4kiQv/5igIBIov/VwkIMgcWpIv/TEAAIov/VwIBi/9XAQGoi/+MAUAAEIv/iP+pRwKM/4wAjAFBADqLAUmM/yIjVIz/MgchBQgWi/9MXAmM/4v+Fov/IlMpIk8CVIv/VwkITgJQTFCABJNhfSRMULCL/4wAiYoEASJHCYAARwWL/VcJCDIHFqSL/SRVSSMSQQKsi/1XGSCL/EyL/yMiiP7oQQKaI4wKixBAAA6LEUEACYv9jAKLCkECPIv8FkmMCYv/TFBJjAG9TIwPRCKMDIsMiw8MQQAxiwGLDCW6SYwDJwcTQQAZi/6LA1BJvkQnBlwCJwZcCjIGIQYIFlwSv4sMJQiMDEL/x4v9I1UlC6+LAUm8SEy/i/0pXAJJjP1XAwGL/VcEAYv9VwUBi/1XOSBJTgSMBov9V1kgSU4FjAeL/Vd5IElOBowIiwlPA1BPAlBMUExQTFBMUIAEX6W900xQsIv9gRFbSYwLIQQSQQGLIowNIowOi/1XGSAyCYsGSwJPAoj9rYwAMgmLB0sCTwKI/aCMBDIJiwhOAoj9lYwFiwtBAGmLAIsLgGBwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O2ZpcnN0X3ByaXplX3NoYXJlIn2I/Q2LDUEAaosEiw2AYXBpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJpc19nYW1lX292ZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7c2Vjb25kX3ByaXplX3NoYXJlIn2I/J6LDkEAaYsFiw6AYHBpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJpc19nYW1lX292ZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7dGhpcmRfcHJpemVfc2hhcmUifYj8MIv9JwZcEUmM/YwCiwKMAImLC4GAiXoSQQAXiwtJgTwLgWQKTEsBCYwNIowOjAtC/lqLC0mBMguBZApLAYEeC4FkCkmMDU8CSwIJTAmMDowLQv44IowKQv1jigIBi/4Xi/8XCIGQAwuBxBMIiSq+RQGJigEBKIv/UL5FAYmKAQGL/xYnBExQvkUBiYoBASJJi/8WJwRLAVC9RQFEK0xQvkxJTwJEgAIAAEwVIosFiwQMQQA0iwKLBSVYSYwBJwcTiwOMAEEAFIsDVwIAiwFQSRUlChZXBgJMUIwAiwCMA4sFJQiMBUL/xIsDjACJMQAyCRJEJwgjZ4mKAgAyBIEDEkQqvUUBFESL/jgIgfSZAQ9Ei/44ADIJEkSL/jgHMgoSRIv/OAgyDw9Ei/84ADIJEkSL/zgHMgoSRLEyCkcDgFJwaWVvdXQ6ansibWV0aG9kIjoibWludF90cm9waHkiLCJjb25jZXJuIjoiaXR4bi5hc3NldF9jb25maWc7Y3JlYXRlX3Ryb3BoeV9hc3NldCJ9sgWyLLIrsiqyKSKyJCKyI4ANUGllb3V0X1Ryb3BoebImgARUUkZZsiUjsiKBA7IQIrIBs7Q8KoEpuUgWMgNMKVBMUCpMv4kyBCMSRDEAKr5ESVcJIE8CEkQxAEwiW0xLAXAARQFEsTEAgFdwaWVvdXQ6ansibWV0aG9kIjoiY2xhaW1fdHJvcGh5IiwiY29uY2VybiI6Iml0eG4uYXNzZXRfdHJhbnNmZXI7dHJhbnNmZXJfdHJvcGh5X2Fzc2V0In2yBSOyErIUshGBBLIQIrIBs4mKAQAyBCQSRCgxAFC9RQEURCq9RQFEi/84CCEHEkSL/zgAMQASRIv/OAcyChJEMgYhBggWgBIAAAAAAAAAAAAAAAAAAAAAAABMUCgxAFBMv4kyBCMSRCgxAFC9RQFEKDEAUL5EIlMpIk8CVCJTFEQoMQBQvkSBClsURCgxAFC8SDEAIQeAWnBpZW91dDpqeyJtZXRob2QiOiJkZWxfYm94X2dhbWVfcmVnaXN0ZXJfZm9yX3NlbGYiLCJjb25jZXJuIjoidHhuLmFwcF9jO21icl9ib3hfcl9yZWZ1bmQifYj46ImKAQAyBCMSRCiL/1BJvUUBREm+REkiUykiTwJUIlMUREmBClsURIESWzIGDES8SIv/MQAyCYj4xyEHgFpwaWVvdXQ6ansibWV0aG9kIjoiZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9vdGhlciIsImNvbmNlcm4iOiJpdHhuLnBheTttYnJfYm94X2NfcmVmdW5kIn2I+E6JigUAMgSBBBJEKr1FAUQoMQBQvUUBRCgxAFC+RCJTKSJPAlQiUxREi/yBAw9BAOuL/IEQDkEA4yNEi/84CEkhBBJEi/04CCELEkSL/jgIJYv8C0kWSZOBEA5EVwYCgAEKTIj8Ek8CEkSL/zgAMQASRIv9OAAxABJEi/44ADEAEkSL/zgHMgoSRIv9OAcyChJEi/44BzIKEkQpIov7VIv8FkmTgQgORFcHATIHIQUIFk8EFjEAMgNHA08IIlMpI08CVE8IUIABAVApUClQKVApUCcLUE8HUE8GUE8FUE8EUE8DUE8CUExQIicIZURJFicESwFQTwO/KDEAUEm+RCIjVL9PAq8rTwJQSbxISU8CvyIxALsjCCcITGeJIkL/GooCADIEJBJEi/4WJwRLAVBJvUUBREm+RCq9RQFEKDEAUL1FAUSL/zgISSEEEkSL/zgAMQASRIv/OAcyChJEMQBLAiRVi/5PAitLAyKI904UREsCIlMpIk8CVCJTFERLAlcJCDIHFqdESwJXAgFLA1cBAaZESwKBB1lLAyNVJQtLAQ1EK08GUDEATE4CuyMIFkmTgQgORFcHAU8CTFwCSYEHWSUIFkmTgRAORFcGAlwHSYERW08CCBZcEYv+TIj3Wb+JigEAMgQjEkSL/xYnBEsBUEm9RQFEKDEAUL1FAUS+REkiUykiTwJUIlNEMQBMI1WL/08CK08DIoj2oSMSRCgxAFC+RElXCggnBqhEMgaBBAgWXApMXAIoMQBQTL+JigEAIzgQgQYSRDIEJBJEMRYURIv/FicESwFQvUUBRCM4GDIIEkQjOAAxABJEIyLCGicKEkQjScIaSU8CEkQoMQBQvkQkWxYSRCgxAFC+RCRbi/8SRImKAQAiRwqAAEcGgZqZATIMDUEAGLGBBrIQgQWyGScMsh4nDLIfIrIBs0L/3iI4EIEGEkQyBCQSRDEWIxJEi/8WSYwBJwRMUEmMAEm9RQFEKDEAUL1FAUQqvUUBRCI4GDIIEkQiOAAxABJEIknCGicJEkQiI8IaSTYaARJEKDEAUL5EJFsWEkQxAEsBvkQjVYv/TwIrTwMjiPWOIxJEvkxJTgKMBEQoMQBQvkyMAkRJIlMpIk8CVCJTRFcJCDIHFqdEKDEAUL5EJFuL/xJEMgYoMQBQvkSBClsPRDEAjAcxAElXEAgVgQgSRIEQWyIhCB1FASEJHkUBHkUBIQgdRQEhCR5FAYACAP+MCYGAgPz///////8BIx5FASEKGiEMGIwQIowNjA+LDYH/AQxBAFyLD0khCB1FASEJHk4CSEmBEpFLARuBG5EhChpMgTuRSpFMHCMeRQGBHxpPAkyQIQoaGUmMDIsQD0EAHIsMIQwYIwgWVwYCiwlMUIwJiw0jCIwNjA9C/6CMD0L/pCKMDosJFYwRJIwNiw2LEQxBACwkixFJTgIPJEsCTwJNiwlMTwJSiw1ZgfBVDkAAD4sOIwiMDosNJAiMDUL/zIsOSRZJk4EIDkRXBwFJjAqLAYsHUExQgATeIkTWTFCwiwRJgQZVTwIMTEmMBowFQQAPiwSLClwGiwdcmUmMBowFiwWMBIsCSSNViw4MTIwDQQAIiwKLClwBjAOLA4wCiwRXOSAyAxJAAAuLBIEDVYsODEEBN4sESVcEAVwFSVdZIFx5SVcDAVwESVc5IFxZiwpcA4sHXDmMBIsEVwMBSYwIKr5EVwgBpUEAySq+RIsIXAgqSwG/VwkgMgMTQQCrKr5ESVcJIEwiW3AATIwLQQCZiwsjEkEAkiq+REkiW0xXCSAyCrGAcHBpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJjbGF3YmFja19pdHhuIiwiY29uY2VybiI6Iml0eG4uYXNzZXRfdHJhbnNmZXI7Y2xhd2JhY2tfdHJvcGh5X2Fzc2V0In2yBSOyErIUshOyEYEEshAisgGzKr5EMQBcCSpMv4sESSRVIwkWSZOBCA5EVwcBXAKLAicGXAInBlwKMgYhBggWXBIoMQBQTL+L/0woK4jzo4sATL+JiwRXWSAyAxJAAAuLBIEEVYsODEEAH4sESVcEAVwFSVdZIFx5iwpcBIsHXFmMBosGjARC/riLBFd5IDIDEkAAC4sEgQVViw4MQf/jiwSLClwFiwdceYwGQv/UigIAIjIEIxJEi/4WJwRMUEcCvUUBRL5Ei/8XSUAAaosCSSJTKSJPAlQiUxREJFUjEkEAH4sCVxkgi/5MKyMiiPIWQQAOi/6LAigriPL2iwFMv4mLAklXCQgyBxakTIwAQAAQiwKI8j9JTgKMAkyMAEEAEosAjAIjRIv+iwKI8lSLAUy/iSJC/++LAyQSRIsCSSJTKSJPAlQiU0RJVwkIMgcWpESL/kwoK4jymIsBTL+JigUAMgQkEkSL+xYnBEsBUElOAkm9RQFEi/84ADEAEkSL/zgHMgoSRIv/OAghBA9EvkRJVxkgMQASREmBEVsUREkkVRREK08CUCIxALsiSVSAAQFcAilcAylcBClcBScLXAcyByEFCBZcCUmBEVshBAgWXBEyA1w5MgNcWTIDXHlJi/xBABmLAUkjUykiTwJUIlMUKSJPAlQiUyNMVIwCiwJJjAGMAov9QQAli/6BAw9BACOL/oEQDkEAGyNEi/4WSZOBCA5EVwcBiwFMXAGMAosAiwK/iSJC/+KKAQCAADIEIxJEi/8WSScETFBHAr1FAUS+TElPAkRXGSBJMQASQAAIMQAyCRJBAQ8jRIsDJFVJjAAjEkEA84v/iwQrIyKI8IVEMQCLA4ERW4BMcGllb3V0Omp7Im1ldGhvZCI6ImRlbGV0ZV9nYW1lIiwiY29uY2VybiI6Iml0eG4ucGF5O3ByaXplX3Bvb2xfYWRtaW5fc3Rha2UifYjvvosCvEgriwFQvEgoiwRQSb5EIklUv4sDI1UlCxZJk4EQDkRXBgKAAQpMiPO7MQAhC08CCIBXcGllb3V0Omp7Im1ldGhvZCI6ImRlbGV0ZV9nYW1lIiwiY29uY2VybiI6Iml0eG4ucGF5O2JveF9zX21icl9yZWZ1bmQrYm94X3BfbWJyX3JlZnVuZCJ9iO8viYsAFESLA4ERWxREQv9iIkL+7ooAAIAAIQ5EMQAyCRJEKr1FAUEAezIKKr5EIltwAEyMAEEAaYsAIxJBAGIqvkQiW7GATnBpZW91dDpqeyJtZXRob2QiOiJ0ZXJtaW5hdGUiLCJjb25jZXJuIjoiaXR4bi5hc3NldF9jb25maWc7YnVybl90cm9waHlfYXNzZXQifbIFsiGBA7IQIrIBsyq8SLExAEmARnBpZW91dDpqeyJtZXRob2QiOiJ0ZXJtaW5hdGUiLCJjb25jZXJuIjoiaXR4bi5wYXk7Y2xvc2VfcmVtYWluZGVyX3RvIn2yBbIJIrIIsgcjshAisgGziQ==", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 9, "patch": 0}}, "events": [{"args": [{"type": "uint64", "name": "field1"}, {"type": "bool", "name": "field2"}, {"type": "uint64", "name": "field3"}], "name": "game_live"}, {"args": [{"type": "uint64", "name": "field1"}, {"type": "address", "name": "field2"}, {"type": "uint8", "name": "field3"}], "name": "player_score"}, {"args": [{"type": "uint64", "name": "field1"}, {"type": "uint8", "name": "field2"}, {"type": "uint8", "name": "field3"}, {"type": "uint8", "name": "field4"}, {"type": "address", "name": "field5"}, {"type": "address", "name": "field6"}, {"type": "address", "name": "field7"}], "name": "game_over"}], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC5fX2FsZ29weV9lbnRyeXBvaW50X3dpdGhfaW5pdCgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMiAzMiAxMDAwMDAwIDIwMCAxNTAwMDAgMjk3MDAgNjM2NDEzNjIyMzg0Njc5MzAwNSAxNDQyNjk1MDQwODg4OTYzNDA3IDQyOTQ5NjcyOTUgODA1MDAgNjU1MzUgVE1QTF9HRU5fVU5JWCBUTVBMX0RFTEVUQUJMRQogICAgYnl0ZWNibG9jayAicl8iIDB4MDAgInRfIiAicF8iICJzXyIgMHgxNTFmN2M3NSAweDAwMDAwMDAwMDAwMDAwMDAgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwICJnYW1lX2lkIiAweGRiZGY0Zjc3IDB4MWE3ODllZDAgMHgwMDIwIDB4MDY4MTAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxLTMyCiAgICAvLyAjIFNtYXJ0IGNvbnRyYWN0IGNsYXNzCiAgICAvLyBjbGFzcyBQaWVvdXQoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2FmdGVyX2lmX2Vsc2VAMjYKICAgIHB1c2hieXRlc3MgMHg2MzMzY2Q5ZCAweGI2NmQyZjU2IDB4MWQyMzZhMzcgMHgwNGI3MTZlMSAweGJiZmE4ZTAxIDB4YjE2YWE5NzEgMHg1YmUyMTlmMCAweGIyNDYwZWY2IDB4M2FlNzRmNzQgMHgxZmEwNjVlOSAweGY2YzkxMjUxIDB4YzFkYTFiYjYgMHgxMjk3ODQxNyAweDcxYWY5NjZlIDB4ZGMzNDk3MDcgLy8gbWV0aG9kICJjYWxjX3NpbmdsZV9ib3hfY29zdCh1aW50OCx1aW50MTYpdWludDY0IiwgbWV0aG9kICJyZWFkX2dlbl91bml4KCl1aW50NjQiLCBtZXRob2QgImRvZXNfYm94X2dhbWVfdHJvcGh5X2V4aXN0KClib29sIiwgbWV0aG9kICJkb2VzX2JveF9nYW1lX3JlZ2lzdGVyX2V4aXN0KGFjY291bnQpYm9vbCIsIG1ldGhvZCAiZG9lc19ib3hfZ2FtZV9zdGF0ZV9leGlzdCh1aW50NjQpYm9vbCIsIG1ldGhvZCAicmVhZF9ib3hfZ2FtZV9wbGF5ZXJzKHVpbnQ2NClhZGRyZXNzW10iLCBtZXRob2QgImdlbmVyYXRlKCl2b2lkIiwgbWV0aG9kICJtaW50X3Ryb3BoeShwYXkscGF5KXZvaWQiLCBtZXRob2QgImNsYWltX3Ryb3BoeSgpdm9pZCIsIG1ldGhvZCAiZ2V0X2JveF9nYW1lX3JlZ2lzdGVyKHBheSl2b2lkIiwgbWV0aG9kICJkZWxfYm94X2dhbWVfcmVnaXN0ZXJfZm9yX3NlbGYoKXZvaWQiLCBtZXRob2QgImRlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfb3RoZXIoYWNjb3VudCl2b2lkIiwgbWV0aG9kICJuZXdfZ2FtZShib29sLHVpbnQ2NCxwYXkscGF5LHBheSl2b2lkIiwgbWV0aG9kICJqb2luX2dhbWUodWludDY0LHBheSl2b2lkIiwgbWV0aG9kICJzZXRfZ2FtZV9jb21taXQodWludDY0KXZvaWQiCiAgICBieXRlYyA5IC8vIG1ldGhvZCAidXBfcmVmX2J1ZGdldF9mb3JfcGxheV9nYW1lKHVpbnQ2NCl2b2lkIgogICAgYnl0ZWMgMTAgLy8gbWV0aG9kICJwbGF5X2dhbWUodWludDY0KXZvaWQiCiAgICBwdXNoYnl0ZXNzIDB4OWVlZTljMTggMHg3MTBlYmI4ZiAweDE4OThhMDJlIDB4NWZmMTZkYTQgLy8gbWV0aG9kICJ0cmlnZ2VyX2dhbWVfZXZlbnQodWludDY0LHVpbnQ4KXZvaWQiLCBtZXRob2QgInJlc2V0X2dhbWUodWludDY0LGJvb2wsYm9vbCx1aW50NjQscGF5KXZvaWQiLCBtZXRob2QgImRlbGV0ZV9nYW1lKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ0ZXJtaW5hdGUoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NhbGNfc2luZ2xlX2JveF9jb3N0X3JvdXRlQDUgbWFpbl9yZWFkX2dlbl91bml4X3JvdXRlQDYgbWFpbl9kb2VzX2JveF9nYW1lX3Ryb3BoeV9leGlzdF9yb3V0ZUA3IG1haW5fZG9lc19ib3hfZ2FtZV9yZWdpc3Rlcl9leGlzdF9yb3V0ZUA4IG1haW5fZG9lc19ib3hfZ2FtZV9zdGF0ZV9leGlzdF9yb3V0ZUA5IG1haW5fcmVhZF9ib3hfZ2FtZV9wbGF5ZXJzX3JvdXRlQDEwIG1haW5fZ2VuZXJhdGVfcm91dGVAMTEgbWFpbl9taW50X3Ryb3BoeV9yb3V0ZUAxMiBtYWluX2NsYWltX3Ryb3BoeV9yb3V0ZUAxMyBtYWluX2dldF9ib3hfZ2FtZV9yZWdpc3Rlcl9yb3V0ZUAxNCBtYWluX2RlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfc2VsZl9yb3V0ZUAxNSBtYWluX2RlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfb3RoZXJfcm91dGVAMTYgbWFpbl9uZXdfZ2FtZV9yb3V0ZUAxNyBtYWluX2pvaW5fZ2FtZV9yb3V0ZUAxOCBtYWluX3NldF9nYW1lX2NvbW1pdF9yb3V0ZUAxOSBtYWluX3VwX3JlZl9idWRnZXRfZm9yX3BsYXlfZ2FtZV9yb3V0ZUAyMCBtYWluX3BsYXlfZ2FtZV9yb3V0ZUAyMSBtYWluX3RyaWdnZXJfZ2FtZV9ldmVudF9yb3V0ZUAyMiBtYWluX3Jlc2V0X2dhbWVfcm91dGVAMjMgbWFpbl9kZWxldGVfZ2FtZV9yb3V0ZUAyNCBtYWluX3Rlcm1pbmF0ZV9yb3V0ZUAyNQoKbWFpbl9hZnRlcl9pZl9lbHNlQDI2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX3Rlcm1pbmF0ZV9yb3V0ZUAyNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODM2LTgzNwogICAgLy8gIyBBbGxvdyBhcHBsaWNhdGlvbiBjcmVhdG9yIHRvIGRlbGV0ZSB0aGUgc21hcnQgY29udHJhY3QgYXBwbGljYXRpb24KICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNSAvLyBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IERlbGV0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgdGVybWluYXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9nYW1lX3JvdXRlQDI0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NjItNzYzCiAgICAvLyAjIEFsbG93IGFwcGxpY2F0aW9uIGNyZWF0b3Igb3IgYWRtaW4gdG8gZGVsZXRlIGFuIGV4aXN0aW5nIGdhbWUgaW5zdGFuY2UKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxLTMyCiAgICAvLyAjIFNtYXJ0IGNvbnRyYWN0IGNsYXNzCiAgICAvLyBjbGFzcyBQaWVvdXQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzYyLTc2MwogICAgLy8gIyBBbGxvdyBhcHBsaWNhdGlvbiBjcmVhdG9yIG9yIGFkbWluIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBnYW1lIGluc3RhbmNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgZGVsZXRlX2dhbWUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVzZXRfZ2FtZV9yb3V0ZUAyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Njg4LTY4OQogICAgLy8gIyBBbGxvdyBhZG1pbiB0byByZXNldCBhbiBleGlzdGluZyBnYW1lIGluc3RhbmNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBidG9pCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Njg4LTY4OQogICAgLy8gIyBBbGxvdyBhZG1pbiB0byByZXNldCBhbiBleGlzdGluZyBnYW1lIGluc3RhbmNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgcmVzZXRfZ2FtZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl90cmlnZ2VyX2dhbWVfZXZlbnRfcm91dGVAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYwOS02MTAKICAgIC8vICMgQWxsb3cgYW55IHZhbGlkIGFjY291bnQgdG8gY2hlY2sgYW5kIHRyaWdnZXIgZ2FtZSBldmVudCBwcm9ncmVzc2lvbgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEtMzIKICAgIC8vICMgU21hcnQgY29udHJhY3QgY2xhc3MKICAgIC8vIGNsYXNzIFBpZW91dChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MDktNjEwCiAgICAvLyAjIEFsbG93IGFueSB2YWxpZCBhY2NvdW50IHRvIGNoZWNrIGFuZCB0cmlnZ2VyIGdhbWUgZXZlbnQgcHJvZ3Jlc3Npb24KICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiB0cmlnZ2VyX2dhbWVfZXZlbnQKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcGxheV9nYW1lX3JvdXRlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0ODAtNDgxCiAgICAvLyAjIFBsYXkgdGhlIGdhbWUsIHJlc29sdmUgdGhlIHBsYXllcidzIHNjb3JlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2FtZSBpbnN0YW5jZSwgdXBkYXRlIGdhbWUgc3RhdGUgYWNjb3JkaW5nbHkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxLTMyCiAgICAvLyAjIFNtYXJ0IGNvbnRyYWN0IGNsYXNzCiAgICAvLyBjbGFzcyBQaWVvdXQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDgwLTQ4MQogICAgLy8gIyBQbGF5IHRoZSBnYW1lLCByZXNvbHZlIHRoZSBwbGF5ZXIncyBzY29yZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdhbWUgaW5zdGFuY2UsIHVwZGF0ZSBnYW1lIHN0YXRlIGFjY29yZGluZ2x5CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgcGxheV9nYW1lCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3VwX3JlZl9idWRnZXRfZm9yX3BsYXlfZ2FtZV9yb3V0ZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDU3LTQ1OAogICAgLy8gIyBNYWtlIGFwcCBjYWxsIHRvIGFkZCBleHRyYSByZXNvdXJjZSByZWZlcmVuY2UgYnVkZ2V0LCBtdXN0IGJlIGdyb3VwZWQgdy8gcGxheSBnYW1lIGFiaW1ldGhvZAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEtMzIKICAgIC8vICMgU21hcnQgY29udHJhY3QgY2xhc3MKICAgIC8vIGNsYXNzIFBpZW91dChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NTctNDU4CiAgICAvLyAjIE1ha2UgYXBwIGNhbGwgdG8gYWRkIGV4dHJhIHJlc291cmNlIHJlZmVyZW5jZSBidWRnZXQsIG11c3QgYmUgZ3JvdXBlZCB3LyBwbGF5IGdhbWUgYWJpbWV0aG9kCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgdXBfcmVmX2J1ZGdldF9mb3JfcGxheV9nYW1lCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3NldF9nYW1lX2NvbW1pdF9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDE4LTQxOQogICAgLy8gIyBTZXQgYSBjb21taXRtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdldCBvbi1jaGFpbiByYW5kb21uZXNzIGFuZCBwbGF5IHRoZSBnYW1lCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQxOC00MTkKICAgIC8vICMgU2V0IGEgY29tbWl0bWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBnZXQgb24tY2hhaW4gcmFuZG9tbmVzcyBhbmQgcGxheSB0aGUgZ2FtZQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIHNldF9nYW1lX2NvbW1pdAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9qb2luX2dhbWVfcm91dGVAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM1MC0zNTEKICAgIC8vICMgSm9pbiBleGlzdGluZyBnYW1lIGluc3RhbmNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzUwLTM1MQogICAgLy8gIyBKb2luIGV4aXN0aW5nIGdhbWUgaW5zdGFuY2UKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBqb2luX2dhbWUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fbmV3X2dhbWVfcm91dGVAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI2Ny0yNjgKICAgIC8vICMgQ3JlYXRlIG5ldyBnYW1lIGluc3RhbmNlIHdpdGggdW5pcXVlIElECiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG4gR3JvdXBJbmRleAogICAgcHVzaGludCAzIC8vIDMKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzIgLy8gMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI2Ny0yNjgKICAgIC8vICMgQ3JlYXRlIG5ldyBnYW1lIGluc3RhbmNlIHdpdGggdW5pcXVlIElECiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgbmV3X2dhbWUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9vdGhlcl9yb3V0ZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjI5LTIzMAogICAgLy8gIyBEZWxldGUgdGhlIGdhbWUgcmVnaXN0ZXIgYm94IGRhdGEgZm9yIGFub3RoZXIgYWNjb3VudAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEtMzIKICAgIC8vICMgU21hcnQgY29udHJhY3QgY2xhc3MKICAgIC8vIGNsYXNzIFBpZW91dChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjI5LTIzMAogICAgLy8gIyBEZWxldGUgdGhlIGdhbWUgcmVnaXN0ZXIgYm94IGRhdGEgZm9yIGFub3RoZXIgYWNjb3VudAogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGRlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfb3RoZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9zZWxmX3JvdXRlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyMDQtMjA1CiAgICAvLyAjIERlbGV0ZSB0aGUgZ2FtZSByZWdpc3RlciBib3ggZGF0YSBmb3IgdGhlaXIgb3duIGFjY291bnQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGRlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfc2VsZgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfYm94X2dhbWVfcmVnaXN0ZXJfcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE4MC0xODEKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSByZWdpc3RlciBib3ggdGhhdCBpcyBhIHByZXJlcXVpc3RlIHRvIGludGVyYWN0IHdpdGggZ2FtZS1yZWxhdGVkIGZlYXR1cmVzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTgwLTE4MQogICAgLy8gIyBDcmVhdGUgYSBnYW1lIHJlZ2lzdGVyIGJveCB0aGF0IGlzIGEgcHJlcmVxdWlzdGUgdG8gaW50ZXJhY3Qgd2l0aCBnYW1lLXJlbGF0ZWQgZmVhdHVyZXMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBnZXRfYm94X2dhbWVfcmVnaXN0ZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY2xhaW1fdHJvcGh5X3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNjAtMTYxCiAgICAvLyAjIEFsbG93IGF0aCBhZGRyZXNzIHRvIGNsYWltIHRoZSB0cm9waHkgYW5kIGFkZCBpdCB0byB0aGVpciBhc3NldCBiYWxhbmNlIHZpYSBhbiBhc3NldCB0cmFuc2ZlciBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgY2xhaW1fdHJvcGh5CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX21pbnRfdHJvcGh5X3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxMTMtMTE0CiAgICAvLyAjIEFsbG93IGFwcCBjcmVhdG9yIHRvIG1pbnQgYSBvbmUtdGltZSBORlQgYXNzZXQgdXNlZCBhcyBhIHRyb3BoeSB0b2tlbiB0byBob25vciB0aGUgYXRoIGFkZHJlc3MKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxLTMyCiAgICAvLyAjIFNtYXJ0IGNvbnRyYWN0IGNsYXNzCiAgICAvLyBjbGFzcyBQaWVvdXQoQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzIgLy8gMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjExMy0xMTQKICAgIC8vICMgQWxsb3cgYXBwIGNyZWF0b3IgdG8gbWludCBhIG9uZS10aW1lIE5GVCBhc3NldCB1c2VkIGFzIGEgdHJvcGh5IHRva2VuIHRvIGhvbm9yIHRoZSBhdGggYWRkcmVzcwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIG1pbnRfdHJvcGh5CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dlbmVyYXRlX3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxMDItMTAzCiAgICAvLyAjIEdlbmVyYXRlIHRoZSBzbWFydCBjb250cmFjdCBhcHBsaWNhdGlvbiBjbGllbnQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2VuZXJhdGUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVhZF9ib3hfZ2FtZV9wbGF5ZXJzX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3OC03OQogICAgLy8gIyBSRUFELU9OTFk6IFJldHVybiBhbiBhcnJheSBvZiBhbGwgYWN0aXZlIHBsYXllcnMgYXQgdGltZSBvZiBjYWxsCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc4LTc5CiAgICAvLyAjIFJFQUQtT05MWTogUmV0dXJuIGFuIGFycmF5IG9mIGFsbCBhY3RpdmUgcGxheWVycyBhdCB0aW1lIG9mIGNhbGwKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiByZWFkX2JveF9nYW1lX3BsYXllcnMKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZG9lc19ib3hfZ2FtZV9zdGF0ZV9leGlzdF9yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3My03NAogICAgLy8gIyBSRUFELU9OTFk6IFJldHVybiBUcnVlIGlmIGdhbWUgc3RhdGUgYm94IGRhdGEgZXhpc3RzLCBlbHNlIEZhbHNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMS0zMgogICAgLy8gIyBTbWFydCBjb250cmFjdCBjbGFzcwogICAgLy8gY2xhc3MgUGllb3V0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjczLTc0CiAgICAvLyAjIFJFQUQtT05MWTogUmV0dXJuIFRydWUgaWYgZ2FtZSBzdGF0ZSBib3ggZGF0YSBleGlzdHMsIGVsc2UgRmFsc2UKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBkb2VzX2JveF9nYW1lX3N0YXRlX2V4aXN0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgYnl0ZWMgNSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9kb2VzX2JveF9nYW1lX3JlZ2lzdGVyX2V4aXN0X3JvdXRlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjY4LTY5CiAgICAvLyAjIFJFQUQtT05MWTogUmV0dXJuIFRydWUgaWYgZ2FtZSByZWdpc3RlciBib3ggZGF0YSBleGlzdHMsIGVsc2UgRmFsc2UKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxLTMyCiAgICAvLyAjIFNtYXJ0IGNvbnRyYWN0IGNsYXNzCiAgICAvLyBjbGFzcyBQaWVvdXQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjY4LTY5CiAgICAvLyAjIFJFQUQtT05MWTogUmV0dXJuIFRydWUgaWYgZ2FtZSByZWdpc3RlciBib3ggZGF0YSBleGlzdHMsIGVsc2UgRmFsc2UKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBkb2VzX2JveF9nYW1lX3JlZ2lzdGVyX2V4aXN0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgYnl0ZWMgNSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9kb2VzX2JveF9nYW1lX3Ryb3BoeV9leGlzdF9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2My02NAogICAgLy8gIyBSRUFELU9OTFk6IFJldHVybiBUcnVlIGlmIGdhbWUgdHJvcGh5IGJveCBkYXRhIGV4aXN0cywgZWxzZSBGYWxzZQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZG9lc19ib3hfZ2FtZV90cm9waHlfZXhpc3QKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3JlYWRfZ2VuX3VuaXhfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTgtNTkKICAgIC8vICMgUkVBRC1PTkxZOiBSZXR1cm4gdGhlIGFwcCBnZW5lc2lzIHRpbWVzdGFtcCBpbiBVbml4IGZvcm1hdAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjEKICAgIC8vIHJldHVybiBUZW1wbGF0ZVZhcltVSW50NjRdKCJHRU5fVU5JWCIpCiAgICBpbnRjIDEzIC8vIFRNUExfR0VOX1VOSVgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTgtNTkKICAgIC8vICMgUkVBRC1PTkxZOiBSZXR1cm4gdGhlIGFwcCBnZW5lc2lzIHRpbWVzdGFtcCBpbiBVbml4IGZvcm1hdAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBpdG9iCiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NhbGNfc2luZ2xlX2JveF9jb3N0X3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ0LTQ1CiAgICAvLyAjIFJFQUQtT05MWTogQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJhbGFuY2UgcmVxdWlyZW1lbnQgKE1CUikgY29zdCBmb3Igc3RvcmluZyBhIHNpbmdsZSBib3ggdW5pdAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEtMzIKICAgIC8vICMgU21hcnQgY29udHJhY3QgY2xhc3MKICAgIC8vIGNsYXNzIFBpZW91dChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NC00NQogICAgLy8gIyBSRUFELU9OTFk6IENhbGN1bGF0ZSB0aGUgbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IChNQlIpIGNvc3QgZm9yIHN0b3JpbmcgYSBzaW5nbGUgYm94IHVuaXQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBjYWxjX3NpbmdsZV9ib3hfY29zdAogICAgaXRvYgogICAgYnl0ZWMgNSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuc3Vicm91dGluZXMucGF5b3V0X2l0eG4ocmVjZWl2ZXI6IGJ5dGVzLCBhbW91bnQ6IHVpbnQ2NCwgbm90ZTogYnl0ZXMpIC0+IHZvaWQ6CnBheW91dF9pdHhuOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo1Mi01NAogICAgLy8gIyBEZWZpbmUgYSBwYXlvdXQgcGF5bWVudCBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBwYXlvdXRfaXR4bihyZWNlaXZlcjogQWNjb3VudCwgYW1vdW50OiBVSW50NjQsIG5vdGU6IFN0cmluZykgLT4gTm9uZToKICAgIHByb3RvIDMgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo1NS01OQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgbm90ZT1ub3RlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIE5vdGUKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo1NQogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjU1LTU5CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9cmVjZWl2ZXIsCiAgICAvLyAgICAgYW1vdW50PWFtb3VudCwKICAgIC8vICAgICBub3RlPW5vdGUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5zdWJyb3V0aW5lcy5yZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8oYWNjMTogYnl0ZXMsIGFjYzI6IGJ5dGVzLCBhY2MzOiBieXRlcykgLT4gYnl0ZXM6CnJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6NjItNjgKICAgIC8vICMgUmVzb2x2ZSByZWNpZXZlciBhY2NvdW50IGFkZHJlc3MgYnkgcHJpb3JpdHkKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcmVzb2x2ZV9yZWNlaXZlcl9ieV9wcmlvKAogICAgLy8gICAgIGFjYzE6IEFjY291bnQsCiAgICAvLyAgICAgYWNjMjogQWNjb3VudCwKICAgIC8vICAgICBhY2MzOiBBY2NvdW50LAogICAgLy8gKSAtPiBBY2NvdW50OgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjY5CiAgICAvLyBpZiBhY2MxICE9IEdsb2JhbC56ZXJvX2FkZHJlc3MgYW5kIG9wLkFjY3RQYXJhbXNHZXQuYWNjdF9iYWxhbmNlKGFjYzEpWzFdOgogICAgZnJhbWVfZGlnIC0zCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBieiByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW9fZWxzZV9ib2R5QDMKICAgIGZyYW1lX2RpZyAtMwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJ6IHJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpb19lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo3MAogICAgLy8gcmV0dXJuIGFjYzEKICAgIGZyYW1lX2RpZyAtMwogICAgcmV0c3ViCgpyZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW9fZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjcxCiAgICAvLyBlbGlmIGFjYzIgIT0gR2xvYmFsLnplcm9fYWRkcmVzcyBhbmQgb3AuQWNjdFBhcmFtc0dldC5hY2N0X2JhbGFuY2UoYWNjMilbMV06CiAgICBmcmFtZV9kaWcgLTIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IHJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpb19lbHNlX2JvZHlANgogICAgZnJhbWVfZGlnIC0yCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYnogcmVzb2x2ZV9yZWNlaXZlcl9ieV9wcmlvX2Vsc2VfYm9keUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjcyCiAgICAvLyByZXR1cm4gYWNjMgogICAgZnJhbWVfZGlnIC0yCiAgICByZXRzdWIKCnJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpb19lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6NzMKICAgIC8vIGVsaWYgYWNjMyAhPSBHbG9iYWwuemVyb19hZGRyZXNzIGFuZCBvcC5BY2N0UGFyYW1zR2V0LmFjY3RfYmFsYW5jZShhY2MzKVsxXToKICAgIGZyYW1lX2RpZyAtMQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYnogcmVzb2x2ZV9yZWNlaXZlcl9ieV9wcmlvX2Vsc2VfYm9keUA5CiAgICBmcmFtZV9kaWcgLTEKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYnVyeSAxCiAgICBieiByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW9fZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6NzQKICAgIC8vIHJldHVybiBhY2MzCiAgICBmcmFtZV9kaWcgLTEKICAgIHJldHN1YgoKcmVzb2x2ZV9yZWNlaXZlcl9ieV9wcmlvX2Vsc2VfYm9keUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo3NgogICAgLy8gVHhuLnNlbmRlciAhPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5Ojc2LTc3CiAgICAvLyBUeG4uc2VuZGVyICE9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIGFuZCBvcC5BY2N0UGFyYW1zR2V0LmFjY3RfYmFsYW5jZShUeG4uc2VuZGVyKVsxXQogICAgYnogcmVzb2x2ZV9yZWNlaXZlcl9ieV9wcmlvX2Vsc2VfYm9keUAxMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo3NwogICAgLy8gYW5kIG9wLkFjY3RQYXJhbXNHZXQuYWNjdF9iYWxhbmNlKFR4bi5zZW5kZXIpWzFdCiAgICB0eG4gU2VuZGVyCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo3Ni03NwogICAgLy8gVHhuLnNlbmRlciAhPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBhbmQgb3AuQWNjdFBhcmFtc0dldC5hY2N0X2JhbGFuY2UoVHhuLnNlbmRlcilbMV0KICAgIGJ6IHJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpb19lbHNlX2JvZHlAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6NzkKICAgIC8vIHJldHVybiBUeG4uc2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICByZXRzdWIKCnJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpb19lbHNlX2JvZHlAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjgxCiAgICAvLyByZXR1cm4gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuc3Vicm91dGluZXMuY2hlY2tfYWNjX2luX2dhbWUoZ2FtZV9pZDogdWludDY0LCBhY2NvdW50OiBieXRlcywgYm94X2dhbWVfcGxheWVyczogYnl0ZXMsIHBsYXllcl9jb3VudDogdWludDY0LCBjbGVhcl9wbGF5ZXI6IHVpbnQ2NCkgLT4gdWludDY0OgpjaGVja19hY2NfaW5fZ2FtZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6OTYtMTA0CiAgICAvLyAjIENoZWNrIGlmIGFjY291bnQgaXMgYW4gYWN0aXZlIHBsYXllciBvZiBhIGdhbWUKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgY2hlY2tfYWNjX2luX2dhbWUoCiAgICAvLyAgICAgZ2FtZV9pZDogVUludDY0LAogICAgLy8gICAgIGFjY291bnQ6IEFjY291bnQsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVyczogQm94TWFwW1VJbnQ2NCwgQnl0ZXNdLAogICAgLy8gICAgIHBsYXllcl9jb3VudDogVUludDY0LAogICAgLy8gICAgIGNsZWFyX3BsYXllcjogYm9vbCwgICMgbm9xYTogRkJUMDAxCiAgICAvLyApIC0+IGJvb2w6CiAgICBwcm90byA1IDEKICAgIGludGNfMCAvLyAwCiAgICBwdXNoYnl0ZXMgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTA1LTEwNgogICAgLy8gIyBDYWxjdWxhdGUgdG90YWwgYnl0ZSBsZW5ndGggdG8gaXRlcmF0ZSBvdmVyIGJhc2VkIG9uIHBsYXllciBjb3VudCBhbmQgYWRkcmVzcyBzaXplCiAgICAvLyBnYW1lX3BsYXllcnNfbGVuZ3RoID0gcGxheWVyX2NvdW50ICogY3N0LkFERFJFU1NfU0laRQogICAgZnJhbWVfZGlnIC0yCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTA4LTEwOQogICAgLy8gIyBJbml0aWFsaXplIGZsYWcgdG8gdHJhY2sgaWYgYWNjb3VudCBpcyBmb3VuZCBpbiBnYW1lCiAgICAvLyBhY2NfaW5fZ2FtZSA9IEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxMTEtMTEyCiAgICAvLyAjIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGxheWVyIGJ5dGUgYXJyYXkgaW4gMzItYnl0ZSBjaHVua3MgKG9uZSBhZGRyZXNzIHBlciBjaHVuaykKICAgIC8vIGZvciBpIGluIHVyYW5nZSgwLCBnYW1lX3BsYXllcnNfbGVuZ3RoLCBjc3QuQUREUkVTU19TSVpFKToKICAgIGR1cAoKY2hlY2tfYWNjX2luX2dhbWVfZm9yX2hlYWRlckAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxMTEtMTEyCiAgICAvLyAjIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGxheWVyIGJ5dGUgYXJyYXkgaW4gMzItYnl0ZSBjaHVua3MgKG9uZSBhZGRyZXNzIHBlciBjaHVuaykKICAgIC8vIGZvciBpIGluIHVyYW5nZSgwLCBnYW1lX3BsYXllcnNfbGVuZ3RoLCBjc3QuQUREUkVTU19TSVpFKToKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2J1cnkgMQogICAgYnogY2hlY2tfYWNjX2luX2dhbWVfYWZ0ZXJfZm9yQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTEzLTExNAogICAgLy8gIyBFeHRyYWN0IHRoZSAzMi1ieXRlIHBsYXllciBhZGRyZXNzIGF0IHN0YXJ0IGluZGV4IGkKICAgIC8vIHBsYXllcl9hZGRyX2J5dGVzID0gb3AuZXh0cmFjdChib3hfZ2FtZV9wbGF5ZXJzW2dhbWVfaWRdLCBpLCBjc3QuQUREUkVTU19TSVpFKQogICAgZnJhbWVfZGlnIC01CiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTMKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBCb3hNYXAgZW50cnkgZXhpc3RzCiAgICBmcmFtZV9kaWcgNAogICAgaW50Y18zIC8vIDMyCiAgICBleHRyYWN0MwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxMTYtMTE3CiAgICAvLyAjIENoZWNrIGlmIHRoZSBleHRyYWN0ZWQgcGxheWVyIGFkZHJlc3MgYnl0ZXMgbWF0Y2ggdXAgd2l0aCB0aGUgYWNjb3VudCBieXRlcwogICAgLy8gaWYgYWNjb3VudC5ieXRlcyA9PSBwbGF5ZXJfYWRkcl9ieXRlczoKICAgIGZyYW1lX2RpZyAtNAogICAgPT0KICAgIGJ6IGNoZWNrX2FjY19pbl9nYW1lX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxMTgKICAgIC8vIGFjY19pbl9nYW1lID0gVHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxMjAtMTIxCiAgICAvLyAjIE9wdGlvbmFsbHkgY2xlYXIgdGhpcyBwbGF5ZXIgZnJvbSB0aGUgYm94IGJ5IHJlcGxhY2luZyB0aGVpciBhZGRyZXNzIHdpdGggemVybyBieXRlcwogICAgLy8gaWYgY2xlYXJfcGxheWVyOgogICAgZnJhbWVfZGlnIC0xCiAgICBieiBjaGVja19hY2NfaW5fZ2FtZV9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTI1CiAgICAvLyBnYW1lX3BsYXllcnNfYnJlZi5yZXBsYWNlKGksIGNzdC5aRVJPX0FERFJfQllURVMpCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDQKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBib3hfcmVwbGFjZQoKY2hlY2tfYWNjX2luX2dhbWVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2J1cnkgMQoKY2hlY2tfYWNjX2luX2dhbWVfYWZ0ZXJfZm9yQDg6CiAgICBmcmFtZV9kaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxMzAtMTMxCiAgICAvLyAjIFJldHVybiBUcnVlIGlmIGFjY291bnQgd2FzIGZvdW5kIGluIHRoZSBnYW1lLCBlbHNlIEZhbHNlCiAgICAvLyByZXR1cm4gYWNjX2luX2dhbWUKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpjaGVja19hY2NfaW5fZ2FtZV9hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjExMS0xMTIKICAgIC8vICMgSXRlcmF0ZSB0aHJvdWdoIHRoZSBwbGF5ZXIgYnl0ZSBhcnJheSBpbiAzMi1ieXRlIGNodW5rcyAob25lIGFkZHJlc3MgcGVyIGNodW5rKQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDAsIGdhbWVfcGxheWVyc19sZW5ndGgsIGNzdC5BRERSRVNTX1NJWkUpOgogICAgZnJhbWVfZGlnIDQKICAgIGludGNfMyAvLyAzMgogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIGNoZWNrX2FjY19pbl9nYW1lX2Zvcl9oZWFkZXJAMQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuc3Vicm91dGluZXMuY2FuX3F1aWNrX3BsYXkoZ2FtZV9zdGF0ZTogYnl0ZXMpIC0+IHVpbnQ2NCwgYnl0ZXM6CmNhbl9xdWlja19wbGF5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMjItMjI0CiAgICAvLyAjIENoZWNrIGlmIHF1aWNrIHBsYXkgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBpZiBhbGwgY29uZGl0aW9ucyBhcmUgbWV0LCBlbHNlIGZhbHNlCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGNhbl9xdWlja19wbGF5KGdhbWVfc3RhdGU6IHN0Yy5HYW1lU3RhdGUpIC0+IGJvb2w6CiAgICBwcm90byAxIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjI2CiAgICAvLyBnYW1lX3N0YXRlLnF1aWNrX3BsYXlfZW5hYmxlZC5uYXRpdmUgICMgUXVpY2sgcGxheSBtb2RlIG11c3QgYmUgZW5hYmxlZAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzEgLy8gMQogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMjYtMjI4CiAgICAvLyBnYW1lX3N0YXRlLnF1aWNrX3BsYXlfZW5hYmxlZC5uYXRpdmUgICMgUXVpY2sgcGxheSBtb2RlIG11c3QgYmUgZW5hYmxlZAogICAgLy8gYW5kIGdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcy5uYXRpdmUgPT0gVHhuLnNlbmRlciAgIyBUeG4gc2VuZGVyIG11c3QgYmUgZ2FtZSBpbnN0YW5jZSBhZG1pbgogICAgLy8gYW5kIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMubmF0aXZlID4gMSAgIyBNb3JlIHRoYW4gMSBhY3RpdmUgcGxheWVyIGluIGdhbWUgcmVxdWlyZWQKICAgIGJ6IGNhbl9xdWlja19wbGF5X2Jvb2xfZmFsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMjcKICAgIC8vIGFuZCBnYW1lX3N0YXRlLmFkbWluX2FkZHJlc3MubmF0aXZlID09IFR4bi5zZW5kZXIgICMgVHhuIHNlbmRlciBtdXN0IGJlIGdhbWUgaW5zdGFuY2UgYWRtaW4KICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyNSAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHR4biBTZW5kZXIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIyNi0yMjgKICAgIC8vIGdhbWVfc3RhdGUucXVpY2tfcGxheV9lbmFibGVkLm5hdGl2ZSAgIyBRdWljayBwbGF5IG1vZGUgbXVzdCBiZSBlbmFibGVkCiAgICAvLyBhbmQgZ2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSA9PSBUeG4uc2VuZGVyICAjIFR4biBzZW5kZXIgbXVzdCBiZSBnYW1lIGluc3RhbmNlIGFkbWluCiAgICAvLyBhbmQgZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgPiAxICAjIE1vcmUgdGhhbiAxIGFjdGl2ZSBwbGF5ZXIgaW4gZ2FtZSByZXF1aXJlZAogICAgYnogY2FuX3F1aWNrX3BsYXlfYm9vbF9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIyOAogICAgLy8gYW5kIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMubmF0aXZlID4gMSAgIyBNb3JlIHRoYW4gMSBhY3RpdmUgcGxheWVyIGluIGdhbWUgcmVxdWlyZWQKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18yIC8vIDIKICAgIGdldGJ5dGUKICAgIGludGNfMSAvLyAxCiAgICA+CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIyNi0yMjgKICAgIC8vIGdhbWVfc3RhdGUucXVpY2tfcGxheV9lbmFibGVkLm5hdGl2ZSAgIyBRdWljayBwbGF5IG1vZGUgbXVzdCBiZSBlbmFibGVkCiAgICAvLyBhbmQgZ2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSA9PSBUeG4uc2VuZGVyICAjIFR4biBzZW5kZXIgbXVzdCBiZSBnYW1lIGluc3RhbmNlIGFkbWluCiAgICAvLyBhbmQgZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgPiAxICAjIE1vcmUgdGhhbiAxIGFjdGl2ZSBwbGF5ZXIgaW4gZ2FtZSByZXF1aXJlZAogICAgYnogY2FuX3F1aWNrX3BsYXlfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQoKY2FuX3F1aWNrX3BsYXlfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMjUtMjI5CiAgICAvLyByZXR1cm4gKAogICAgLy8gICAgIGdhbWVfc3RhdGUucXVpY2tfcGxheV9lbmFibGVkLm5hdGl2ZSAgIyBRdWljayBwbGF5IG1vZGUgbXVzdCBiZSBlbmFibGVkCiAgICAvLyAgICAgYW5kIGdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcy5uYXRpdmUgPT0gVHhuLnNlbmRlciAgIyBUeG4gc2VuZGVyIG11c3QgYmUgZ2FtZSBpbnN0YW5jZSBhZG1pbgogICAgLy8gICAgIGFuZCBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzLm5hdGl2ZSA+IDEgICMgTW9yZSB0aGFuIDEgYWN0aXZlIHBsYXllciBpbiBnYW1lIHJlcXVpcmVkCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTEKICAgIHJldHN1YgoKY2FuX3F1aWNrX3BsYXlfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgY2FuX3F1aWNrX3BsYXlfYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5zdWJyb3V0aW5lcy5pc19nYW1lX2xpdmUoZ2FtZV9pZDogdWludDY0LCBnYW1lX3N0YXRlOiBieXRlcykgLT4gYnl0ZXM6CmlzX2dhbWVfbGl2ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjMyLTIzNAogICAgLy8gIyBDaGVjayBpZiBnYW1lIGlzIGxpdmUgYW5kIGV4ZWN1dGUgaXRzIGNvbmRpdGlvbmFsIGxvZ2ljCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGlzX2dhbWVfbGl2ZShnYW1lX2lkOiBVSW50NjQsIGdhbWVfc3RhdGU6IHN0Yy5HYW1lU3RhdGUpIC0+IE5vbmU6CiAgICBwcm90byAyIDEKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIzNwogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMgPCBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAgIyBJZiBkZWFkbGluZSBleHBpcmVkCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgOSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgYjwKICAgIGZyYW1lX2RpZyAtMQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMzctMjM5CiAgICAvLyBnYW1lX3N0YXRlLmV4cGlyeV90cyA8IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICAjIElmIGRlYWRsaW5lIGV4cGlyZWQKICAgIC8vIG9yIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMgPT0gZ2FtZV9zdGF0ZS5tYXhfcGxheWVycyAgIyBJZiBsb2JieSBmdWxsCiAgICAvLyBvciBjYW5fcXVpY2tfcGxheShnYW1lX3N0YXRlPWdhbWVfc3RhdGUpICAjIElmIHF1aWNrIHBsYXkgY29uZGl0aW9ucyBhcmUgbWV0CiAgICBibnogaXNfZ2FtZV9saXZlX2lmX2JvZHlANQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMzgKICAgIC8vIG9yIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMgPT0gZ2FtZV9zdGF0ZS5tYXhfcGxheWVycyAgIyBJZiBsb2JieSBmdWxsCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAxIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDEgMSAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGI9PQogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjM3LTIzOQogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMgPCBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAgIyBJZiBkZWFkbGluZSBleHBpcmVkCiAgICAvLyBvciBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzID09IGdhbWVfc3RhdGUubWF4X3BsYXllcnMgICMgSWYgbG9iYnkgZnVsbAogICAgLy8gb3IgY2FuX3F1aWNrX3BsYXkoZ2FtZV9zdGF0ZT1nYW1lX3N0YXRlKSAgIyBJZiBxdWljayBwbGF5IGNvbmRpdGlvbnMgYXJlIG1ldAogICAgYm56IGlzX2dhbWVfbGl2ZV9pZl9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjM5CiAgICAvLyBvciBjYW5fcXVpY2tfcGxheShnYW1lX3N0YXRlPWdhbWVfc3RhdGUpICAjIElmIHF1aWNrIHBsYXkgY29uZGl0aW9ucyBhcmUgbWV0CiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgY2FuX3F1aWNrX3BsYXkKICAgIGR1cG4gMgogICAgZnJhbWVfYnVyeSAtMQogICAgZnJhbWVfYnVyeSAwCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjM3LTIzOQogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMgPCBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAgIyBJZiBkZWFkbGluZSBleHBpcmVkCiAgICAvLyBvciBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzID09IGdhbWVfc3RhdGUubWF4X3BsYXllcnMgICMgSWYgbG9iYnkgZnVsbAogICAgLy8gb3IgY2FuX3F1aWNrX3BsYXkoZ2FtZV9zdGF0ZT1nYW1lX3N0YXRlKSAgIyBJZiBxdWljayBwbGF5IGNvbmRpdGlvbnMgYXJlIG1ldAogICAgYnogaXNfZ2FtZV9saXZlX2FmdGVyX2lmX2Vsc2VAMTAKCmlzX2dhbWVfbGl2ZV9pZl9ib2R5QDU6CiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBmcmFtZV9idXJ5IC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI0MS0yNDIKICAgIC8vICMgTWFyayBqb2luIHBoYXNlIGFzIGNvbXBsZXRlIHdoZW4gc3Rha2luZyBmaW5hbGl6ZWQgZXZhbHVhdGVzIFRydWUKICAgIC8vIGdhbWVfc3RhdGUuc3Rha2luZ19maW5hbGl6ZWQgPSBhcmM0LkJvb2woVHJ1ZSkgICMgbm9xYTogRkJUMDAzCiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18xIC8vIDEKICAgIHNldGJpdAogICAgZnJhbWVfYnVyeSAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyNDYKICAgIC8vIEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICsgVUludDY0KGNzdC5QSEFTRV9FWFBJUllfSU5URVJWQUwpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjIDUgLy8gMjAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI0NC0yNDcKICAgIC8vICMgRXN0YWJsaXNoIGdhbWUgcGxheSB3aW5kb3cgYnkgc2V0dGluZyBleHBpcnkgdGltZXN0YW1wCiAgICAvLyBnYW1lX3N0YXRlLmV4cGlyeV90cyA9IGFyYzQuVUludDY0KAogICAgLy8gICAgIEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICsgVUludDY0KGNzdC5QSEFTRV9FWFBJUllfSU5URVJWQUwpCiAgICAvLyApCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIHJlcGxhY2UyIDkKICAgIGZyYW1lX2J1cnkgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjUyCiAgICAvLyBnYW1lX2lkLAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI1MwogICAgLy8gZ2FtZV9zdGF0ZS5zdGFraW5nX2ZpbmFsaXplZCwKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnl0ZWNfMSAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjU0CiAgICAvLyBnYW1lX3N0YXRlLmV4cGlyeV90cywKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCA5IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI0OS0yNTUKICAgIC8vICMgRW1pdCBBUkMtMjggZXZlbnQgZm9yIG9mZi1jaGFpbiB0cmFja2luZwogICAgLy8gYXJjNC5lbWl0KAogICAgLy8gICAgICJnYW1lX2xpdmUodWludDY0LGJvb2wsdWludDY0KSIsCiAgICAvLyAgICAgZ2FtZV9pZCwKICAgIC8vICAgICBnYW1lX3N0YXRlLnN0YWtpbmdfZmluYWxpemVkLAogICAgLy8gICAgIGdhbWVfc3RhdGUuZXhwaXJ5X3RzLAogICAgLy8gKQogICAgY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDkzNjE3ZDI0IC8vIG1ldGhvZCAiZ2FtZV9saXZlKHVpbnQ2NCxib29sLHVpbnQ2NCkiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDAKCmlzX2dhbWVfbGl2ZV9hZnRlcl9pZl9lbHNlQDEwOgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5zdWJyb3V0aW5lcy5pc19nYW1lX292ZXIoZ2FtZV9pZDogdWludDY0LCBnYW1lX3N0YXRlOiBieXRlcywgYm94X2dhbWVfcmVnaXN0ZXI6IGJ5dGVzLCBib3hfZ2FtZV9wbGF5ZXJzOiBieXRlcykgLT4gYnl0ZXM6CmlzX2dhbWVfb3ZlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjU3LTI2NAogICAgLy8gIyBDaGVjayBpZiBnYW1lIGlzIG92ZXIgYW5kIGV4ZWN1dGUgaXRzIGNvbmRpdGlvbmFsIGxvZ2ljCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGlzX2dhbWVfb3ZlcigKICAgIC8vICAgICBnYW1lX2lkOiBVSW50NjQsCiAgICAvLyAgICAgZ2FtZV9zdGF0ZTogc3RjLkdhbWVTdGF0ZSwKICAgIC8vICAgICBib3hfZ2FtZV9yZWdpc3RlcjogQm94TWFwW0FjY291bnQsIHN0Yy5HYW1lUmVnaXN0ZXJdLAogICAgLy8gICAgIGJveF9nYW1lX3BsYXllcnM6IEJveE1hcFtVSW50NjQsIEJ5dGVzXSwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDQgMQogICAgaW50Y18wIC8vIDAKICAgIGR1cG4gOQogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjY1LTI2NgogICAgLy8gIyBEZWZpbmUgZ2FtZSBvdmVyIGNyaXRlcmlhCiAgICAvLyBkZWFkbGluZV9leHBpcmVkID0gZ2FtZV9zdGF0ZS5leHBpcnlfdHMgPCBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZnJhbWVfZGlnIC0zCiAgICBleHRyYWN0IDkgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIGI8CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI2NwogICAgLy8gbm9fYWN0aXZlX3BsYXllcnMgPSBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzLm5hdGl2ZSA9PSAwCiAgICBmcmFtZV9kaWcgLTMKICAgIGludGNfMiAvLyAyCiAgICBnZXRieXRlCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjY5CiAgICAvLyBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzLm5hdGl2ZSA9PSAxCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjY5LTI3NgogICAgLy8gZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgPT0gMQogICAgLy8gYW5kIGNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PWdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1ib3hfZ2FtZV9wbGF5ZXJzLAogICAgLy8gICAgIHBsYXllcl9jb3VudD1VSW50NjQoMSksCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKQogICAgYnogaXNfZ2FtZV9vdmVyX2Jvb2xfZmFsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyNzIKICAgIC8vIGFjY291bnQ9Z2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyAtMwogICAgZXh0cmFjdCAyNSAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjcwLTI3NgogICAgLy8gYW5kIGNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PWdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1ib3hfZ2FtZV9wbGF5ZXJzLAogICAgLy8gICAgIHBsYXllcl9jb3VudD1VSW50NjQoMSksCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKQogICAgZnJhbWVfZGlnIC00CiAgICBzd2FwCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6Mjc0CiAgICAvLyBwbGF5ZXJfY291bnQ9VUludDY0KDEpLAogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6Mjc1CiAgICAvLyBjbGVhcl9wbGF5ZXI9RmFsc2UsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyNzAtMjc2CiAgICAvLyBhbmQgY2hlY2tfYWNjX2luX2dhbWUoCiAgICAvLyAgICAgZ2FtZV9pZD1nYW1lX2lkLAogICAgLy8gICAgIGFjY291bnQ9Z2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPWJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PVVJbnQ2NCgxKSwKICAgIC8vICAgICBjbGVhcl9wbGF5ZXI9RmFsc2UsCiAgICAvLyApCiAgICBjYWxsc3ViIGNoZWNrX2FjY19pbl9nYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI2OS0yNzYKICAgIC8vIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMubmF0aXZlID09IDEKICAgIC8vIGFuZCBjaGVja19hY2NfaW5fZ2FtZSgKICAgIC8vICAgICBnYW1lX2lkPWdhbWVfaWQsCiAgICAvLyAgICAgYWNjb3VudD1nYW1lX3N0YXRlLmFkbWluX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGJveF9nYW1lX3BsYXllcnM9Ym94X2dhbWVfcGxheWVycywKICAgIC8vICAgICBwbGF5ZXJfY291bnQ9VUludDY0KDEpLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICkKICAgIGJ6IGlzX2dhbWVfb3Zlcl9ib29sX2ZhbHNlQDMKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDEwCgppc19nYW1lX292ZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyNzktMjgwCiAgICAvLyAjIENoZWNrIGdhbWUgb3ZlciBjcml0ZXJpYQogICAgLy8gaWYgZGVhZGxpbmVfZXhwaXJlZCBvciBub19hY3RpdmVfcGxheWVycyBvciBhZG1pbl9vbmx5X3BsYXllcjoKICAgIGZyYW1lX2RpZyAxNgogICAgYm56IGlzX2dhbWVfb3Zlcl9pZl9ib2R5QDcKICAgIGZyYW1lX2RpZyAxNwogICAgYnogaXNfZ2FtZV9vdmVyX2lmX2JvZHlANwogICAgZnJhbWVfZGlnIC0zCiAgICBmcmFtZV9idXJ5IDIKICAgIGZyYW1lX2RpZyAxMAogICAgYnogaXNfZ2FtZV9vdmVyX2FmdGVyX2lmX2Vsc2VAMzAKCmlzX2dhbWVfb3Zlcl9pZl9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI4MS0yODIKICAgIC8vICMgUmVzZXQgZ2FtZSByZWdpc3RlciBib3ggY29udGVudHMgZm9yIGFueSByZW1haW5pbmcgcGxheWVycwogICAgLy8gZ2FtZV9wbGF5ZXJzX2JyZWYgPSBCb3hSZWYoa2V5PWJveF9nYW1lX3BsYXllcnMua2V5X3ByZWZpeCArIG9wLml0b2IoZ2FtZV9pZCkpCiAgICBmcmFtZV9kaWcgLTQKICAgIGl0b2IKICAgIGR1cAogICAgZnJhbWVfYnVyeSA5CiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjgzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMCwgZ2FtZV9wbGF5ZXJzX2JyZWYubGVuZ3RoLCAzMik6CiAgICBib3hfbGVuCiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDE1CiAgICBhc3NlcnQgLy8gY2hlY2sgQm94UmVmIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMTIKCmlzX2dhbWVfb3Zlcl9mb3JfaGVhZGVyQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI4MwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDAsIGdhbWVfcGxheWVyc19icmVmLmxlbmd0aCwgMzIpOgogICAgZnJhbWVfZGlnIDEyCiAgICBmcmFtZV9kaWcgMTUKICAgIDwKICAgIGJ6IGlzX2dhbWVfb3Zlcl9hZnRlcl9mb3JAMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6Mjg0CiAgICAvLyBwbGF5ZXJfYWRkcl9ieXRlcyA9IGdhbWVfcGxheWVyc19icmVmLmV4dHJhY3QoaSwgMzIpCiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfZGlnIDEyCiAgICBpbnRjXzMgLy8gMzIKICAgIGJveF9leHRyYWN0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyODUKICAgIC8vIGlmIHBsYXllcl9hZGRyX2J5dGVzICE9IEJ5dGVzKGNzdC5aRVJPX0FERFJfQllURVMpOgogICAgYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgICE9CiAgICBieiBpc19nYW1lX292ZXJfYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo5MQogICAgLy8gYm94X2dhbWVfcmVnaXN0ZXJbYWNjb3VudF0uZ2FtZV9pZCA9IGFyYzQuVUludDY0KDApCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAzCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIEJveE1hcCBlbnRyeSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICByZXBsYWNlMiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjkyCiAgICAvLyBib3hfZ2FtZV9yZWdpc3RlclthY2NvdW50XS5jb21taXRfcmFuZF9yb3VuZCA9IGFyYzQuVUludDY0KDApCiAgICBieXRlYyA2IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgcmVwbGFjZTIgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6OTMKICAgIC8vIGJveF9nYW1lX3JlZ2lzdGVyW2FjY291bnRdLmV4cGlyeV9yb3VuZCA9IGFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCArIHJvdW5kX2RlbHRhKQogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI5MQogICAgLy8gcm91bmRfZGVsdGE9VUludDY0KGNzdC5CT1hfUl9FWFBfUk9VTkRfREVMVEEpLAogICAgaW50YyA2IC8vIDE1MDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTo5MwogICAgLy8gYm94X2dhbWVfcmVnaXN0ZXJbYWNjb3VudF0uZXhwaXJ5X3JvdW5kID0gYXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kICsgcm91bmRfZGVsdGEpCiAgICArCiAgICBpdG9iCiAgICByZXBsYWNlMiAxOAogICAgYm94X3B1dAoKaXNfZ2FtZV9vdmVyX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI4MwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDAsIGdhbWVfcGxheWVyc19icmVmLmxlbmd0aCwgMzIpOgogICAgZnJhbWVfZGlnIDEyCiAgICBpbnRjXzMgLy8gMzIKICAgICsKICAgIGZyYW1lX2J1cnkgMTIKICAgIGIgaXNfZ2FtZV9vdmVyX2Zvcl9oZWFkZXJAOAoKaXNfZ2FtZV9vdmVyX2FmdGVyX2ZvckAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6Mjk2CiAgICAvLyBjc3QuQUREUkVTU19TSVpFICogZ2FtZV9zdGF0ZS5tYXhfcGxheWVycy5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMwogICAgaW50Y18xIC8vIDEKICAgIGdldGJ5dGUKICAgIGludGNfMyAvLyAzMgogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyOTQtMjk3CiAgICAvLyAjIENsZWFyIGJveCBnYW1lIHBsYXllcnMgZGF0YSBieSBzZXR0aW5nIGl0cyB2YWx1ZSB0byBhbGwgemVyb2VzCiAgICAvLyBib3hfZ2FtZV9wbGF5ZXJzW2dhbWVfaWRdID0gb3AuYnplcm8oCiAgICAvLyAgICAgY3N0LkFERFJFU1NfU0laRSAqIGdhbWVfc3RhdGUubWF4X3BsYXllcnMubmF0aXZlCiAgICAvLyApCiAgICBiemVybwogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI5OS0zMDAKICAgIC8vICMgTWFyayBnYW1lIGFzIG92ZXIgYnkgc2V0dGluZyBhY3RpdmUgcGxheWVycyB0byB6ZXJvCiAgICAvLyBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzID0gYXJjNC5VSW50OCgwKQogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlY18xIC8vIDB4MDAKICAgIHJlcGxhY2UyIDIKICAgIGR1cAogICAgZnJhbWVfYnVyeSAtMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMDYKICAgIC8vIGdhbWVfc3RhdGUuZmlyc3RfcGxhY2Vfc2NvcmUsCiAgICBleHRyYWN0IDMgMSAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzA3CiAgICAvLyBnYW1lX3N0YXRlLnNlY29uZF9wbGFjZV9zY29yZSwKICAgIGZyYW1lX2RpZyAtMwogICAgZXh0cmFjdCA0IDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMwOAogICAgLy8gZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9zY29yZSwKICAgIGZyYW1lX2RpZyAtMwogICAgZXh0cmFjdCA1IDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMwOQogICAgLy8gZ2FtZV9zdGF0ZS5maXJzdF9wbGFjZV9hZGRyZXNzLAogICAgZnJhbWVfZGlnIC0zCiAgICBleHRyYWN0IDU3IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBjb3ZlciA0CiAgICBmcmFtZV9idXJ5IDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzEwCiAgICAvLyBnYW1lX3N0YXRlLnNlY29uZF9wbGFjZV9hZGRyZXNzLAogICAgZnJhbWVfZGlnIC0zCiAgICBleHRyYWN0IDg5IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBjb3ZlciA1CiAgICBmcmFtZV9idXJ5IDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzExCiAgICAvLyBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MsCiAgICBmcmFtZV9kaWcgLTMKICAgIGV4dHJhY3QgMTIxIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBjb3ZlciA2CiAgICBmcmFtZV9idXJ5IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzAyLTMxMgogICAgLy8gIyBFbWl0IEFSQy0yOCBldmVudCBmb3Igb2ZmLWNoYWluIHRyYWNraW5nCiAgICAvLyBhcmM0LmVtaXQoCiAgICAvLyAgICAgImdhbWVfb3Zlcih1aW50NjQsdWludDgsdWludDgsdWludDgsYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MpIiwKICAgIC8vICAgICBnYW1lX2lkLAogICAgLy8gICAgIGdhbWVfc3RhdGUuZmlyc3RfcGxhY2Vfc2NvcmUsCiAgICAvLyAgICAgZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2Vfc2NvcmUsCiAgICAvLyAgICAgZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9zY29yZSwKICAgIC8vICAgICBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX2FkZHJlc3MsCiAgICAvLyAgICAgZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2VfYWRkcmVzcywKICAgIC8vICAgICBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MsCiAgICAvLyApCiAgICBmcmFtZV9kaWcgOQogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDVmYTViZGQzIC8vIG1ldGhvZCAiZ2FtZV9vdmVyKHVpbnQ2NCx1aW50OCx1aW50OCx1aW50OCxhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcykiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMTQtMzE1CiAgICAvLyAjIElmIG9ubHkgMSBwbGF5ZXIgaW4gbG9iYnkgYWZ0ZXIgZ2FtZSBnb2VzIGxpdmUsIHRoZXkgZ2V0IGVudGlyZSBwcml6ZSBwb29sCiAgICAvLyBpZiBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlID09IGNzdC5TVEFLRV9BTU9VTlQ6CiAgICBmcmFtZV9kaWcgLTMKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTEKICAgIGludGMgNCAvLyAxMDAwMDAwCiAgICA9PQogICAgYnogaXNfZ2FtZV9vdmVyX2Vsc2VfYm9keUAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMTcKICAgIC8vIHNlY29uZF9wcml6ZV9zaGFyZSA9IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzE4CiAgICAvLyB0aGlyZF9wcml6ZV9zaGFyZSA9IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMTQKCmlzX2dhbWVfb3Zlcl9hZnRlcl9pZl9lbHNlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMzcKICAgIC8vIGFjYzI9Z2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyAtMwogICAgZXh0cmFjdCAyNSAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzM4CiAgICAvLyBhY2MzPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzM0LTMzOQogICAgLy8gIyBSZXNvbHZlIHByaXplIHBvb2wgd2luIHNoYXJlIHJlY2VpdmVycyBieSBwcmlvcml0eQogICAgLy8gZmlyc3RfcGxhY2VfcmVjZWl2ZXIgPSByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8oCiAgICAvLyAgICAgYWNjMT1nYW1lX3N0YXRlLmZpcnN0X3BsYWNlX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGFjYzI9Z2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBhY2MzPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyApCiAgICBmcmFtZV9kaWcgNgogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8KICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNDMKICAgIC8vIGFjYzM9R2xvYmFsLmNyZWF0b3JfYWRkcmVzcywKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNDAtMzQ0CiAgICAvLyBzZWNvbmRfcGxhY2VfcmVjZWl2ZXIgPSByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8oCiAgICAvLyAgICAgYWNjMT1nYW1lX3N0YXRlLnNlY29uZF9wbGFjZV9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBhY2MyPWdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYWNjMz1HbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gKQogICAgZnJhbWVfZGlnIDcKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgcmVzb2x2ZV9yZWNlaXZlcl9ieV9wcmlvCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzQ4CiAgICAvLyBhY2MzPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzQ1LTM0OQogICAgLy8gdGhpcmRfcGxhY2VfcmVjZWl2ZXIgPSByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8oCiAgICAvLyAgICAgYWNjMT1nYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGFjYzI9Z2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBhY2MzPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyApCiAgICBmcmFtZV9kaWcgOAogICAgY292ZXIgMgogICAgY2FsbHN1YiByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8KICAgIGZyYW1lX2J1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNTEtMzUyCiAgICAvLyAjIElzc3VlIHByaXplIHBvb2wgc2hhcmUgcGF5b3V0cyB0byBmaXJzdCwgc2Vjb25kIGFuZCB0aGlyZCBwbGFjZSBhY2NvdW50cyBpZiB0aGVpciBzaGFyZSBpcyBub24temVybyBhbW91bnQKICAgIC8vIGlmIGZpcnN0X3ByaXplX3NoYXJlID4gVUludDY0KDApOgogICAgZnJhbWVfZGlnIDExCiAgICBieiBpc19nYW1lX292ZXJfYWZ0ZXJfaWZfZWxzZUAyMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNTMtMzU5CiAgICAvLyBwYXlvdXRfaXR4bigKICAgIC8vICAgICByZWNlaXZlcj1maXJzdF9wbGFjZV9yZWNlaXZlciwKICAgIC8vICAgICBhbW91bnQ9Zmlyc3RfcHJpemVfc2hhcmUsCiAgICAvLyAgICAgbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgICAgICdwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O2ZpcnN0X3ByaXplX3NoYXJlIn0nCiAgICAvLyAgICAgKSwKICAgIC8vICkKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzU2LTM1OAogICAgLy8gbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgJ3BpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJpc19nYW1lX292ZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7Zmlyc3RfcHJpemVfc2hhcmUifScKICAgIC8vICksCiAgICBwdXNoYnl0ZXMgInBpZW91dDpqe1wibWV0aG9kXCI6XCJwbGF5X2dhbWVcIixcInN1YnJvdXRpbmU6XCJpc19nYW1lX292ZXJcIixcImNvbmNlcm5cIjpcIml0eG4ucGF5O2ZpcnN0X3ByaXplX3NoYXJlXCJ9IgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNTMtMzU5CiAgICAvLyBwYXlvdXRfaXR4bigKICAgIC8vICAgICByZWNlaXZlcj1maXJzdF9wbGFjZV9yZWNlaXZlciwKICAgIC8vICAgICBhbW91bnQ9Zmlyc3RfcHJpemVfc2hhcmUsCiAgICAvLyAgICAgbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgICAgICdwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O2ZpcnN0X3ByaXplX3NoYXJlIn0nCiAgICAvLyAgICAgKSwKICAgIC8vICkKICAgIGNhbGxzdWIgcGF5b3V0X2l0eG4KCmlzX2dhbWVfb3Zlcl9hZnRlcl9pZl9lbHNlQDIzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNjAKICAgIC8vIGlmIHNlY29uZF9wcml6ZV9zaGFyZSA+IFVJbnQ2NCgwKToKICAgIGZyYW1lX2RpZyAxMwogICAgYnogaXNfZ2FtZV9vdmVyX2FmdGVyX2lmX2Vsc2VAMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzYxLTM2NwogICAgLy8gcGF5b3V0X2l0eG4oCiAgICAvLyAgICAgcmVjZWl2ZXI9c2Vjb25kX3BsYWNlX3JlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudD1zZWNvbmRfcHJpemVfc2hhcmUsCiAgICAvLyAgICAgbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgICAgICdwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O3NlY29uZF9wcml6ZV9zaGFyZSJ9JwogICAgLy8gICAgICksCiAgICAvLyApCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjM2NC0zNjYKICAgIC8vIG5vdGU9U3RyaW5nKAogICAgLy8gICAgICdwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O3NlY29uZF9wcml6ZV9zaGFyZSJ9JwogICAgLy8gKSwKICAgIHB1c2hieXRlcyAicGllb3V0Omp7XCJtZXRob2RcIjpcInBsYXlfZ2FtZVwiLFwic3Vicm91dGluZTpcImlzX2dhbWVfb3ZlclwiLFwiY29uY2VyblwiOlwiaXR4bi5wYXk7c2Vjb25kX3ByaXplX3NoYXJlXCJ9IgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNjEtMzY3CiAgICAvLyBwYXlvdXRfaXR4bigKICAgIC8vICAgICByZWNlaXZlcj1zZWNvbmRfcGxhY2VfcmVjZWl2ZXIsCiAgICAvLyAgICAgYW1vdW50PXNlY29uZF9wcml6ZV9zaGFyZSwKICAgIC8vICAgICBub3RlPVN0cmluZygKICAgIC8vICAgICAgICAgJ3BpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJpc19nYW1lX292ZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7c2Vjb25kX3ByaXplX3NoYXJlIn0nCiAgICAvLyAgICAgKSwKICAgIC8vICkKICAgIGNhbGxzdWIgcGF5b3V0X2l0eG4KCmlzX2dhbWVfb3Zlcl9hZnRlcl9pZl9lbHNlQDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNjgKICAgIC8vIGlmIHRoaXJkX3ByaXplX3NoYXJlID4gVUludDY0KDApOgogICAgZnJhbWVfZGlnIDE0CiAgICBieiBpc19nYW1lX292ZXJfYWZ0ZXJfaWZfZWxzZUAyNwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNjktMzc1CiAgICAvLyBwYXlvdXRfaXR4bigKICAgIC8vICAgICByZWNlaXZlcj10aGlyZF9wbGFjZV9yZWNlaXZlciwKICAgIC8vICAgICBhbW91bnQ9dGhpcmRfcHJpemVfc2hhcmUsCiAgICAvLyAgICAgbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgICAgICdwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O3RoaXJkX3ByaXplX3NoYXJlIn0nCiAgICAvLyAgICAgKSwKICAgIC8vICkKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9kaWcgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzcyLTM3NAogICAgLy8gbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgJ3BpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJpc19nYW1lX292ZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7dGhpcmRfcHJpemVfc2hhcmUifScKICAgIC8vICksCiAgICBwdXNoYnl0ZXMgInBpZW91dDpqe1wibWV0aG9kXCI6XCJwbGF5X2dhbWVcIixcInN1YnJvdXRpbmU6XCJpc19nYW1lX292ZXJcIixcImNvbmNlcm5cIjpcIml0eG4ucGF5O3RoaXJkX3ByaXplX3NoYXJlXCJ9IgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNjktMzc1CiAgICAvLyBwYXlvdXRfaXR4bigKICAgIC8vICAgICByZWNlaXZlcj10aGlyZF9wbGFjZV9yZWNlaXZlciwKICAgIC8vICAgICBhbW91bnQ9dGhpcmRfcHJpemVfc2hhcmUsCiAgICAvLyAgICAgbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgICAgICdwaWVvdXQ6ansibWV0aG9kIjoicGxheV9nYW1lIiwic3Vicm91dGluZToiaXNfZ2FtZV9vdmVyIiwiY29uY2VybiI6Iml0eG4ucGF5O3RoaXJkX3ByaXplX3NoYXJlIn0nCiAgICAvLyAgICAgKSwKICAgIC8vICkKICAgIGNhbGxzdWIgcGF5b3V0X2l0eG4KCmlzX2dhbWVfb3Zlcl9hZnRlcl9pZl9lbHNlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozNzctMzc4CiAgICAvLyAjIFNldCBwcml6ZSBwb29sIGFtb3VudCB0byB6ZXJvIGFmdGVyIG1ha2luZyBwYXlvdXRzCiAgICAvLyBnYW1lX3N0YXRlLnByaXplX3Bvb2wgPSBhcmM0LlVJbnQ2NCgwKQogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlYyA2IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgcmVwbGFjZTIgMTcKICAgIGR1cAogICAgZnJhbWVfYnVyeSAtMwogICAgZnJhbWVfYnVyeSAyCgppc19nYW1lX292ZXJfYWZ0ZXJfaWZfZWxzZUAzMDoKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKaXNfZ2FtZV9vdmVyX2Vsc2VfYm9keUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzE5LTMyMAogICAgLy8gIyBFbGlmLCBvbmx5IDIgcGxheWVycyBpbiBsb2JieSBhZnRlciBnYW1lIGdvZXMgbGl2ZSwgc3BsaXQgcHJpemUgcG9vbDogNjAlIC8gcmVtYWluZGVyIC8gMAogICAgLy8gZWxpZiBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlID09IDIgKiBjc3QuU1RBS0VfQU1PVU5UOgogICAgZnJhbWVfZGlnIDExCiAgICBwdXNoaW50IDIwMDAwMDAgLy8gMjAwMDAwMAogICAgPT0KICAgIGJ6IGlzX2dhbWVfb3Zlcl9lbHNlX2JvZHlAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MzIxCiAgICAvLyBmaXJzdF9wcml6ZV9zaGFyZSA9IGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgKiBVSW50NjQoNjApIC8vIFVJbnQ2NCgxMDApCiAgICBmcmFtZV9kaWcgMTEKICAgIGR1cAogICAgcHVzaGludCA2MCAvLyA2MAogICAgKgogICAgcHVzaGludCAxMDAgLy8gMTAwCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMyMgogICAgLy8gc2Vjb25kX3ByaXplX3NoYXJlID0gZ2FtZV9zdGF0ZS5wcml6ZV9wb29sLm5hdGl2ZSAtIGZpcnN0X3ByaXplX3NoYXJlCiAgICBzd2FwCiAgICBkaWcgMQogICAgLQogICAgZnJhbWVfYnVyeSAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMjMKICAgIC8vIHRoaXJkX3ByaXplX3NoYXJlID0gVUludDY0KDApICAjIE5vIHRoaXJkIHBsYXllcgogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMTQKICAgIGZyYW1lX2J1cnkgMTEKICAgIGIgaXNfZ2FtZV9vdmVyX2FmdGVyX2lmX2Vsc2VAMjEKCmlzX2dhbWVfb3Zlcl9lbHNlX2JvZHlAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMyNgogICAgLy8gZmlyc3RfcHJpemVfc2hhcmUgPSBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlICogVUludDY0KDUwKSAvLyBVSW50NjQoMTAwKQogICAgZnJhbWVfZGlnIDExCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgICoKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMjgKICAgIC8vIGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgKiBVSW50NjQoMzApIC8vIFVJbnQ2NCgxMDApCiAgICBkaWcgMQogICAgcHVzaGludCAzMCAvLyAzMAogICAgKgogICAgcHVzaGludCAxMDAgLy8gMTAwCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMyNy0zMjkKICAgIC8vIHNlY29uZF9wcml6ZV9zaGFyZSA9ICgKICAgIC8vICAgICBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlICogVUludDY0KDMwKSAvLyBVSW50NjQoMTAwKQogICAgLy8gKQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMzMQogICAgLy8gZ2FtZV9zdGF0ZS5wcml6ZV9wb29sLm5hdGl2ZSAtIGZpcnN0X3ByaXplX3NoYXJlIC0gc2Vjb25kX3ByaXplX3NoYXJlCiAgICB1bmNvdmVyIDIKICAgIGRpZyAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjMzMC0zMzIKICAgIC8vIHRoaXJkX3ByaXplX3NoYXJlID0gKAogICAgLy8gICAgIGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgLSBmaXJzdF9wcml6ZV9zaGFyZSAtIHNlY29uZF9wcml6ZV9zaGFyZQogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMzEKICAgIC8vIGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgLSBmaXJzdF9wcml6ZV9zaGFyZSAtIHNlY29uZF9wcml6ZV9zaGFyZQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weTozMzAtMzMyCiAgICAvLyB0aGlyZF9wcml6ZV9zaGFyZSA9ICgKICAgIC8vICAgICBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlIC0gZmlyc3RfcHJpemVfc2hhcmUgLSBzZWNvbmRfcHJpemVfc2hhcmUKICAgIC8vICkKICAgIGZyYW1lX2J1cnkgMTQKICAgIGZyYW1lX2J1cnkgMTEKICAgIGIgaXNfZ2FtZV9vdmVyX2FmdGVyX2lmX2Vsc2VAMjEKCmlzX2dhbWVfb3Zlcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxMAogICAgYiBpc19nYW1lX292ZXJfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5jb250cmFjdC5QaWVvdXQuY2FsY19zaW5nbGVfYm94X2Nvc3Qoa2V5X3NpemU6IGJ5dGVzLCB2YWx1ZV9zaXplOiBieXRlcykgLT4gdWludDY0OgpjYWxjX3NpbmdsZV9ib3hfY29zdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDQtNDgKICAgIC8vICMgUkVBRC1PTkxZOiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYmFsYW5jZSByZXF1aXJlbWVudCAoTUJSKSBjb3N0IGZvciBzdG9yaW5nIGEgc2luZ2xlIGJveCB1bml0CiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBjYWxjX3NpbmdsZV9ib3hfY29zdCgKICAgIC8vICAgICBzZWxmLCBrZXlfc2l6ZTogYXJjNC5VSW50OCwgdmFsdWVfc2l6ZTogYXJjNC5VSW50MTYKICAgIC8vICkgLT4gVUludDY0OgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUyCiAgICAvLyBrZXlfc2l6ZS5uYXRpdmUgKyB2YWx1ZV9zaXplLm5hdGl2ZQogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTEKICAgIC8vIHNpemVfY29zdCA9IGFyYzQuVUludDE2KDQwMCkubmF0aXZlICogKAogICAgcHVzaGludCA0MDAgLy8gNDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUxLTUzCiAgICAvLyBzaXplX2Nvc3QgPSBhcmM0LlVJbnQxNig0MDApLm5hdGl2ZSAqICgKICAgIC8vICAgICBrZXlfc2l6ZS5uYXRpdmUgKyB2YWx1ZV9zaXplLm5hdGl2ZQogICAgLy8gKSAgIyBTaXplIGZlZSAoNDAwIHBlciBieXRlICogKGxlbihrZXkpK2xlbih2YWx1ZSkpKQogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1NS01NgogICAgLy8gIyBSZXR1cm4gc2luZ2xlIGJveCB0b3RhbCBjb3N0IGFtb3VudAogICAgLy8gcmV0dXJuIGJhc2VfY29zdC5uYXRpdmUgKyBzaXplX2Nvc3QKICAgIHB1c2hpbnQgMjUwMCAvLyAyNTAwCiAgICArCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC5kb2VzX2JveF9nYW1lX3Ryb3BoeV9leGlzdCgpIC0+IHVpbnQ2NDoKZG9lc19ib3hfZ2FtZV90cm9waHlfZXhpc3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjY2CiAgICAvLyByZXR1cm4gc2VsZi5ib3hfZ2FtZV90cm9waHkubWF5YmUoKVsxXQogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBib3hfZ2V0CiAgICBidXJ5IDEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LmRvZXNfYm94X2dhbWVfcmVnaXN0ZXJfZXhpc3QocGxheWVyOiBieXRlcykgLT4gdWludDY0Ogpkb2VzX2JveF9nYW1lX3JlZ2lzdGVyX2V4aXN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2OC03MAogICAgLy8gIyBSRUFELU9OTFk6IFJldHVybiBUcnVlIGlmIGdhbWUgcmVnaXN0ZXIgYm94IGRhdGEgZXhpc3RzLCBlbHNlIEZhbHNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBkb2VzX2JveF9nYW1lX3JlZ2lzdGVyX2V4aXN0KHNlbGYsIHBsYXllcjogQWNjb3VudCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3MQogICAgLy8gcmV0dXJuIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIubWF5YmUoa2V5PXBsYXllcilbMV0KICAgIGJ5dGVjXzAgLy8gInJfIgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGJ1cnkgMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5jb250cmFjdC5QaWVvdXQuZG9lc19ib3hfZ2FtZV9zdGF0ZV9leGlzdChnYW1lX2lkOiB1aW50NjQpIC0+IHVpbnQ2NDoKZG9lc19ib3hfZ2FtZV9zdGF0ZV9leGlzdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzMtNzUKICAgIC8vICMgUkVBRC1PTkxZOiBSZXR1cm4gVHJ1ZSBpZiBnYW1lIHN0YXRlIGJveCBkYXRhIGV4aXN0cywgZWxzZSBGYWxzZQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgZG9lc19ib3hfZ2FtZV9zdGF0ZV9leGlzdChzZWxmLCBnYW1lX2lkOiBVSW50NjQpIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzYKICAgIC8vIHJldHVybiBzZWxmLmJveF9nYW1lX3N0YXRlLm1heWJlKGtleT1nYW1lX2lkKVsxXQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBieXRlYyA0IC8vICJzXyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYnVyeSAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC5yZWFkX2JveF9nYW1lX3BsYXllcnMoZ2FtZV9pZDogdWludDY0KSAtPiBieXRlczoKcmVhZF9ib3hfZ2FtZV9wbGF5ZXJzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3OC04MAogICAgLy8gIyBSRUFELU9OTFk6IFJldHVybiBhbiBhcnJheSBvZiBhbGwgYWN0aXZlIHBsYXllcnMgYXQgdGltZSBvZiBjYWxsCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiByZWFkX2JveF9nYW1lX3BsYXllcnMoc2VsZiwgZ2FtZV9pZDogVUludDY0KSAtPiB0YS5HYW1lUGxheWVyc0FycjoKICAgIHByb3RvIDEgMQogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MS04MgogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgZ2FtZV9pZCBpbiBzZWxmLmJveF9nYW1lX3N0YXRlLCBlcnIuR0FNRV9JRF9OT1RfRk9VTkQKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAic18iCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggZ2FtZSBzdGF0ZSBub3QgZm91bmQuIENoZWNrIGlmIGdhbWUgSUQgZXhpc3RzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NC04NQogICAgLy8gIyBSZXRyaWV2ZSBieXRlIGFycmF5IG9mIGN1cnJlbnQgcGxheWVyIGFkZHJlc3NlcyBmcm9tIHRoZSBib3ggdXNpbmcgdGhlIGdhbWUgaWQgcGFyYW1ldGVyCiAgICAvLyBwbGF5ZXJzX2JfYXJyID0gc2VsZi5ib3hfZ2FtZV9wbGF5ZXJzW2dhbWVfaWRdCiAgICBieXRlY18zIC8vICJwXyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3BsYXllcnMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg3LTg4CiAgICAvLyAjIERlZmluZSBhIGR5bmFtaWMgYXJyYXkgdG8gYXBwZW5kIGFsbCByZW1haW5pbmcgYWN0aXZlIHBsYXllcnMKICAgIC8vIGFjdGl2ZV9wbGF5ZXJzID0gdGEuR2FtZVBsYXllcnNBcnIoKQogICAgcHVzaGJ5dGVzIDB4MDAwMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo5MC05MQogICAgLy8gIyBJdGVyYXRlIHRocm91Z2ggdGhlIHBsYXllcnMgYnl0ZSBhcnJheQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDAsIHBsYXllcnNfYl9hcnIubGVuZ3RoLCBjc3QuQUREUkVTU19TSVpFKToKICAgIGxlbgogICAgaW50Y18wIC8vIDAKCnJlYWRfYm94X2dhbWVfcGxheWVyc19mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjkwLTkxCiAgICAvLyAjIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGxheWVycyBieXRlIGFycmF5CiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMCwgcGxheWVyc19iX2Fyci5sZW5ndGgsIGNzdC5BRERSRVNTX1NJWkUpOgogICAgZnJhbWVfZGlnIDUKICAgIGZyYW1lX2RpZyA0CiAgICA8CiAgICBieiByZWFkX2JveF9nYW1lX3BsYXllcnNfYWZ0ZXJfZm9yQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6OTItOTMKICAgIC8vICMgRXh0cmFjdCB0aGUgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBwbGF5ZXIgYWRkcmVzcwogICAgLy8gcGxheWVyX2FkZHJfYnl0ZXMgPSBvcC5leHRyYWN0KHBsYXllcnNfYl9hcnIsIGksIGNzdC5BRERSRVNTX1NJWkUpCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDUKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdDMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojk0LTk1CiAgICAvLyAjIE9ubHkgYXBwZW5kIGFkZHJlc3MgaWYgaXRzIGJ5dGVzIGRvIE5PVCBlcXVhbCB0byBhIHplcm9lZCBieXRlIGFycmF5IG9mIHNpemUgMzIKICAgIC8vIGlmIHBsYXllcl9hZGRyX2J5dGVzICE9IEJ5dGVzKGNzdC5aRVJPX0FERFJfQllURVMpOgogICAgYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgICE9CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSAwCiAgICBieiByZWFkX2JveF9nYW1lX3BsYXllcnNfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojk3CiAgICAvLyBhY3RpdmVfcGxheWVycy5hcHBlbmQoYXJjNC5BZGRyZXNzKHBsYXllcl9hY2NvdW50KSkKICAgIGZyYW1lX2RpZyAzCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyAzMgogICAgLwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCgpyZWFkX2JveF9nYW1lX3BsYXllcnNfYWZ0ZXJfaWZfZWxzZUA0OgogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo5MC05MQogICAgLy8gIyBJdGVyYXRlIHRocm91Z2ggdGhlIHBsYXllcnMgYnl0ZSBhcnJheQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDAsIHBsYXllcnNfYl9hcnIubGVuZ3RoLCBjc3QuQUREUkVTU19TSVpFKToKICAgIGZyYW1lX2RpZyA1CiAgICBpbnRjXzMgLy8gMzIKICAgICsKICAgIGZyYW1lX2J1cnkgNQogICAgYiByZWFkX2JveF9nYW1lX3BsYXllcnNfZm9yX2hlYWRlckAxCgpyZWFkX2JveF9nYW1lX3BsYXllcnNfYWZ0ZXJfZm9yQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojk5LTEwMAogICAgLy8gIyBSZXR1cm4gdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIHJlbWFpbmluZyBhY3RpdmUgcGxheWVycwogICAgLy8gcmV0dXJuIGFjdGl2ZV9wbGF5ZXJzCiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC5nZW5lcmF0ZSgpIC0+IHZvaWQ6CmdlbmVyYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxMDctMTA4CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIGVyci5JTlZBTElEX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBBY2NvdW50IG11c3QgbWF0Y2ggYXBwbGljYXRpb24gY3JlYXRvciBhZGRyZXNzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxMTAtMTExCiAgICAvLyAjIFNldCBHbG9iYWwgU3RhdGUgdmFyaWFibGVzIHRvIHRoZWlyIGRlZmF1bHQgc3RhcnRpbmcgdmFsdWVzCiAgICAvLyBzZWxmLmdhbWVfaWQgPSBVSW50NjQoMSkKICAgIGJ5dGVjIDggLy8gImdhbWVfaWQiCiAgICBpbnRjXzEgLy8gMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0Lm1pbnRfdHJvcGh5KGJveF90X3BheTogdWludDY0LCBtaW50X3BheTogdWludDY0KSAtPiB2b2lkOgptaW50X3Ryb3BoeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTEzLTExOQogICAgLy8gIyBBbGxvdyBhcHAgY3JlYXRvciB0byBtaW50IGEgb25lLXRpbWUgTkZUIGFzc2V0IHVzZWQgYXMgYSB0cm9waHkgdG9rZW4gdG8gaG9ub3IgdGhlIGF0aCBhZGRyZXNzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBtaW50X3Ryb3BoeSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGJveF90X3BheTogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWludF9wYXk6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjEyMC0xMjEKICAgIC8vICMgRmFpbCB0cmFuc2FjdGlvbiB1bmxlc3MgdGhlIGFzc2VydGlvbiBiZWxvdyBldmFsdWF0ZXMgVHJ1ZQogICAgLy8gYXNzZXJ0IEdsb2JhbC5ncm91cF9zaXplID09IDMsIGVyci5JTlZBTElEX0dST1VQX1NJWkUKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIHB1c2hpbnQgMyAvLyAzCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZ3JvdXAgc2l6ZS4gRW5zdXJlIG51bWJlciBvZiB0cmFuc2FjdGlvbiBpbiBncm91cCBpcyB3aXRoaW4gdmFsaWQgYm91bmRzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxMjIKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5ib3hfZ2FtZV90cm9waHksIGVyci5CT1hfRk9VTkQKICAgIGJ5dGVjXzIgLy8gInRfIgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAhCiAgICBhc3NlcnQgLy8gQm94IGZvdW5kLiBFbnN1cmUgdGhlIGJveCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3MgZG9lcyBub3QgZXhpc3QgYWxyZWFkeS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTI0CiAgICAvLyBhc3NlcnQgYm94X3RfcGF5LmFtb3VudCA+PSBjc3QuQk9YX1RfQ09TVCwgZXJyLklOVkFMSURfQk9YX1BBWV9GRUUKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgQW1vdW50CiAgICBwdXNoaW50IDE5NzAwIC8vIDE5NzAwCiAgICA+PQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBmdW5kcy4gQm94IHBheSBhbW91bnQgaXMgbm90IGVub3VnaCB0byBjb3ZlciBhcHBsaWNhdGlvbiBNQlIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjEyNQogICAgLy8gYXNzZXJ0IGJveF90X3BheS5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgZXJyLklOVkFMSURfQk9YX1BBWV9TRU5ERVIKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQm94IHBheW1lbnQgc2VuZGVyIGFkZHJlc3MgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIgYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTI3CiAgICAvLyBib3hfdF9wYXkucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjEyNi0xMjgKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgYm94X3RfcGF5LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksIGVyci5JTlZBTElEX0JPWF9QQVlfUkVDRUlWRVIKICAgIGFzc2VydCAvLyBCb3ggcGF5bWVudCByZWNlaXZlciBhZGRyZXNzIG11c3QgbWF0Y2ggYXBwbGljYXRpb24gYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTMxCiAgICAvLyBtaW50X3BheS5hbW91bnQgPj0gR2xvYmFsLmFzc2V0X2NyZWF0ZV9taW5fYmFsYW5jZQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGdsb2JhbCBBc3NldENyZWF0ZU1pbkJhbGFuY2UKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjEzMC0xMzIKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWludF9wYXkuYW1vdW50ID49IEdsb2JhbC5hc3NldF9jcmVhdGVfbWluX2JhbGFuY2UKICAgIC8vICksIGVyci5JTlZBTElEX01JTlRfUEFZX0ZFRQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBmdW5kcy4gTWludCBwYXkgYW1vdW50IGlzIG5vdCBlbm91Z2ggdG8gY292ZXIgYXNzZXQgY3JlYXRpb24gY29zdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTMzCiAgICAvLyBhc3NlcnQgbWludF9wYXkuc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIGVyci5JTlZBTElEX01JTlRfUEFZX1NFTkRFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBNaW50IHBheW1lbnQgc2VuZGVyIGFkZHJlc3MgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIgYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTM1CiAgICAvLyBtaW50X3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTM0LTEzNgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBtaW50X3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCBlcnIuSU5WQUxJRF9NSU5UX1BBWV9SRUNFSVZFUgogICAgYXNzZXJ0IC8vIE1pbnQgcGF5bWVudCByZWNlaXZlciBhZGRyZXNzIG11c3QgbWF0Y2ggYXBwbGljYXRpb24gYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTM4LTE1MAogICAgLy8gIyBNaW50IGEgbmV3IHVuaXF1ZSBhc3NldCByZXByZXNlbnRpbmcgdGhlIGdhbWUgdHJvcGh5IGJ5IG1ha2luZyBhbiBhc3NldCBjb25maWcgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vIGFjZmdfaXR4biA9IGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgdG90YWw9MSwKICAgIC8vICAgICB1bml0X25hbWU9IlRSRlkiLAogICAgLy8gICAgIGFzc2V0X25hbWU9IlBpZW91dF9Ucm9waHkiLAogICAgLy8gICAgIGRlY2ltYWxzPTAsCiAgICAvLyAgICAgZGVmYXVsdF9mcm96ZW49RmFsc2UsCiAgICAvLyAgICAgbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlc2VydmU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBjbGF3YmFjaz1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIG5vdGU9YidwaWVvdXQ6ansibWV0aG9kIjoibWludF90cm9waHkiLCJjb25jZXJuIjoiaXR4bi5hc3NldF9jb25maWc7Y3JlYXRlX3Ryb3BoeV9hc3NldCJ9JywKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTQ1CiAgICAvLyBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNDYtMTQ4CiAgICAvLyByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBkdXBuIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTQ5CiAgICAvLyBub3RlPWIncGllb3V0Omp7Im1ldGhvZCI6Im1pbnRfdHJvcGh5IiwiY29uY2VybiI6Iml0eG4uYXNzZXRfY29uZmlnO2NyZWF0ZV90cm9waHlfYXNzZXQifScsCiAgICBwdXNoYnl0ZXMgMHg3MDY5NjU2Zjc1NzQzYTZhN2IyMjZkNjU3NDY4NmY2NDIyM2EyMjZkNjk2ZTc0NWY3NDcyNmY3MDY4NzkyMjJjMjI2MzZmNmU2MzY1NzI2ZTIyM2EyMjY5NzQ3ODZlMmU2MTczNzM2NTc0NWY2MzZmNmU2NjY5NjczYjYzNzI2NTYxNzQ2NTVmNzQ3MjZmNzA2ODc5NWY2MTczNzM2NTc0MjI3ZAogICAgaXR4bl9maWVsZCBOb3RlCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0Q2xhd2JhY2sKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRGcmVlemUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNDQKICAgIC8vIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXREZWZhdWx0RnJvemVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE0MwogICAgLy8gZGVjaW1hbHM9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTQyCiAgICAvLyBhc3NldF9uYW1lPSJQaWVvdXRfVHJvcGh5IiwKICAgIHB1c2hieXRlcyAiUGllb3V0X1Ryb3BoeSIKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE0MQogICAgLy8gdW5pdF9uYW1lPSJUUkZZIiwKICAgIHB1c2hieXRlcyAiVFJGWSIKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRVbml0TmFtZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNDAKICAgIC8vIHRvdGFsPTEsCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjEzOC0xMzkKICAgIC8vICMgTWludCBhIG5ldyB1bmlxdWUgYXNzZXQgcmVwcmVzZW50aW5nIHRoZSBnYW1lIHRyb3BoeSBieSBtYWtpbmcgYW4gYXNzZXQgY29uZmlnIGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyBhY2ZnX2l0eG4gPSBpdHhuLkFzc2V0Q29uZmlnKAogICAgcHVzaGludCAzIC8vIGFjZmcKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxMzgtMTUwCiAgICAvLyAjIE1pbnQgYSBuZXcgdW5pcXVlIGFzc2V0IHJlcHJlc2VudGluZyB0aGUgZ2FtZSB0cm9waHkgYnkgbWFraW5nIGFuIGFzc2V0IGNvbmZpZyBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gYWNmZ19pdHhuID0gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICB0b3RhbD0xLAogICAgLy8gICAgIHVuaXRfbmFtZT0iVFJGWSIsCiAgICAvLyAgICAgYXNzZXRfbmFtZT0iUGllb3V0X1Ryb3BoeSIsCiAgICAvLyAgICAgZGVjaW1hbHM9MCwKICAgIC8vICAgICBkZWZhdWx0X2Zyb3plbj1GYWxzZSwKICAgIC8vICAgICBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGZyZWV6ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgbm90ZT1iJ3BpZW91dDpqeyJtZXRob2QiOiJtaW50X3Ryb3BoeSIsImNvbmNlcm4iOiJpdHhuLmFzc2V0X2NvbmZpZztjcmVhdGVfdHJvcGh5X2Fzc2V0In0nLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gQ3JlYXRlZEFzc2V0SUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTUyLTE1MwogICAgLy8gIyBDcmVhdGUgdGhlIGdhbWUgdHJvcGh5IGJveCBhbmQgYXNzaWduIGl0cyBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV90cm9waHkuY3JlYXRlKCkKICAgIGJ5dGVjXzIgLy8gInRfIgogICAgcHVzaGludCA0MSAvLyA0MQogICAgYm94X2NyZWF0ZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE1NQogICAgLy8gYXNzZXRfaWQ9YXJjNC5VSW50NjQoYWNmZ19pdHhuLmNyZWF0ZWRfYXNzZXQuaWQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNTcKICAgIC8vIGF0aF9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNTQtMTU4CiAgICAvLyBzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZSA9IHN0Yy5HYW1lVHJvcGh5KAogICAgLy8gICAgIGFzc2V0X2lkPWFyYzQuVUludDY0KGFjZmdfaXR4bi5jcmVhdGVkX2Fzc2V0LmlkKSwKICAgIC8vICAgICBhdGhfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBhdGhfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyApCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE1NgogICAgLy8gYXRoX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICBieXRlY18xIC8vIDB4MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTU0LTE1OAogICAgLy8gc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUgPSBzdGMuR2FtZVRyb3BoeSgKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhY2ZnX2l0eG4uY3JlYXRlZF9hc3NldC5pZCksCiAgICAvLyAgICAgYXRoX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgYXRoX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gKQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTU0CiAgICAvLyBzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZSA9IHN0Yy5HYW1lVHJvcGh5KAogICAgYnl0ZWNfMiAvLyAidF8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE1NC0xNTgKICAgIC8vIHNlbGYuYm94X2dhbWVfdHJvcGh5LnZhbHVlID0gc3RjLkdhbWVUcm9waHkoCiAgICAvLyAgICAgYXNzZXRfaWQ9YXJjNC5VSW50NjQoYWNmZ19pdHhuLmNyZWF0ZWRfYXNzZXQuaWQpLAogICAgLy8gICAgIGF0aF9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIGF0aF9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LmNsYWltX3Ryb3BoeSgpIC0+IHZvaWQ6CmNsYWltX3Ryb3BoeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTYzLTE2NAogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgR2xvYmFsLmdyb3VwX3NpemUgPT0gMSwgZXJyLlNUQU5EQUxPTkVfVFhOX09OTFkKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZ3JvdXAgc2l6ZS4gVGhpcyBhcHAgY2FsbCBjYW4gb25seSB0YWtlIHN0YW5kYWxvbmUgdHJhbnNhY3Rpb25zLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNjYKICAgIC8vIFR4bi5zZW5kZXIgPT0gc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXRoX2FkZHJlc3MubmF0aXZlCiAgICB0eG4gU2VuZGVyCiAgICBieXRlY18yIC8vICJ0XyIKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3Ryb3BoeSBleGlzdHMKICAgIGR1cAogICAgZXh0cmFjdCA5IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgdW5jb3ZlciAyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNjUtMTY3CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT0gc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXRoX2FkZHJlc3MubmF0aXZlCiAgICAvLyApLCBlcnIuSU5WQUxJRF9UUk9QSFlfUkVDRUlWRVIKICAgIGFzc2VydCAvLyBBc3NldCB0cm9waHkgcmVjZWl2ZXIgbXVzdCBtYXRjaCBhcHBsaWNhdGlvbiBBVEggYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTY4CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlci5pc19vcHRlZF9pbigKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTY5CiAgICAvLyBBc3NldChzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZS5hc3NldF9pZC5uYXRpdmUpCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTY4LTE3MAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIuaXNfb3B0ZWRfaW4oCiAgICAvLyAgICAgQXNzZXQoc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXNzZXRfaWQubmF0aXZlKQogICAgLy8gKSwgZXJyLkFTU0VUX09QVF9JTl9SRVFVSVJFRAogICAgc3dhcAogICAgZGlnIDEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQWNjb3VudCBtdXN0IGJlIG9wdGVkIGluIHRvIGFzc2V0IGluIG9yZGVyIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE3Mi0xNzgKICAgIC8vICMgVHJhbnNmZXIgZ2FtZSB0cm9waHkgYXNzZXQgdG8gc2VuZGVyIGJ5IG1ha2luZyBhbiBhc3NldCB0cmFuc2ZlciBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9c2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXNzZXRfaWQubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTEsCiAgICAvLyAgICAgbm90ZT1iJ3BpZW91dDpqeyJtZXRob2QiOiJjbGFpbV90cm9waHkiLCJjb25jZXJuIjoiaXR4bi5hc3NldF90cmFuc2Zlcjt0cmFuc2Zlcl90cm9waHlfYXNzZXQifScsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE3NQogICAgLy8gYXNzZXRfcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTc3CiAgICAvLyBub3RlPWIncGllb3V0Omp7Im1ldGhvZCI6ImNsYWltX3Ryb3BoeSIsImNvbmNlcm4iOiJpdHhuLmFzc2V0X3RyYW5zZmVyO3RyYW5zZmVyX3Ryb3BoeV9hc3NldCJ9JywKICAgIHB1c2hieXRlcyAweDcwNjk2NTZmNzU3NDNhNmE3YjIyNmQ2NTc0Njg2ZjY0MjIzYTIyNjM2YzYxNjk2ZDVmNzQ3MjZmNzA2ODc5MjIyYzIyNjM2ZjZlNjM2NTcyNmUyMjNhMjI2OTc0Nzg2ZTJlNjE3MzczNjU3NDVmNzQ3MjYxNmU3MzY2NjU3MjNiNzQ3MjYxNmU3MzY2NjU3MjVmNzQ3MjZmNzA2ODc5NWY2MTczNzM2NTc0MjI3ZAogICAgaXR4bl9maWVsZCBOb3RlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE3NgogICAgLy8gYXNzZXRfYW1vdW50PTEsCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxNzItMTczCiAgICAvLyAjIFRyYW5zZmVyIGdhbWUgdHJvcGh5IGFzc2V0IHRvIHNlbmRlciBieSBtYWtpbmcgYW4gYXNzZXQgdHJhbnNmZXIgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE3Mi0xNzgKICAgIC8vICMgVHJhbnNmZXIgZ2FtZSB0cm9waHkgYXNzZXQgdG8gc2VuZGVyIGJ5IG1ha2luZyBhbiBhc3NldCB0cmFuc2ZlciBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9c2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXNzZXRfaWQubmF0aXZlLAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTEsCiAgICAvLyAgICAgbm90ZT1iJ3BpZW91dDpqeyJtZXRob2QiOiJjbGFpbV90cm9waHkiLCJjb25jZXJuIjoiaXR4bi5hc3NldF90cmFuc2Zlcjt0cmFuc2Zlcl90cm9waHlfYXNzZXQifScsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5jb250cmFjdC5QaWVvdXQuZ2V0X2JveF9nYW1lX3JlZ2lzdGVyKGJveF9yX3BheTogdWludDY0KSAtPiB2b2lkOgpnZXRfYm94X2dhbWVfcmVnaXN0ZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE4MC0xODIKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSByZWdpc3RlciBib3ggdGhhdCBpcyBhIHByZXJlcXVpc3RlIHRvIGludGVyYWN0IHdpdGggZ2FtZS1yZWxhdGVkIGZlYXR1cmVzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBnZXRfYm94X2dhbWVfcmVnaXN0ZXIoc2VsZiwgYm94X3JfcGF5OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbikgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxODMtMTg0CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAyLCBlcnIuSU5WQUxJRF9HUk9VUF9TSVpFCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBpbnRjXzIgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdyb3VwIHNpemUuIEVuc3VyZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW4gZ3JvdXAgaXMgd2l0aGluIHZhbGlkIGJvdW5kcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTg1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciBub3QgaW4gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwgZXJyLkJPWF9GT1VORAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgIQogICAgYXNzZXJ0IC8vIEJveCBmb3VuZC4gRW5zdXJlIHRoZSBib3ggeW91IGFyZSB0cnlpbmcgdG8gYWNjZXNzIGRvZXMgbm90IGV4aXN0IGFscmVhZHkuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE4NgogICAgLy8gYXNzZXJ0IHNlbGYuYm94X2dhbWVfdHJvcGh5LCBlcnIuQk9YX05PVF9GT1VORAogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggbm90IGZvdW5kLiBFbnN1cmUgdGhlIGJveCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3Mgd2FzIGNyZWF0ZWQgYW5kIHN0aWxsIGV4aXN0cy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTg4LTE4OQogICAgLy8gIyAtLSBCT1ggUiBQQVkgLS0KICAgIC8vIGFzc2VydCBib3hfcl9wYXkuYW1vdW50ID09IGNzdC5CT1hfUl9DT1NULCBlcnIuSU5WQUxJRF9CT1hfUEFZX0ZFRQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludGMgNyAvLyAyOTcwMAogICAgPT0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgZnVuZHMuIEJveCBwYXkgYW1vdW50IGlzIG5vdCBlbm91Z2ggdG8gY292ZXIgYXBwbGljYXRpb24gTUJSLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxOTAKICAgIC8vIGFzc2VydCBib3hfcl9wYXkuc2VuZGVyID09IFR4bi5zZW5kZXIsIGVyci5JTlZBTElEX0JPWF9QQVlfU0VOREVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIGFzc2VydCAvLyBCb3ggcGF5bWVudCBzZW5kZXIgYWRkcmVzcyBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlciBhZGRyZXNzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxOTIKICAgIC8vIGJveF9yX3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MTkxLTE5MwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBib3hfcl9wYXkucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLklOVkFMSURfQk9YX1BBWV9SRUNFSVZFUgogICAgYXNzZXJ0IC8vIEJveCBwYXltZW50IHJlY2VpdmVyIGFkZHJlc3MgbXVzdCBtYXRjaCBhcHBsaWNhdGlvbiBhZGRyZXNzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyMDEKICAgIC8vIGV4cGlyeV9yb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQgKyBjc3QuQk9YX1JfRVhQX1JPVU5EX0RFTFRBKSwKICAgIGdsb2JhbCBSb3VuZAogICAgaW50YyA2IC8vIDE1MDAwMAogICAgKwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToxOTUtMjAyCiAgICAvLyAjIENyZWF0ZSBhIGdhbWUgcmVnaXN0ZXIgYm94IHdpdGggc2VuZGVyIGFzIGtleSBhbmQgYXNzaWduIGl0cyBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlcltUeG4uc2VuZGVyXSA9IHN0Yy5HYW1lUmVnaXN0ZXIoCiAgICAvLyAgICAgaG9zdGluZ19nYW1lPWFyYzQuQm9vbChGYWxzZSksICAjIG5vcWE6IEZCVDAwMwogICAgLy8gICAgIGJlc3Rfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBnYW1lX2lkPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgIGNvbW1pdF9yYW5kX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgIGV4cGlyeV9yb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQgKyBjc3QuQk9YX1JfRVhQX1JPVU5EX0RFTFRBKSwKICAgIC8vICkKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE5NS0xOTYKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSByZWdpc3RlciBib3ggd2l0aCBzZW5kZXIgYXMga2V5IGFuZCBhc3NpZ24gaXRzIGRlZmF1bHQgc3RhcnRpbmcgdmFsdWVzCiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdID0gc3RjLkdhbWVSZWdpc3RlcigKICAgIGJ5dGVjXzAgLy8gInJfIgogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjE5NS0yMDIKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSByZWdpc3RlciBib3ggd2l0aCBzZW5kZXIgYXMga2V5IGFuZCBhc3NpZ24gaXRzIGRlZmF1bHQgc3RhcnRpbmcgdmFsdWVzCiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdID0gc3RjLkdhbWVSZWdpc3RlcigKICAgIC8vICAgICBob3N0aW5nX2dhbWU9YXJjNC5Cb29sKEZhbHNlKSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyAgICAgYmVzdF9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIGdhbWVfaWQ9YXJjNC5VSW50NjQoMCksCiAgICAvLyAgICAgY29tbWl0X3JhbmRfcm91bmQ9YXJjNC5VSW50NjQoMCksCiAgICAvLyAgICAgZXhwaXJ5X3JvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCArIGNzdC5CT1hfUl9FWFBfUk9VTkRfREVMVEEpLAogICAgLy8gKQogICAgc3dhcAogICAgYm94X3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5jb250cmFjdC5QaWVvdXQuZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9zZWxmKCkgLT4gdm9pZDoKZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9zZWxmOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyMDctMjA4CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAxLCBlcnIuU1RBTkRBTE9ORV9UWE5fT05MWQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBncm91cCBzaXplLiBUaGlzIGFwcCBjYWxsIGNhbiBvbmx5IHRha2Ugc3RhbmRhbG9uZSB0cmFuc2FjdGlvbnMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjIwOQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwgZXJyLkJPWF9OT1RfRk9VTkQKICAgIGJ5dGVjXzAgLy8gInJfIgogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggbm90IGZvdW5kLiBFbnN1cmUgdGhlIGJveCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3Mgd2FzIGNyZWF0ZWQgYW5kIHN0aWxsIGV4aXN0cy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjExCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbVHhuLnNlbmRlcl0uaG9zdGluZ19nYW1lLm5hdGl2ZSwgZXJyLkhPU1RJTkdfR0FNRV9GTEFHCiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIEdhbWUgcmVnaXN0ZXIgaG9zdGluZyBnYW1lIGJvb2xlYW4gdmFsdWUgbWlzbWF0Y2guCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjIxNAogICAgLy8gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlcltUeG4uc2VuZGVyXS5jb21taXRfcmFuZF9yb3VuZC5uYXRpdmUgPT0gMAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyIGVudHJ5IGV4aXN0cwogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgICEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjEzLTIxNQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdLmNvbW1pdF9yYW5kX3JvdW5kLm5hdGl2ZSA9PSAwCiAgICAvLyApLCBlcnIuTk9OX1pFUk9fQ09NTUlUX1JBTkRfUk9VTkQKICAgIGFzc2VydCAvLyBDb21taXQgUmFuZCBSb3VuZCBub3QgZW1wdHkuIFZhbHVlIG11c3QgYmUgemVybyB0byBvYnRhaW4gYSB2YWxpZCBvbmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjIxNy0yMTgKICAgIC8vICMgRGVsZXRlIGdhbWUgcmVnaXN0ZXIgYm94IGZyb20gdGhlIHNtYXJ0IGNvbnRyYWN0IHN0b3JhZ2UgdW5kZXIgc2VuZGVyIGtleQogICAgLy8gZGVsIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbVHhuLnNlbmRlcl0KICAgIGJ5dGVjXzAgLy8gInJfIgogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjIyCiAgICAvLyByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyMjMKICAgIC8vIGFtb3VudD1VSW50NjQoY3N0LkJPWF9SX0NPU1QpLAogICAgaW50YyA3IC8vIDI5NzAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjIyNC0yMjYKICAgIC8vIG5vdGU9U3RyaW5nKAogICAgLy8gICAgICdwaWVvdXQ6ansibWV0aG9kIjoiZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9zZWxmIiwiY29uY2VybiI6InR4bi5hcHBfYzttYnJfYm94X3JfcmVmdW5kIn0nCiAgICAvLyApLAogICAgcHVzaGJ5dGVzICJwaWVvdXQ6antcIm1ldGhvZFwiOlwiZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9zZWxmXCIsXCJjb25jZXJuXCI6XCJ0eG4uYXBwX2M7bWJyX2JveF9yX3JlZnVuZFwifSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjIwLTIyNwogICAgLy8gIyBJc3N1ZSBNQlIgcmVmdW5kIGZvciBnYW1lIHJlZ2lzdGVyIGJveCBkZWxldGlvbiB2aWEgYSBwYXltZW50IGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyBzcnQucGF5b3V0X2l0eG4oCiAgICAvLyAgICAgcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ9VUludDY0KGNzdC5CT1hfUl9DT1NUKSwKICAgIC8vICAgICBub3RlPVN0cmluZygKICAgIC8vICAgICAgICAgJ3BpZW91dDpqeyJtZXRob2QiOiJkZWxfYm94X2dhbWVfcmVnaXN0ZXJfZm9yX3NlbGYiLCJjb25jZXJuIjoidHhuLmFwcF9jO21icl9ib3hfcl9yZWZ1bmQifScKICAgIC8vICAgICApLAogICAgLy8gKQogICAgY2FsbHN1YiBwYXlvdXRfaXR4bgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5jb250cmFjdC5QaWVvdXQuZGVsX2JveF9nYW1lX3JlZ2lzdGVyX2Zvcl9vdGhlcihwbGF5ZXI6IGJ5dGVzKSAtPiB2b2lkOgpkZWxfYm94X2dhbWVfcmVnaXN0ZXJfZm9yX290aGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyMjktMjMxCiAgICAvLyAjIERlbGV0ZSB0aGUgZ2FtZSByZWdpc3RlciBib3ggZGF0YSBmb3IgYW5vdGhlciBhY2NvdW50CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBkZWxfYm94X2dhbWVfcmVnaXN0ZXJfZm9yX290aGVyKHNlbGYsIHBsYXllcjogQWNjb3VudCkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyMzItMjMzCiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAxLCBlcnIuU1RBTkRBTE9ORV9UWE5fT05MWQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBncm91cCBzaXplLiBUaGlzIGFwcCBjYWxsIGNhbiBvbmx5IHRha2Ugc3RhbmRhbG9uZSB0cmFuc2FjdGlvbnMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjIzNQogICAgLy8gYXNzZXJ0IHBsYXllciBpbiBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyLCBlcnIuQk9YX05PVF9GT1VORAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggbm90IGZvdW5kLiBFbnN1cmUgdGhlIGJveCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3Mgd2FzIGNyZWF0ZWQgYW5kIHN0aWxsIGV4aXN0cy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjM3CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbcGxheWVyXS5ob3N0aW5nX2dhbWUubmF0aXZlLCBlcnIuSE9TVElOR19HQU1FX0ZMQUcKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAhCiAgICBhc3NlcnQgLy8gR2FtZSByZWdpc3RlciBob3N0aW5nIGdhbWUgYm9vbGVhbiB2YWx1ZSBtaXNtYXRjaC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjQwCiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW3BsYXllcl0uY29tbWl0X3JhbmRfcm91bmQubmF0aXZlID09IDAKICAgIGR1cAogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgICEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjM5LTI0MQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW3BsYXllcl0uY29tbWl0X3JhbmRfcm91bmQubmF0aXZlID09IDAKICAgIC8vICksIGVyci5OT05fWkVST19DT01NSVRfUkFORF9ST1VORAogICAgYXNzZXJ0IC8vIENvbW1pdCBSYW5kIFJvdW5kIG5vdCBlbXB0eS4gVmFsdWUgbXVzdCBiZSB6ZXJvIHRvIG9idGFpbiBhIHZhbGlkIG9uZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjQ0CiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW3BsYXllcl0uZXhwaXJ5X3JvdW5kLm5hdGl2ZSA8IEdsb2JhbC5yb3VuZAogICAgcHVzaGludCAxOCAvLyAxOAogICAgZXh0cmFjdF91aW50NjQKICAgIGdsb2JhbCBSb3VuZAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyNDMtMjQ1CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbcGxheWVyXS5leHBpcnlfcm91bmQubmF0aXZlIDwgR2xvYmFsLnJvdW5kCiAgICAvLyApLCBlcnIuVElNRV9DT05TVFJBSU5UX1ZJT0xBVElPTgogICAgYXNzZXJ0IC8vIEludmFsaWQgdGltZSBmcmFtZS4gQ2FsbCBtYWRlIG91dHNpZGUgdGhlIHBlcm1pdHRlZCBibG9jayBvciB0aW1lc3RhbXAgcmFuZ2UuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI0OC0yNDkKICAgIC8vICMgRGVsZXRlIGdhbWUgcmVnaXN0ZXIgYm94IGZyb20gdGhlIHNtYXJ0IGNvbnRyYWN0IHN0b3JhZ2UgdW5kZXIgcGxheWVyIGtleQogICAgLy8gZGVsIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbcGxheWVyXQogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI1MS0yNTYKICAgIC8vICMgUmVzb2x2ZSBnYW1lIHJlZ2lzdGVyIGJveCBkZWxldGlvbiBNQlIgcmVmdW5kIHJlY2VpdmVyIGJ5IHByaW9yaXR5CiAgICAvLyByZWNlaXZlciA9IHNydC5yZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8oCiAgICAvLyAgICAgYWNjMT1wbGF5ZXIsCiAgICAvLyAgICAgYWNjMj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGFjYzM9R2xvYmFsLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyNTQKICAgIC8vIGFjYzI9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjU1CiAgICAvLyBhY2MzPUdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjUxLTI1NgogICAgLy8gIyBSZXNvbHZlIGdhbWUgcmVnaXN0ZXIgYm94IGRlbGV0aW9uIE1CUiByZWZ1bmQgcmVjZWl2ZXIgYnkgcHJpb3JpdHkKICAgIC8vIHJlY2VpdmVyID0gc3J0LnJlc29sdmVfcmVjZWl2ZXJfYnlfcHJpbygKICAgIC8vICAgICBhY2MxPXBsYXllciwKICAgIC8vICAgICBhY2MyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYWNjMz1HbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gKQogICAgY2FsbHN1YiByZXNvbHZlX3JlY2VpdmVyX2J5X3ByaW8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjYxCiAgICAvLyBhbW91bnQ9VUludDY0KGNzdC5CT1hfUl9DT1NUKSwKICAgIGludGMgNyAvLyAyOTcwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyNjItMjY0CiAgICAvLyBub3RlPVN0cmluZygKICAgIC8vICAgICAncGllb3V0Omp7Im1ldGhvZCI6ImRlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfb3RoZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7bWJyX2JveF9jX3JlZnVuZCJ9JwogICAgLy8gKSwKICAgIHB1c2hieXRlcyAicGllb3V0Omp7XCJtZXRob2RcIjpcImRlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfb3RoZXJcIixcImNvbmNlcm5cIjpcIml0eG4ucGF5O21icl9ib3hfY19yZWZ1bmRcIn0iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI1OC0yNjUKICAgIC8vICMgSXNzdWUgTUJSIHJlZnVuZCBmb3IgZ2FtZSByZWdpc3RlciBib3ggZGVsZXRpb24gdmlhIGEgcGF5bWVudCBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gc3J0LnBheW91dF9pdHhuKAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudD1VSW50NjQoY3N0LkJPWF9SX0NPU1QpLAogICAgLy8gICAgIG5vdGU9U3RyaW5nKAogICAgLy8gICAgICAgICAncGllb3V0Omp7Im1ldGhvZCI6ImRlbF9ib3hfZ2FtZV9yZWdpc3Rlcl9mb3Jfb3RoZXIiLCJjb25jZXJuIjoiaXR4bi5wYXk7bWJyX2JveF9jX3JlZnVuZCJ9JwogICAgLy8gICAgICksCiAgICAvLyApCiAgICBjYWxsc3ViIHBheW91dF9pdHhuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC5uZXdfZ2FtZShxdWlja19wbGF5X2VuYWJsZWQ6IHVpbnQ2NCwgbWF4X3BsYXllcnM6IHVpbnQ2NCwgYm94X3NfcGF5OiB1aW50NjQsIGJveF9wX3BheTogdWludDY0LCBzdGFrZV9wYXk6IHVpbnQ2NCkgLT4gdm9pZDoKbmV3X2dhbWU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI2Ny0yNzYKICAgIC8vICMgQ3JlYXRlIG5ldyBnYW1lIGluc3RhbmNlIHdpdGggdW5pcXVlIElECiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBuZXdfZ2FtZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHF1aWNrX3BsYXlfZW5hYmxlZDogYm9vbCwgICMgbm9xYTogRkJUMDAxCiAgICAvLyAgICAgbWF4X3BsYXllcnM6IFVJbnQ2NCwKICAgIC8vICAgICBib3hfc19wYXk6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIGJveF9wX3BheTogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyAgICAgc3Rha2VfcGF5OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDUgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyNzctMjc4CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSA0LCBlcnIuSU5WQUxJRF9HUk9VUF9TSVpFCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBwdXNoaW50IDQgLy8gNAogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdyb3VwIHNpemUuIEVuc3VyZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW4gZ3JvdXAgaXMgd2l0aGluIHZhbGlkIGJvdW5kcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mjc5CiAgICAvLyBhc3NlcnQgc2VsZi5ib3hfZ2FtZV90cm9waHksIGVyci5CT1hfTk9UX0ZPVU5ECiAgICBieXRlY18yIC8vICJ0XyIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBub3QgZm91bmQuIEVuc3VyZSB0aGUgYm94IHlvdSBhcmUgdHJ5aW5nIHRvIGFjY2VzcyB3YXMgY3JlYXRlZCBhbmQgc3RpbGwgZXhpc3RzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyODAKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsIGVyci5CT1hfTk9UX0ZPVU5ECiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQm94IG5vdCBmb3VuZC4gRW5zdXJlIHRoZSBib3ggeW91IGFyZSB0cnlpbmcgdG8gYWNjZXNzIHdhcyBjcmVhdGVkIGFuZCBzdGlsbCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI4MgogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyWwogICAgYnl0ZWNfMCAvLyAicl8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI4MwogICAgLy8gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyODItMjg0CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbCiAgICAvLyAgICAgVHhuLnNlbmRlcgogICAgLy8gXS5ob3N0aW5nX2dhbWUubmF0aXZlLCBlcnIuSE9TVElOR19HQU1FX0ZMQUcKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIEdhbWUgcmVnaXN0ZXIgaG9zdGluZyBnYW1lIGJvb2xlYW4gdmFsdWUgbWlzbWF0Y2guCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI4NwogICAgLy8gbWF4X3BsYXllcnMgPj0gY3N0Lk1BWF9QTEFZRVJTX0JPVF9CT1VORAogICAgZnJhbWVfZGlnIC00CiAgICBwdXNoaW50IDMgLy8gMwogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mjg3LTI4OAogICAgLy8gbWF4X3BsYXllcnMgPj0gY3N0Lk1BWF9QTEFZRVJTX0JPVF9CT1VORAogICAgLy8gYW5kIG1heF9wbGF5ZXJzIDw9IGNzdC5NQVhfUExBWUVSU19UT1BfQk9VTkQKICAgIGJ6IG5ld19nYW1lX2Jvb2xfZmFsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyODgKICAgIC8vIGFuZCBtYXhfcGxheWVycyA8PSBjc3QuTUFYX1BMQVlFUlNfVE9QX0JPVU5ECiAgICBmcmFtZV9kaWcgLTQKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI4Ny0yODgKICAgIC8vIG1heF9wbGF5ZXJzID49IGNzdC5NQVhfUExBWUVSU19CT1RfQk9VTkQKICAgIC8vIGFuZCBtYXhfcGxheWVycyA8PSBjc3QuTUFYX1BMQVlFUlNfVE9QX0JPVU5ECiAgICBieiBuZXdfZ2FtZV9ib29sX2ZhbHNlQDMKICAgIGludGNfMSAvLyAxCgpuZXdfZ2FtZV9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI4Ni0yODkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWF4X3BsYXllcnMgPj0gY3N0Lk1BWF9QTEFZRVJTX0JPVF9CT1VORAogICAgLy8gICAgIGFuZCBtYXhfcGxheWVycyA8PSBjc3QuTUFYX1BMQVlFUlNfVE9QX0JPVU5ECiAgICAvLyApLCBlcnIuSU5WQUxJRF9NQVhfUExBWUVSUwogICAgYXNzZXJ0IC8vIFRoZSBudW1iZXIgb2YgbWF4IHBsYXllcnMgbXVzdCBiZSB3aXRoaW4gYm91bmRzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyOTEKICAgIC8vIGFzc2VydCBzdGFrZV9wYXkuYW1vdW50ID09IGNzdC5TVEFLRV9BTU9VTlQsIGVyci5JTlZBTElEX1NUQUtFX1BBWV9GRUUKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGludGMgNCAvLyAxMDAwMDAwCiAgICA9PQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBmdW5kcy4gU3Rha2UgcGF5IGFtb3VudCBpcyBub3QgZW5vdWdoIHRvIGNvdmVyIHN0YWtpbmcgcmVxdWlyZW1lbnRzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyOTIKICAgIC8vIGFzc2VydCBib3hfc19wYXkuYW1vdW50ID09IGNzdC5CT1hfU19DT1NULCBlcnIuSU5WQUxJRF9CT1hfUEFZX0ZFRQogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBBbW91bnQKICAgIGludGMgMTEgLy8gODA1MDAKICAgID09CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IGZ1bmRzLiBCb3ggcGF5IGFtb3VudCBpcyBub3QgZW5vdWdoIHRvIGNvdmVyIGFwcGxpY2F0aW9uIE1CUi4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MjkzCiAgICAvLyBhc3NlcnQgYm94X3BfcGF5LmFtb3VudCA9PSBzZWxmLmNhbGNfc2luZ2xlX2JveF9jb3N0KAogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mjk1CiAgICAvLyB2YWx1ZV9zaXplPWFyYzQuVUludDE2KGNzdC5BRERSRVNTX1NJWkUgKiBtYXhfcGxheWVycyksCiAgICBpbnRjXzMgLy8gMzIKICAgIGZyYW1lX2RpZyAtNAogICAgKgogICAgZHVwCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA2IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mjk0CiAgICAvLyBrZXlfc2l6ZT1hcmM0LlVJbnQ4KDEwKSwKICAgIHB1c2hieXRlcyAweDBhCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjI5My0yOTYKICAgIC8vIGFzc2VydCBib3hfcF9wYXkuYW1vdW50ID09IHNlbGYuY2FsY19zaW5nbGVfYm94X2Nvc3QoCiAgICAvLyAgICAga2V5X3NpemU9YXJjNC5VSW50OCgxMCksCiAgICAvLyAgICAgdmFsdWVfc2l6ZT1hcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFICogbWF4X3BsYXllcnMpLAogICAgLy8gKSwgZXJyLklOVkFMSURfQk9YX1BBWV9GRUUKICAgIHN3YXAKICAgIGNhbGxzdWIgY2FsY19zaW5nbGVfYm94X2Nvc3QKICAgIHVuY292ZXIgMgogICAgPT0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgZnVuZHMuIEJveCBwYXkgYW1vdW50IGlzIG5vdCBlbm91Z2ggdG8gY292ZXIgYXBwbGljYXRpb24gTUJSLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weToyOTgKICAgIC8vIGFzc2VydCBzdGFrZV9wYXkuc2VuZGVyID09IFR4bi5zZW5kZXIsIGVyci5JTlZBTElEX1NUQUtFX1BBWV9TRU5ERVIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFN0YWtlIHBheW1lbnQgc2VuZGVyIGFkZHJlc3MgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIgYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mjk5CiAgICAvLyBhc3NlcnQgYm94X3NfcGF5LnNlbmRlciA9PSBUeG4uc2VuZGVyLCBlcnIuSU5WQUxJRF9CT1hfUEFZX1NFTkRFUgogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gQm94IHBheW1lbnQgc2VuZGVyIGFkZHJlc3MgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIgYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzAwCiAgICAvLyBhc3NlcnQgYm94X3BfcGF5LnNlbmRlciA9PSBUeG4uc2VuZGVyLCBlcnIuSU5WQUxJRF9CT1hfUEFZX1NFTkRFUgogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gQm94IHBheW1lbnQgc2VuZGVyIGFkZHJlc3MgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIgYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzAzCiAgICAvLyBzdGFrZV9wYXkucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMwMi0zMDQKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc3Rha2VfcGF5LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICksIGVyci5JTlZBTElEX1NUQUtFX1BBWV9SRUNFSVZFUgogICAgYXNzZXJ0IC8vIFN0YWtlIHBheW1lbnQgcmVjZWl2ZXIgYWRkcmVzcyBtdXN0IG1hdGNoIGFwcGxpY2F0aW9uIGFkZHJlc3MuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMwNgogICAgLy8gYm94X3NfcGF5LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMDUtMzA3CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGJveF9zX3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCBlcnIuSU5WQUxJRF9CT1hfUEFZX1JFQ0VJVkVSCiAgICBhc3NlcnQgLy8gQm94IHBheW1lbnQgcmVjZWl2ZXIgYWRkcmVzcyBtdXN0IG1hdGNoIGFwcGxpY2F0aW9uIGFkZHJlc3MuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMwOQogICAgLy8gYm94X3BfcGF5LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMDgtMzEwCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIGJveF9wX3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLCBlcnIuSU5WQUxJRF9CT1hfUEFZX1JFQ0VJVkVSCiAgICBhc3NlcnQgLy8gQm94IHBheW1lbnQgcmVjZWl2ZXIgYWRkcmVzcyBtdXN0IG1hdGNoIGFwcGxpY2F0aW9uIGFkZHJlc3MuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxNQogICAgLy8gcXVpY2tfcGxheV9lbmFibGVkPWFyYzQuQm9vbChxdWlja19wbGF5X2VuYWJsZWQpLAogICAgYnl0ZWNfMSAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIC01CiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzE2CiAgICAvLyBtYXhfcGxheWVycz1hcmM0LlVJbnQ4KG1heF9wbGF5ZXJzKSwKICAgIGZyYW1lX2RpZyAtNAogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMjMKICAgIC8vIGV4cGlyeV90cz1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGNzdC5QSEFTRV9FWFBJUllfSU5URVJWQUwpLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50YyA1IC8vIDIwMAogICAgKwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMjQKICAgIC8vIHByaXplX3Bvb2w9YXJjNC5VSW50NjQoc3Rha2VfcGF5LmFtb3VudCksCiAgICB1bmNvdmVyIDQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzI1CiAgICAvLyBhZG1pbl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzI2CiAgICAvLyBmaXJzdF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMjctMzI5CiAgICAvLyBzZWNvbmRfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyB0aGlyZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vIHRvcHNjb3Jlcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIGR1cG4gMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMTItMzMwCiAgICAvLyAjIENyZWF0ZSBhIGdhbWUgc3RhdGUgYm94IHdpdGggdW5pcXVlIGdhbWUgSUQgYXMga2V5IGFuZCBhc3NpZ24gaXRzIGRlZmF1bHQgc3RhcnRpbmcgdmFsdWVzCiAgICAvLyBzZWxmLmJveF9nYW1lX3N0YXRlW3NlbGYuZ2FtZV9pZF0gPSBzdGMuR2FtZVN0YXRlKAogICAgLy8gICAgIHN0YWtpbmdfZmluYWxpemVkPWFyYzQuQm9vbChGYWxzZSksICAjIG5vcWE6IEZCVDAwMwogICAgLy8gICAgIHF1aWNrX3BsYXlfZW5hYmxlZD1hcmM0LkJvb2wocXVpY2tfcGxheV9lbmFibGVkKSwKICAgIC8vICAgICBtYXhfcGxheWVycz1hcmM0LlVJbnQ4KG1heF9wbGF5ZXJzKSwKICAgIC8vICAgICBhY3RpdmVfcGxheWVycz1hcmM0LlVJbnQ4KDEpLAogICAgLy8gICAgIGZpcnN0X3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgc2Vjb25kX3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgdGhpcmRfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICB0b3Bfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBib3hfcF9zdGFydF9wb3M9YXJjNC5VSW50MTYoY3N0LkFERFJFU1NfU0laRSksCiAgICAvLyAgICAgZXhwaXJ5X3RzPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICsgY3N0LlBIQVNFX0VYUElSWV9JTlRFUlZBTCksCiAgICAvLyAgICAgcHJpemVfcG9vbD1hcmM0LlVJbnQ2NChzdGFrZV9wYXkuYW1vdW50KSwKICAgIC8vICAgICBhZG1pbl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBmaXJzdF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICBzZWNvbmRfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgdGhpcmRfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgdG9wc2NvcmVyX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gKQogICAgdW5jb3ZlciA4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxNAogICAgLy8gc3Rha2luZ19maW5hbGl6ZWQ9YXJjNC5Cb29sKEZhbHNlKSwgICMgbm9xYTogRkJUMDAzCiAgICBieXRlY18xIC8vIDB4MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEyLTMzMAogICAgLy8gIyBDcmVhdGUgYSBnYW1lIHN0YXRlIGJveCB3aXRoIHVuaXF1ZSBnYW1lIElEIGFzIGtleSBhbmQgYXNzaWduIGl0cyBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV9zdGF0ZVtzZWxmLmdhbWVfaWRdID0gc3RjLkdhbWVTdGF0ZSgKICAgIC8vICAgICBzdGFraW5nX2ZpbmFsaXplZD1hcmM0LkJvb2woRmFsc2UpLCAgIyBub3FhOiBGQlQwMDMKICAgIC8vICAgICBxdWlja19wbGF5X2VuYWJsZWQ9YXJjNC5Cb29sKHF1aWNrX3BsYXlfZW5hYmxlZCksCiAgICAvLyAgICAgbWF4X3BsYXllcnM9YXJjNC5VSW50OChtYXhfcGxheWVycyksCiAgICAvLyAgICAgYWN0aXZlX3BsYXllcnM9YXJjNC5VSW50OCgxKSwKICAgIC8vICAgICBmaXJzdF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRoaXJkX3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgdG9wX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgYm94X3Bfc3RhcnRfcG9zPWFyYzQuVUludDE2KGNzdC5BRERSRVNTX1NJWkUpLAogICAgLy8gICAgIGV4cGlyeV90cz1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGNzdC5QSEFTRV9FWFBJUllfSU5URVJWQUwpLAogICAgLy8gICAgIHByaXplX3Bvb2w9YXJjNC5VSW50NjQoc3Rha2VfcGF5LmFtb3VudCksCiAgICAvLyAgICAgYWRtaW5fYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZmlyc3RfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgc2Vjb25kX3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHRoaXJkX3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHRvcHNjb3Jlcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICkKICAgIGludGNfMSAvLyAxCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgdW5jb3ZlciA4CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzE3CiAgICAvLyBhY3RpdmVfcGxheWVycz1hcmM0LlVJbnQ4KDEpLAogICAgcHVzaGJ5dGVzIDB4MDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEyLTMzMAogICAgLy8gIyBDcmVhdGUgYSBnYW1lIHN0YXRlIGJveCB3aXRoIHVuaXF1ZSBnYW1lIElEIGFzIGtleSBhbmQgYXNzaWduIGl0cyBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV9zdGF0ZVtzZWxmLmdhbWVfaWRdID0gc3RjLkdhbWVTdGF0ZSgKICAgIC8vICAgICBzdGFraW5nX2ZpbmFsaXplZD1hcmM0LkJvb2woRmFsc2UpLCAgIyBub3FhOiBGQlQwMDMKICAgIC8vICAgICBxdWlja19wbGF5X2VuYWJsZWQ9YXJjNC5Cb29sKHF1aWNrX3BsYXlfZW5hYmxlZCksCiAgICAvLyAgICAgbWF4X3BsYXllcnM9YXJjNC5VSW50OChtYXhfcGxheWVycyksCiAgICAvLyAgICAgYWN0aXZlX3BsYXllcnM9YXJjNC5VSW50OCgxKSwKICAgIC8vICAgICBmaXJzdF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRoaXJkX3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgdG9wX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgYm94X3Bfc3RhcnRfcG9zPWFyYzQuVUludDE2KGNzdC5BRERSRVNTX1NJWkUpLAogICAgLy8gICAgIGV4cGlyeV90cz1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGNzdC5QSEFTRV9FWFBJUllfSU5URVJWQUwpLAogICAgLy8gICAgIHByaXplX3Bvb2w9YXJjNC5VSW50NjQoc3Rha2VfcGF5LmFtb3VudCksCiAgICAvLyAgICAgYWRtaW5fYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZmlyc3RfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgc2Vjb25kX3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHRoaXJkX3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHRvcHNjb3Jlcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMTgKICAgIC8vIGZpcnN0X3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICBieXRlY18xIC8vIDB4MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzEyLTMzMAogICAgLy8gIyBDcmVhdGUgYSBnYW1lIHN0YXRlIGJveCB3aXRoIHVuaXF1ZSBnYW1lIElEIGFzIGtleSBhbmQgYXNzaWduIGl0cyBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV9zdGF0ZVtzZWxmLmdhbWVfaWRdID0gc3RjLkdhbWVTdGF0ZSgKICAgIC8vICAgICBzdGFraW5nX2ZpbmFsaXplZD1hcmM0LkJvb2woRmFsc2UpLCAgIyBub3FhOiBGQlQwMDMKICAgIC8vICAgICBxdWlja19wbGF5X2VuYWJsZWQ9YXJjNC5Cb29sKHF1aWNrX3BsYXlfZW5hYmxlZCksCiAgICAvLyAgICAgbWF4X3BsYXllcnM9YXJjNC5VSW50OChtYXhfcGxheWVycyksCiAgICAvLyAgICAgYWN0aXZlX3BsYXllcnM9YXJjNC5VSW50OCgxKSwKICAgIC8vICAgICBmaXJzdF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRoaXJkX3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgdG9wX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgYm94X3Bfc3RhcnRfcG9zPWFyYzQuVUludDE2KGNzdC5BRERSRVNTX1NJWkUpLAogICAgLy8gICAgIGV4cGlyeV90cz1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGNzdC5QSEFTRV9FWFBJUllfSU5URVJWQUwpLAogICAgLy8gICAgIHByaXplX3Bvb2w9YXJjNC5VSW50NjQoc3Rha2VfcGF5LmFtb3VudCksCiAgICAvLyAgICAgYWRtaW5fYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZmlyc3RfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgc2Vjb25kX3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHRoaXJkX3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHRvcHNjb3Jlcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMTkKICAgIC8vIHNlY29uZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgYnl0ZWNfMSAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxMi0zMzAKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSBzdGF0ZSBib3ggd2l0aCB1bmlxdWUgZ2FtZSBJRCBhcyBrZXkgYW5kIGFzc2lnbiBpdHMgZGVmYXVsdCBzdGFydGluZyB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbc2VsZi5nYW1lX2lkXSA9IHN0Yy5HYW1lU3RhdGUoCiAgICAvLyAgICAgc3Rha2luZ19maW5hbGl6ZWQ9YXJjNC5Cb29sKEZhbHNlKSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyAgICAgcXVpY2tfcGxheV9lbmFibGVkPWFyYzQuQm9vbChxdWlja19wbGF5X2VuYWJsZWQpLAogICAgLy8gICAgIG1heF9wbGF5ZXJzPWFyYzQuVUludDgobWF4X3BsYXllcnMpLAogICAgLy8gICAgIGFjdGl2ZV9wbGF5ZXJzPWFyYzQuVUludDgoMSksCiAgICAvLyAgICAgZmlyc3RfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBzZWNvbmRfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRvcF9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIGJveF9wX3N0YXJ0X3Bvcz1hcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFKSwKICAgIC8vICAgICBleHBpcnlfdHM9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBjc3QuUEhBU0VfRVhQSVJZX0lOVEVSVkFMKSwKICAgIC8vICAgICBwcml6ZV9wb29sPWFyYzQuVUludDY0KHN0YWtlX3BheS5hbW91bnQpLAogICAgLy8gICAgIGFkbWluX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGZpcnN0X3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0b3BzY29yZXJfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzIwCiAgICAvLyB0aGlyZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgYnl0ZWNfMSAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxMi0zMzAKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSBzdGF0ZSBib3ggd2l0aCB1bmlxdWUgZ2FtZSBJRCBhcyBrZXkgYW5kIGFzc2lnbiBpdHMgZGVmYXVsdCBzdGFydGluZyB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbc2VsZi5nYW1lX2lkXSA9IHN0Yy5HYW1lU3RhdGUoCiAgICAvLyAgICAgc3Rha2luZ19maW5hbGl6ZWQ9YXJjNC5Cb29sKEZhbHNlKSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyAgICAgcXVpY2tfcGxheV9lbmFibGVkPWFyYzQuQm9vbChxdWlja19wbGF5X2VuYWJsZWQpLAogICAgLy8gICAgIG1heF9wbGF5ZXJzPWFyYzQuVUludDgobWF4X3BsYXllcnMpLAogICAgLy8gICAgIGFjdGl2ZV9wbGF5ZXJzPWFyYzQuVUludDgoMSksCiAgICAvLyAgICAgZmlyc3RfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBzZWNvbmRfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRvcF9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIGJveF9wX3N0YXJ0X3Bvcz1hcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFKSwKICAgIC8vICAgICBleHBpcnlfdHM9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBjc3QuUEhBU0VfRVhQSVJZX0lOVEVSVkFMKSwKICAgIC8vICAgICBwcml6ZV9wb29sPWFyYzQuVUludDY0KHN0YWtlX3BheS5hbW91bnQpLAogICAgLy8gICAgIGFkbWluX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGZpcnN0X3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0b3BzY29yZXJfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzIxCiAgICAvLyB0b3Bfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMTItMzMwCiAgICAvLyAjIENyZWF0ZSBhIGdhbWUgc3RhdGUgYm94IHdpdGggdW5pcXVlIGdhbWUgSUQgYXMga2V5IGFuZCBhc3NpZ24gaXRzIGRlZmF1bHQgc3RhcnRpbmcgdmFsdWVzCiAgICAvLyBzZWxmLmJveF9nYW1lX3N0YXRlW3NlbGYuZ2FtZV9pZF0gPSBzdGMuR2FtZVN0YXRlKAogICAgLy8gICAgIHN0YWtpbmdfZmluYWxpemVkPWFyYzQuQm9vbChGYWxzZSksICAjIG5vcWE6IEZCVDAwMwogICAgLy8gICAgIHF1aWNrX3BsYXlfZW5hYmxlZD1hcmM0LkJvb2wocXVpY2tfcGxheV9lbmFibGVkKSwKICAgIC8vICAgICBtYXhfcGxheWVycz1hcmM0LlVJbnQ4KG1heF9wbGF5ZXJzKSwKICAgIC8vICAgICBhY3RpdmVfcGxheWVycz1hcmM0LlVJbnQ4KDEpLAogICAgLy8gICAgIGZpcnN0X3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgc2Vjb25kX3BsYWNlX3Njb3JlPWFyYzQuVUludDgoMCksCiAgICAvLyAgICAgdGhpcmRfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICB0b3Bfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBib3hfcF9zdGFydF9wb3M9YXJjNC5VSW50MTYoY3N0LkFERFJFU1NfU0laRSksCiAgICAvLyAgICAgZXhwaXJ5X3RzPWFyYzQuVUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICsgY3N0LlBIQVNFX0VYUElSWV9JTlRFUlZBTCksCiAgICAvLyAgICAgcHJpemVfcG9vbD1hcmM0LlVJbnQ2NChzdGFrZV9wYXkuYW1vdW50KSwKICAgIC8vICAgICBhZG1pbl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBmaXJzdF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICBzZWNvbmRfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgdGhpcmRfcGxhY2VfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgdG9wc2NvcmVyX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMyMgogICAgLy8gYm94X3Bfc3RhcnRfcG9zPWFyYzQuVUludDE2KGNzdC5BRERSRVNTX1NJWkUpLAogICAgYnl0ZWMgMTEgLy8gMHgwMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxMi0zMzAKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSBzdGF0ZSBib3ggd2l0aCB1bmlxdWUgZ2FtZSBJRCBhcyBrZXkgYW5kIGFzc2lnbiBpdHMgZGVmYXVsdCBzdGFydGluZyB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbc2VsZi5nYW1lX2lkXSA9IHN0Yy5HYW1lU3RhdGUoCiAgICAvLyAgICAgc3Rha2luZ19maW5hbGl6ZWQ9YXJjNC5Cb29sKEZhbHNlKSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyAgICAgcXVpY2tfcGxheV9lbmFibGVkPWFyYzQuQm9vbChxdWlja19wbGF5X2VuYWJsZWQpLAogICAgLy8gICAgIG1heF9wbGF5ZXJzPWFyYzQuVUludDgobWF4X3BsYXllcnMpLAogICAgLy8gICAgIGFjdGl2ZV9wbGF5ZXJzPWFyYzQuVUludDgoMSksCiAgICAvLyAgICAgZmlyc3RfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBzZWNvbmRfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRvcF9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIGJveF9wX3N0YXJ0X3Bvcz1hcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFKSwKICAgIC8vICAgICBleHBpcnlfdHM9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBjc3QuUEhBU0VfRVhQSVJZX0lOVEVSVkFMKSwKICAgIC8vICAgICBwcml6ZV9wb29sPWFyYzQuVUludDY0KHN0YWtlX3BheS5hbW91bnQpLAogICAgLy8gICAgIGFkbWluX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGZpcnN0X3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0b3BzY29yZXJfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHVuY292ZXIgNwogICAgY29uY2F0CiAgICB1bmNvdmVyIDYKICAgIGNvbmNhdAogICAgdW5jb3ZlciA1CiAgICBjb25jYXQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozMTItMzEzCiAgICAvLyAjIENyZWF0ZSBhIGdhbWUgc3RhdGUgYm94IHdpdGggdW5pcXVlIGdhbWUgSUQgYXMga2V5IGFuZCBhc3NpZ24gaXRzIGRlZmF1bHQgc3RhcnRpbmcgdmFsdWVzCiAgICAvLyBzZWxmLmJveF9nYW1lX3N0YXRlW3NlbGYuZ2FtZV9pZF0gPSBzdGMuR2FtZVN0YXRlKAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDggLy8gImdhbWVfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZV9pZCBleGlzdHMKICAgIGR1cAogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAic18iCiAgICBkaWcgMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMxMi0zMzAKICAgIC8vICMgQ3JlYXRlIGEgZ2FtZSBzdGF0ZSBib3ggd2l0aCB1bmlxdWUgZ2FtZSBJRCBhcyBrZXkgYW5kIGFzc2lnbiBpdHMgZGVmYXVsdCBzdGFydGluZyB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbc2VsZi5nYW1lX2lkXSA9IHN0Yy5HYW1lU3RhdGUoCiAgICAvLyAgICAgc3Rha2luZ19maW5hbGl6ZWQ9YXJjNC5Cb29sKEZhbHNlKSwgICMgbm9xYTogRkJUMDAzCiAgICAvLyAgICAgcXVpY2tfcGxheV9lbmFibGVkPWFyYzQuQm9vbChxdWlja19wbGF5X2VuYWJsZWQpLAogICAgLy8gICAgIG1heF9wbGF5ZXJzPWFyYzQuVUludDgobWF4X3BsYXllcnMpLAogICAgLy8gICAgIGFjdGl2ZV9wbGF5ZXJzPWFyYzQuVUludDgoMSksCiAgICAvLyAgICAgZmlyc3RfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICBzZWNvbmRfcGxhY2Vfc2NvcmU9YXJjNC5VSW50OCgwKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIHRvcF9zY29yZT1hcmM0LlVJbnQ4KDApLAogICAgLy8gICAgIGJveF9wX3N0YXJ0X3Bvcz1hcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFKSwKICAgIC8vICAgICBleHBpcnlfdHM9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBjc3QuUEhBU0VfRVhQSVJZX0lOVEVSVkFMKSwKICAgIC8vICAgICBwcml6ZV9wb29sPWFyYzQuVUludDY0KHN0YWtlX3BheS5hbW91bnQpLAogICAgLy8gICAgIGFkbWluX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGZpcnN0X3BsYWNlX2FkZHJlc3M9YXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgIHNlY29uZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0aGlyZF9wbGFjZV9hZGRyZXNzPWFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIC8vICAgICB0b3BzY29yZXJfYWRkcmVzcz1hcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyApCiAgICB1bmNvdmVyIDMKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzMyLTMzMwogICAgLy8gIyBTZXQgdGhlIGhvc3RpbmcgZ2FtZSBmbGFnIHByb3BlcnR5IGluIHNlbmRlcidzIGdhbWUgcmVnaXN0ZXIgYm94IHRvIFRydWUKICAgIC8vIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbVHhuLnNlbmRlcl0uaG9zdGluZ19nYW1lID0gYXJjNC5Cb29sKAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjMzMi0zMzUKICAgIC8vICMgU2V0IHRoZSBob3N0aW5nIGdhbWUgZmxhZyBwcm9wZXJ0eSBpbiBzZW5kZXIncyBnYW1lIHJlZ2lzdGVyIGJveCB0byBUcnVlCiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdLmhvc3RpbmdfZ2FtZSA9IGFyYzQuQm9vbCgKICAgIC8vICAgICBUcnVlICAjIG5vcWE6IEZCVDAwMwogICAgLy8gKQogICAgaW50Y18wIC8vIDAKICAgIGludGNfMSAvLyAxCiAgICBzZXRiaXQKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzM3LTMzOQogICAgLy8gIyBDcmVhdGUgYSBnYW1lIHBsYXllcnMgYm94IHdpdGggdW5pcXVlIGdhbWUgSUQgYXMga2V5CiAgICAvLyAjIEFzc2lnbiB6ZXJvZWQgYnl0ZXMgdG8gc3RvcmUgYWxsIHBsYXllciBhZGRyZXNzZXMgKDMyIGJ5dGVzIHBlciBwbGF5ZXIpCiAgICAvLyBzZWxmLmJveF9nYW1lX3BsYXllcnNbc2VsZi5nYW1lX2lkXSA9IG9wLmJ6ZXJvKGNzdC5BRERSRVNTX1NJWkUgKiBtYXhfcGxheWVycykKICAgIHVuY292ZXIgMgogICAgYnplcm8KICAgIGJ5dGVjXzMgLy8gInBfIgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozNDUKICAgIC8vIGdhbWVfcGxheWVyc19icmVmLnJlcGxhY2UoMCwgVHhuLnNlbmRlci5ieXRlcykKICAgIGludGNfMCAvLyAwCiAgICB0eG4gU2VuZGVyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozNDctMzQ4CiAgICAvLyAjIEluY3JlbWVudCBnYW1lIGlkIGJ5IDEgZm9yIG5leHQgbmV3IGdhbWUgaW5zdGFuY2UKICAgIC8vIHNlbGYuZ2FtZV9pZCArPSAxCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWMgOCAvLyAiZ2FtZV9pZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCm5ld19nYW1lX2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBiIG5ld19nYW1lX2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LmpvaW5fZ2FtZShnYW1lX2lkOiB1aW50NjQsIHN0YWtlX3BheTogdWludDY0KSAtPiB2b2lkOgpqb2luX2dhbWU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM1MC0zNTYKICAgIC8vICMgSm9pbiBleGlzdGluZyBnYW1lIGluc3RhbmNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBqb2luX2dhbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2lkOiBVSW50NjQsCiAgICAvLyAgICAgc3Rha2VfcGF5OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozNTctMzU4CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAyLCBlcnIuSU5WQUxJRF9HUk9VUF9TSVpFCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBpbnRjXzIgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdyb3VwIHNpemUuIEVuc3VyZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW4gZ3JvdXAgaXMgd2l0aGluIHZhbGlkIGJvdW5kcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzU5CiAgICAvLyBhc3NlcnQgZ2FtZV9pZCBpbiBzZWxmLmJveF9nYW1lX3N0YXRlLCBlcnIuR0FNRV9JRF9OT1RfRk9VTkQKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAic18iCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBnYW1lIHN0YXRlIG5vdCBmb3VuZC4gQ2hlY2sgaWYgZ2FtZSBJRCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM2MS0zNjQKICAgIC8vICMgUmV0cmlldmUgY3VycmVudCBnYW1lIHN0YXRlIGRhdGEgZnJvbSBib3ggdXNpbmcgdGhlIGdhbWUgaWQgcGFyYW1ldGVyCiAgICAvLyBnYW1lX3N0YXRlID0gc2VsZi5ib3hfZ2FtZV9zdGF0ZVsKICAgIC8vICAgICBnYW1lX2lkCiAgICAvLyBdLmNvcHkoKSAgIyBNYWtlIGEgY29weSBvZiB0aGUgZ2FtZSBzdGF0ZSBlbHNlIGltbXV0YWJsZQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ib3hfZ2FtZV9zdGF0ZSBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzY2LTM2NwogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgc2VsZi5ib3hfZ2FtZV90cm9waHksIGVyci5CT1hfTk9UX0ZPVU5ECiAgICBieXRlY18yIC8vICJ0XyIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBub3QgZm91bmQuIEVuc3VyZSB0aGUgYm94IHlvdSBhcmUgdHJ5aW5nIHRvIGFjY2VzcyB3YXMgY3JlYXRlZCBhbmQgc3RpbGwgZXhpc3RzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozNjgKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsIGVyci5CT1hfTk9UX0ZPVU5ECiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQm94IG5vdCBmb3VuZC4gRW5zdXJlIHRoZSBib3ggeW91IGFyZSB0cnlpbmcgdG8gYWNjZXNzIHdhcyBjcmVhdGVkIGFuZCBzdGlsbCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM3MAogICAgLy8gYXNzZXJ0IHN0YWtlX3BheS5hbW91bnQgPT0gY3N0LlNUQUtFX0FNT1VOVCwgZXJyLklOVkFMSURfU1RBS0VfUEFZX0ZFRQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDAwMDAKICAgID09CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IGZ1bmRzLiBTdGFrZSBwYXkgYW1vdW50IGlzIG5vdCBlbm91Z2ggdG8gY292ZXIgc3Rha2luZyByZXF1aXJlbWVudHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM3MQogICAgLy8gYXNzZXJ0IHN0YWtlX3BheS5zZW5kZXIgPT0gVHhuLnNlbmRlciwgZXJyLklOVkFMSURfU1RBS0VfUEFZX1NFTkRFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gU3Rha2UgcGF5bWVudCBzZW5kZXIgYWRkcmVzcyBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlciBhZGRyZXNzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozNzMKICAgIC8vIHN0YWtlX3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzcyLTM3NAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzdGFrZV9wYXkucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLklOVkFMSURfU1RBS0VfUEFZX1JFQ0VJVkVSCiAgICBhc3NlcnQgLy8gU3Rha2UgcGF5bWVudCByZWNlaXZlciBhZGRyZXNzIG11c3QgbWF0Y2ggYXBwbGljYXRpb24gYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mzc3CiAgICAvLyBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM3OQogICAgLy8gcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0uYWN0aXZlX3BsYXllcnMubmF0aXZlLAogICAgZGlnIDIKICAgIGludGNfMiAvLyAyCiAgICBnZXRieXRlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM3NS0zODEKICAgIC8vIGFzc2VydCBub3Qgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0uYWN0aXZlX3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICksIGVyci5QTEFZRVJfQUNUSVZFCiAgICBmcmFtZV9kaWcgLTIKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozNzgKICAgIC8vIGJveF9nYW1lX3BsYXllcnM9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLAogICAgYnl0ZWNfMyAvLyAicF8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM3NS0zODEKICAgIC8vIGFzc2VydCBub3Qgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0uYWN0aXZlX3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICksIGVyci5QTEFZRVJfQUNUSVZFCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozODAKICAgIC8vIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM3NS0zODEKICAgIC8vIGFzc2VydCBub3Qgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0uYWN0aXZlX3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICksIGVyci5QTEFZRVJfQUNUSVZFCiAgICBjYWxsc3ViIGNoZWNrX2FjY19pbl9nYW1lCiAgICAhCiAgICBhc3NlcnQgLy8gUGxheWVyIHdpdGggdGhpcyBhZGRyZXNzIG11c3Qgbm90IGJlIGFuIGFjdGl2ZSBnYW1lIHBhcnRpY2lwYW50IGluIHRoZSBnYW1lLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozODMKICAgIC8vIGFzc2VydCBub3QgZ2FtZV9zdGF0ZS5zdGFraW5nX2ZpbmFsaXplZC5uYXRpdmUsIGVyci5TVEFLSU5HX0ZJTkFMX0ZMQUcKICAgIGRpZyAyCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIEdhbWUgc3RhdGUgc3Rha2luZyBmaW5hbGl6ZWQgYm9vbGVhbiB2YWx1ZSBtaXNtYXRjaC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mzg1CiAgICAvLyBnYW1lX3N0YXRlLmV4cGlyeV90cyA+PSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZGlnIDIKICAgIGV4dHJhY3QgOSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgYj49CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM4NC0zODYKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZ2FtZV9zdGF0ZS5leHBpcnlfdHMgPj0gR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAKICAgIC8vICksIGVyci5USU1FX0NPTlNUUkFJTlRfVklPTEFUSU9OCiAgICBhc3NlcnQgLy8gSW52YWxpZCB0aW1lIGZyYW1lLiBDYWxsIG1hZGUgb3V0c2lkZSB0aGUgcGVybWl0dGVkIGJsb2NrIG9yIHRpbWVzdGFtcCByYW5nZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mzg3CiAgICAvLyBhc3NlcnQgZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycyA8PSBnYW1lX3N0YXRlLm1heF9wbGF5ZXJzLCBlcnIuRlVMTF9HQU1FX0xPQkJZCiAgICBkaWcgMgogICAgZXh0cmFjdCAyIDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgZXh0cmFjdCAxIDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBiPD0KICAgIGFzc2VydCAvLyBOdW1iZXIgb2YgYWN0aXZlIHBsYXllcnMgbXVzdCBub3QgZXhjZWVkIG51bWJlciBvZiBtYXggcGxheWVycy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mzg5CiAgICAvLyBnYW1lX3N0YXRlLmJveF9wX3N0YXJ0X3Bvcy5uYXRpdmUKICAgIGRpZyAyCiAgICBwdXNoaW50IDcgLy8gNwogICAgZXh0cmFjdF91aW50MTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6MzkwCiAgICAvLyA8IGNzdC5BRERSRVNTX1NJWkUgKiBnYW1lX3N0YXRlLm1heF9wbGF5ZXJzLm5hdGl2ZQogICAgZGlnIDMKICAgIGludGNfMSAvLyAxCiAgICBnZXRieXRlCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mzg5LTM5MAogICAgLy8gZ2FtZV9zdGF0ZS5ib3hfcF9zdGFydF9wb3MubmF0aXZlCiAgICAvLyA8IGNzdC5BRERSRVNTX1NJWkUgKiBnYW1lX3N0YXRlLm1heF9wbGF5ZXJzLm5hdGl2ZQogICAgZGlnIDEKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Mzg4LTM5MQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBnYW1lX3N0YXRlLmJveF9wX3N0YXJ0X3Bvcy5uYXRpdmUKICAgIC8vICAgICA8IGNzdC5BRERSRVNTX1NJWkUgKiBnYW1lX3N0YXRlLm1heF9wbGF5ZXJzLm5hdGl2ZQogICAgLy8gKSwgZXJyLkJPWF9QX1NUQVJUX1BPU19PVkVSRkxPVwogICAgYXNzZXJ0IC8vIFBsYXllcnMgYm94IHN0YXJ0IHBvc2l0aW9uIGluZGV4IG92ZXJmbG93LiBDYW4gbm90IHN0b3JlIG1vcmUgYWRkcmVzc2VzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozOTUKICAgIC8vIGtleT1zZWxmLmJveF9nYW1lX3BsYXllcnMua2V5X3ByZWZpeCArIG9wLml0b2IoZ2FtZV9pZCkKICAgIGJ5dGVjXzMgLy8gInBfIgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozOTMtMzk2CiAgICAvLyAjIEZvciBnYW1lIHBsYXllcnMgYm94LCBzdG9yZSB0aGUgc2VuZGVyJ3MgYWRkcmVzcyBhdCB0aGUgY3VycmVudCBnYW1lIHN0YXRlIGJveCBwXyBzdGFydCBwb3NpdGlvbgogICAgLy8gZ2FtZV9wbGF5ZXJzX2JyZWYgPSBCb3hSZWYoCiAgICAvLyAgICAga2V5PXNlbGYuYm94X2dhbWVfcGxheWVycy5rZXlfcHJlZml4ICsgb3AuaXRvYihnYW1lX2lkKQogICAgLy8gKQogICAgdW5jb3ZlciA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM5NQogICAgLy8ga2V5PXNlbGYuYm94X2dhbWVfcGxheWVycy5rZXlfcHJlZml4ICsgb3AuaXRvYihnYW1lX2lkKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjM5NwogICAgLy8gZ2FtZV9wbGF5ZXJzX2JyZWYucmVwbGFjZShnYW1lX3N0YXRlLmJveF9wX3N0YXJ0X3Bvcy5uYXRpdmUsIFR4bi5zZW5kZXIuYnl0ZXMpCiAgICB0eG4gU2VuZGVyCiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTozOTktNDAwCiAgICAvLyAjIEluY3JlbWVudCBudW1iZXIgb2YgYWN0aXZlIHBsYXllcnMgYnkgMQogICAgLy8gZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycyA9IGFyYzQuVUludDgoZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgKyAxKQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgcmVwbGFjZTIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MDQKICAgIC8vIGdhbWVfc3RhdGUuYm94X3Bfc3RhcnRfcG9zLm5hdGl2ZSArIGNzdC5BRERSRVNTX1NJWkUKICAgIGR1cAogICAgcHVzaGludCA3IC8vIDcKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMzIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDAyLTQwNQogICAgLy8gIyBJbmNyZW1lbnQgY3VycmVudCBnYW1lIHBsYXllcnMgYm94IG9mZnNldCBieSAzMiBzbyB0aGF0IG5leHQgcGxheWVyIGFkZHJlc3MgY2FuIGJlIHN0b3JlZAogICAgLy8gZ2FtZV9zdGF0ZS5ib3hfcF9zdGFydF9wb3MgPSBhcmM0LlVJbnQxNigKICAgIC8vICAgICBnYW1lX3N0YXRlLmJveF9wX3N0YXJ0X3Bvcy5uYXRpdmUgKyBjc3QuQUREUkVTU19TSVpFCiAgICAvLyApCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDA5CiAgICAvLyBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlICsgc3Rha2VfcGF5LmFtb3VudAogICAgZHVwCiAgICBwdXNoaW50IDE3IC8vIDE3CiAgICBleHRyYWN0X3VpbnQ2NAogICAgdW5jb3ZlciAyCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQwNy00MTAKICAgIC8vICMgSW5jcmVtZW50IHByaXplIHBvb2wgYnkgc3Rha2UgcGF5bWVudCBhbW91bnQKICAgIC8vIGdhbWVfc3RhdGUucHJpemVfcG9vbCA9IGFyYzQuVUludDY0KAogICAgLy8gICAgIGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgKyBzdGFrZV9wYXkuYW1vdW50CiAgICAvLyApCiAgICBpdG9iCiAgICByZXBsYWNlMiAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MTItNDEzCiAgICAvLyAjIENoZWNrIGlmIGdhbWUgaXMgbGl2ZSBvbiBldmVyeSBjYWxsCiAgICAvLyBzcnQuaXNfZ2FtZV9saXZlKGdhbWVfaWQ9Z2FtZV9pZCwgZ2FtZV9zdGF0ZT1nYW1lX3N0YXRlKQogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjYWxsc3ViIGlzX2dhbWVfbGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MTUtNDE2CiAgICAvLyAjIENvcHkgdGhlIG1vZGlmaWVkIGdhbWUgc3RhdGUgYW5kIHN0b3JlIGl0IGFzIG5ldyB2YWx1ZSBvZiBib3gKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0gPSBnYW1lX3N0YXRlLmNvcHkoKQogICAgYm94X3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnBpZW91dC5jb250cmFjdC5QaWVvdXQuc2V0X2dhbWVfY29tbWl0KGdhbWVfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc2V0X2dhbWVfY29tbWl0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MTgtNDIzCiAgICAvLyAjIFNldCBhIGNvbW1pdG1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2V0IG9uLWNoYWluIHJhbmRvbW5lc3MgYW5kIHBsYXkgdGhlIGdhbWUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIHNldF9nYW1lX2NvbW1pdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGdhbWVfaWQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MjQtNDI1CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAxLCBlcnIuU1RBTkRBTE9ORV9UWE5fT05MWQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBncm91cCBzaXplLiBUaGlzIGFwcCBjYWxsIGNhbiBvbmx5IHRha2Ugc3RhbmRhbG9uZSB0cmFuc2FjdGlvbnMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQyNgogICAgLy8gYXNzZXJ0IGdhbWVfaWQgaW4gc2VsZi5ib3hfZ2FtZV9zdGF0ZSwgZXJyLkdBTUVfSURfTk9UX0ZPVU5ECiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGJ5dGVjIDQgLy8gInNfIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggZ2FtZSBzdGF0ZSBub3QgZm91bmQuIENoZWNrIGlmIGdhbWUgSUQgZXhpc3RzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MjcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsIGVyci5CT1hfTk9UX0ZPVU5ECiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQm94IG5vdCBmb3VuZC4gRW5zdXJlIHRoZSBib3ggeW91IGFyZSB0cnlpbmcgdG8gYWNjZXNzIHdhcyBjcmVhdGVkIGFuZCBzdGlsbCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQyOC00MzAKICAgIC8vIGFzc2VydCBzZWxmLmJveF9nYW1lX3N0YXRlWwogICAgLy8gICAgIGdhbWVfaWQKICAgIC8vIF0uc3Rha2luZ19maW5hbGl6ZWQubmF0aXZlLCBlcnIuU1RBS0lOR19GSU5BTF9GTEFHCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ib3hfZ2FtZV9zdGF0ZSBlbnRyeSBleGlzdHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnl0ZWNfMSAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGFzc2VydCAvLyBHYW1lIHN0YXRlIHN0YWtpbmcgZmluYWxpemVkIGJvb2xlYW4gdmFsdWUgbWlzbWF0Y2guCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQzNAogICAgLy8gYWNjb3VudD1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MzYKICAgIC8vIHBsYXllcl9jb3VudD1zZWxmLmJveF9nYW1lX3N0YXRlW2dhbWVfaWRdLm1heF9wbGF5ZXJzLm5hdGl2ZSwKICAgIHN3YXAKICAgIGludGNfMSAvLyAxCiAgICBnZXRieXRlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQzMi00MzgKICAgIC8vIHNydC5jaGVja19hY2NfaW5fZ2FtZSggICMgbm9xYTogRTcxMgogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0ubWF4X3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQzNQogICAgLy8gYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICBieXRlY18zIC8vICJwXyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDMyLTQzOAogICAgLy8gc3J0LmNoZWNrX2FjY19pbl9nYW1lKCAgIyBub3FhOiBFNzEyCiAgICAvLyAgICAgZ2FtZV9pZD1nYW1lX2lkLAogICAgLy8gICAgIGFjY291bnQ9VHhuLnNlbmRlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICAgICBwbGF5ZXJfY291bnQ9c2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXS5tYXhfcGxheWVycy5uYXRpdmUsCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKQogICAgdW5jb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQzNwogICAgLy8gY2xlYXJfcGxheWVyPUZhbHNlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDMyLTQzOAogICAgLy8gc3J0LmNoZWNrX2FjY19pbl9nYW1lKCAgIyBub3FhOiBFNzEyCiAgICAvLyAgICAgZ2FtZV9pZD1nYW1lX2lkLAogICAgLy8gICAgIGFjY291bnQ9VHhuLnNlbmRlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICAgICBwbGF5ZXJfY291bnQ9c2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXS5tYXhfcGxheWVycy5uYXRpdmUsCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKQogICAgY2FsbHN1YiBjaGVja19hY2NfaW5fZ2FtZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0MzkKICAgIC8vID09IFRydWUKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQzMi00MzkKICAgIC8vIHNydC5jaGVja19hY2NfaW5fZ2FtZSggICMgbm9xYTogRTcxMgogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0ubWF4X3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICkKICAgIC8vID09IFRydWUKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQzMS00NDAKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc3J0LmNoZWNrX2FjY19pbl9nYW1lKCAgIyBub3FhOiBFNzEyCiAgICAvLyAgICAgICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICAgICAgYWNjb3VudD1UeG4uc2VuZGVyLAogICAgLy8gICAgICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICAgICAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0ubWF4X3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgICAgICBjbGVhcl9wbGF5ZXI9RmFsc2UsCiAgICAvLyAgICAgKQogICAgLy8gICAgID09IFRydWUKICAgIC8vICksIGVyci5QTEFZRVJfTk9UX0ZPVU5ECiAgICBhc3NlcnQgLy8gQWNjb3VudCBpcyBub3QgcmVjb2duaXplZCBhcyBhbiBhY3RpdmUgcGxheWVyIGZvciB0aGlzIGdhbWUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ0Mi00NDMKICAgIC8vICMgUmV0cmlldmUgY3VycmVudCBnYW1lIHJlZ2lzdGVyIGRhdGEgZnJvbSBib3ggdXNpbmcgdGhlIGdhbWUgaWQgcGFyYW1ldGVyCiAgICAvLyBnYW1lX3JlZ2lzdGVyID0gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlclsKICAgIGJ5dGVjXzAgLy8gInJfIgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NDQKICAgIC8vIFR4bi5zZW5kZXIKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDQyLTQ0NQogICAgLy8gIyBSZXRyaWV2ZSBjdXJyZW50IGdhbWUgcmVnaXN0ZXIgZGF0YSBmcm9tIGJveCB1c2luZyB0aGUgZ2FtZSBpZCBwYXJhbWV0ZXIKICAgIC8vIGdhbWVfcmVnaXN0ZXIgPSBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyWwogICAgLy8gICAgIFR4bi5zZW5kZXIKICAgIC8vIF0uY29weSgpICAjIE1ha2UgYSBjb3B5IG9mIHRoZSBnYW1lIHN0YXRlIGVsc2UgaW1tdXRhYmxlCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NDctNDQ4CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBnYW1lX3JlZ2lzdGVyLmNvbW1pdF9yYW5kX3JvdW5kID09IDAsIGVyci5OT05fWkVST19DT01NSVRfUkFORF9ST1VORAogICAgZHVwCiAgICBleHRyYWN0IDEwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBieXRlYyA2IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgYj09CiAgICBhc3NlcnQgLy8gQ29tbWl0IFJhbmQgUm91bmQgbm90IGVtcHR5LiBWYWx1ZSBtdXN0IGJlIHplcm8gdG8gb2J0YWluIGEgdmFsaWQgb25lLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NTAtNDUxCiAgICAvLyAjIFVwZGF0ZSBnYW1lIHJlZ2lzdGVyIGJveCBkYXRhIGNvbW1pdCByYW5kIHJvdW5kIGFuZCBnYW1lIGlkIHByb3BlcnRpZXMgd2l0aCBuZXcgdmFsdWVzCiAgICAvLyBnYW1lX3JlZ2lzdGVyLmNvbW1pdF9yYW5kX3JvdW5kID0gYXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kICsgNCkKICAgIGdsb2JhbCBSb3VuZAogICAgcHVzaGludCA0IC8vIDQKICAgICsKICAgIGl0b2IKICAgIHJlcGxhY2UyIDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ1MgogICAgLy8gZ2FtZV9yZWdpc3Rlci5nYW1lX2lkID0gYXJjNC5VSW50NjQoZ2FtZV9pZCkKICAgIHN3YXAKICAgIHJlcGxhY2UyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDU0LTQ1NQogICAgLy8gIyBDb3B5IHRoZSBtb2RpZmllZCBnYW1lIHN0YXRlIGFuZCBzdG9yZSBpdCBhcyBuZXcgdmFsdWUgb2YgYm94CiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdID0gZ2FtZV9yZWdpc3Rlci5jb3B5KCkKICAgIGJ5dGVjXzAgLy8gInJfIgogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBzd2FwCiAgICBib3hfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC51cF9yZWZfYnVkZ2V0X2Zvcl9wbGF5X2dhbWUoZ2FtZV9pZDogdWludDY0KSAtPiB2b2lkOgp1cF9yZWZfYnVkZ2V0X2Zvcl9wbGF5X2dhbWU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ1Ny00NTkKICAgIC8vICMgTWFrZSBhcHAgY2FsbCB0byBhZGQgZXh0cmEgcmVzb3VyY2UgcmVmZXJlbmNlIGJ1ZGdldCwgbXVzdCBiZSBncm91cGVkIHcvIHBsYXkgZ2FtZSBhYmltZXRob2QKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIHVwX3JlZl9idWRnZXRfZm9yX3BsYXlfZ2FtZShzZWxmLCBnYW1lX2lkOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDYwLTQ2MQogICAgLy8gIyBHZXQgdGhlIHNlY29uZCB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAKICAgIC8vIHNlY29uZF90eG4gPSBndHhuLkFwcGxpY2F0aW9uQ2FsbFRyYW5zYWN0aW9uKGdyb3VwX2luZGV4PTEpCiAgICBpbnRjXzEgLy8gMQogICAgZ3R4bnMgVHlwZUVudW0KICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgYXBwbAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NjMtNDY0CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAyLCBlcnIuSU5WQUxJRF9HUk9VUF9TSVpFCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBpbnRjXzIgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdyb3VwIHNpemUuIEVuc3VyZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW4gZ3JvdXAgaXMgd2l0aGluIHZhbGlkIGJvdW5kcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDY1CiAgICAvLyBhc3NlcnQgVHhuLmdyb3VwX2luZGV4ID09IDAsIGVyci5JTlZBTElEX0dST1VQX0lEWAogICAgdHhuIEdyb3VwSW5kZXgKICAgICEKICAgIGFzc2VydCAvLyBJbnZhbGlkIGdyb3VwIGluZGV4LiBFbnN1cmUgdHJhbnNhY3Rpb24gZ3JvdXAgaW5kZXggbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgdmFsdWUuIAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NjYKICAgIC8vIGFzc2VydCBnYW1lX2lkIGluIHNlbGYuYm94X2dhbWVfc3RhdGUsIGVyci5HQU1FX0lEX05PVF9GT1VORAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBieXRlYyA0IC8vICJzXyIKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBnYW1lIHN0YXRlIG5vdCBmb3VuZC4gQ2hlY2sgaWYgZ2FtZSBJRCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ2MC00NjEKICAgIC8vICMgR2V0IHRoZSBzZWNvbmQgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwCiAgICAvLyBzZWNvbmRfdHhuID0gZ3R4bi5BcHBsaWNhdGlvbkNhbGxUcmFuc2FjdGlvbihncm91cF9pbmRleD0xKQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDY4CiAgICAvLyBhc3NlcnQgc2Vjb25kX3R4bi5hcHBfaWQgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQsIGVyci5BUFBfSURfTUlTTUFUQ0gKICAgIGd0eG5zIEFwcGxpY2F0aW9uSUQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgPT0KICAgIGFzc2VydCAvLyBBcHBsaWNhdGlvbiBJRCBtaXNtYXRjaC4gQXBwIElEIG11c3QgYmUgc2FtZSBhY3Jvc3MgYWxsIHRyYW5zYWN0aW9ucyBpbiBncm91cC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDYwLTQ2MQogICAgLy8gIyBHZXQgdGhlIHNlY29uZCB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAKICAgIC8vIHNlY29uZF90eG4gPSBndHhuLkFwcGxpY2F0aW9uQ2FsbFRyYW5zYWN0aW9uKGdyb3VwX2luZGV4PTEpCiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NjkKICAgIC8vIGFzc2VydCBzZWNvbmRfdHhuLnNlbmRlciA9PSBUeG4uc2VuZGVyLCBlcnIuU0VOREVSX01JU01BVENICiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gU2VuZGVyIG1pc21hdGNoLiBTZW5kZXIgbXVzdCBiZSBzYW1lIGFkZHJlc3MgYWNyb3NzIGFsbCB0cmFuc2FjdGlvbnMgaW4gZ3JvdXAuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ2MC00NjEKICAgIC8vICMgR2V0IHRoZSBzZWNvbmQgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwCiAgICAvLyBzZWNvbmRfdHhuID0gZ3R4bi5BcHBsaWNhdGlvbkNhbGxUcmFuc2FjdGlvbihncm91cF9pbmRleD0xKQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDcwCiAgICAvLyBhc3NlcnQgc2Vjb25kX3R4bi5hcHBfYXJncygwKSA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKAogICAgaW50Y18wIC8vIDAKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ3MC00NzIKICAgIC8vIGFzc2VydCBzZWNvbmRfdHhuLmFwcF9hcmdzKDApID09IGFyYzQuYXJjNF9zaWduYXR1cmUoCiAgICAvLyAgICAgInBsYXlfZ2FtZSh1aW50NjQpdm9pZCIKICAgIC8vICksIGVyci5JTlZBTElEX01FVEhPRF9TRUxFQ1RPUgogICAgYnl0ZWMgMTAgLy8gbWV0aG9kICJwbGF5X2dhbWUodWludDY0KXZvaWQiCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGF0IHRoaXMgZ3JvdXAgaW5kZXggbXVzdCBoYXZlIGV4YWN0IHJlcXVpcmVkIG1ldGhvZCBzZWxlY3Rvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDYwLTQ2MQogICAgLy8gIyBHZXQgdGhlIHNlY29uZCB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAKICAgIC8vIHNlY29uZF90eG4gPSBndHhuLkFwcGxpY2F0aW9uQ2FsbFRyYW5zYWN0aW9uKGdyb3VwX2luZGV4PTEpCiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0NzQKICAgIC8vIGFzc2VydCBzZWNvbmRfdHhuLmFwcF9hcmdzKDEpID09IG9wLml0b2IoZ2FtZV9pZCksIGVyci5JTlZBTElEX0dBTUVfSUQKICAgIGR1cAogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgR2FtZSBJRC4gQm94IEdhbWUgUmVnaXN0ZXIgR2FtZSBJRCBtdXN0IGJlIGEgY2VydGFpbiB2YWx1ZSBvciBtYXRjaCBHYW1lIElEIGFyZy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDc2CiAgICAvLyBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdLmdhbWVfaWQubmF0aXZlCiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICBpbnRjXzIgLy8gMgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDc1LTQ3NwogICAgLy8gYXNzZXJ0IHNlY29uZF90eG4uYXBwX2FyZ3MoMSkgPT0gb3AuaXRvYigKICAgIC8vICAgICBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdLmdhbWVfaWQubmF0aXZlCiAgICAvLyApCiAgICBpdG9iCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ3OAogICAgLy8gYXNzZXJ0IHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbVHhuLnNlbmRlcl0uZ2FtZV9pZC5uYXRpdmUgPT0gZ2FtZV9pZAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyIGVudHJ5IGV4aXN0cwogICAgaW50Y18yIC8vIDIKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LnBsYXlfZ2FtZShnYW1lX2lkOiB1aW50NjQpIC0+IHZvaWQ6CnBsYXlfZ2FtZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDgwLTQ4MgogICAgLy8gIyBQbGF5IHRoZSBnYW1lLCByZXNvbHZlIHRoZSBwbGF5ZXIncyBzY29yZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdhbWUgaW5zdGFuY2UsIHVwZGF0ZSBnYW1lIHN0YXRlIGFjY29yZGluZ2x5CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBwbGF5X2dhbWUoc2VsZiwgZ2FtZV9pZDogVUludDY0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiAxMAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDYKCnBsYXlfZ2FtZV93aGlsZV90b3BAMTE6CiAgICBwdXNoaW50IDE5NjEwIC8vIDE5NjEwCiAgICBnbG9iYWwgT3Bjb2RlQnVkZ2V0CiAgICA+CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfd2hpbGVAMTYKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgIGl0eG5fZmllbGQgT25Db21wbGV0aW9uCiAgICBieXRlYyAxMiAvLyAweDA2ODEwMQogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KICAgIGJ5dGVjIDEyIC8vIDB4MDY4MTAxCiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBiIHBsYXlfZ2FtZV93aGlsZV90b3BAMTEKCnBsYXlfZ2FtZV9hZnRlcl93aGlsZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDg2LTQ4NwogICAgLy8gIyBHZXQgdGhlIGZpcnN0IHRyYW5zYWN0aW9uIGluIHRoZSBncm91cAogICAgLy8gZmlyc3RfdHhuID0gZ3R4bi5BcHBsaWNhdGlvbkNhbGxUcmFuc2FjdGlvbihncm91cF9pbmRleD0wKQogICAgaW50Y18wIC8vIDAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIGFwcGwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDg5LTQ5MAogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgR2xvYmFsLmdyb3VwX3NpemUgPT0gMiwgZXJyLklOVkFMSURfR1JPVVBfU0laRQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18yIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBncm91cCBzaXplLiBFbnN1cmUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGluIGdyb3VwIGlzIHdpdGhpbiB2YWxpZCBib3VuZHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ5MQogICAgLy8gYXNzZXJ0IFR4bi5ncm91cF9pbmRleCA9PSAxLCBlcnIuSU5WQUxJRF9HUk9VUF9JRFgKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdyb3VwIGluZGV4LiBFbnN1cmUgdHJhbnNhY3Rpb24gZ3JvdXAgaW5kZXggbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgdmFsdWUuIAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0OTMKICAgIC8vIGFzc2VydCBnYW1lX2lkIGluIHNlbGYuYm94X2dhbWVfc3RhdGUsIGVyci5HQU1FX0lEX05PVF9GT1VORAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgYnl0ZWMgNCAvLyAic18iCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBnYW1lIHN0YXRlIG5vdCBmb3VuZC4gQ2hlY2sgaWYgZ2FtZSBJRCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ5NAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwgZXJyLkJPWF9OT1RfRk9VTkQKICAgIGJ5dGVjXzAgLy8gInJfIgogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggbm90IGZvdW5kLiBFbnN1cmUgdGhlIGJveCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3Mgd2FzIGNyZWF0ZWQgYW5kIHN0aWxsIGV4aXN0cy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDk1CiAgICAvLyBhc3NlcnQgc2VsZi5ib3hfZ2FtZV90cm9waHksIGVyci5CT1hfTk9UX0ZPVU5ECiAgICBieXRlY18yIC8vICJ0XyIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBub3QgZm91bmQuIEVuc3VyZSB0aGUgYm94IHlvdSBhcmUgdHJ5aW5nIHRvIGFjY2VzcyB3YXMgY3JlYXRlZCBhbmQgc3RpbGwgZXhpc3RzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0ODYtNDg3CiAgICAvLyAjIEdldCB0aGUgZmlyc3QgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwCiAgICAvLyBmaXJzdF90eG4gPSBndHhuLkFwcGxpY2F0aW9uQ2FsbFRyYW5zYWN0aW9uKGdyb3VwX2luZGV4PTApCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0OTcKICAgIC8vIGFzc2VydCBmaXJzdF90eG4uYXBwX2lkID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2lkLCBlcnIuQVBQX0lEX01JU01BVENICiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICBhc3NlcnQgLy8gQXBwbGljYXRpb24gSUQgbWlzbWF0Y2guIEFwcCBJRCBtdXN0IGJlIHNhbWUgYWNyb3NzIGFsbCB0cmFuc2FjdGlvbnMgaW4gZ3JvdXAuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ4Ni00ODcKICAgIC8vICMgR2V0IHRoZSBmaXJzdCB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAKICAgIC8vIGZpcnN0X3R4biA9IGd0eG4uQXBwbGljYXRpb25DYWxsVHJhbnNhY3Rpb24oZ3JvdXBfaW5kZXg9MCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjQ5OAogICAgLy8gYXNzZXJ0IGZpcnN0X3R4bi5zZW5kZXIgPT0gVHhuLnNlbmRlciwgZXJyLlNFTkRFUl9NSVNNQVRDSAogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbmRlciBtaXNtYXRjaC4gU2VuZGVyIG11c3QgYmUgc2FtZSBhZGRyZXNzIGFjcm9zcyBhbGwgdHJhbnNhY3Rpb25zIGluIGdyb3VwLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0ODYtNDg3CiAgICAvLyAjIEdldCB0aGUgZmlyc3QgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwCiAgICAvLyBmaXJzdF90eG4gPSBndHhuLkFwcGxpY2F0aW9uQ2FsbFRyYW5zYWN0aW9uKGdyb3VwX2luZGV4PTApCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo0OTkKICAgIC8vIGFzc2VydCBmaXJzdF90eG4uYXBwX2FyZ3MoMCkgPT0gYXJjNC5hcmM0X3NpZ25hdHVyZSgKICAgIGR1cAogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDk5LTUwMQogICAgLy8gYXNzZXJ0IGZpcnN0X3R4bi5hcHBfYXJncygwKSA9PSBhcmM0LmFyYzRfc2lnbmF0dXJlKAogICAgLy8gICAgICJ1cF9yZWZfYnVkZ2V0X2Zvcl9wbGF5X2dhbWUodWludDY0KXZvaWQiCiAgICAvLyApLCBlcnIuSU5WQUxJRF9NRVRIT0RfU0VMRUNUT1IKICAgIGJ5dGVjIDkgLy8gbWV0aG9kICJ1cF9yZWZfYnVkZ2V0X2Zvcl9wbGF5X2dhbWUodWludDY0KXZvaWQiCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGF0IHRoaXMgZ3JvdXAgaW5kZXggbXVzdCBoYXZlIGV4YWN0IHJlcXVpcmVkIG1ldGhvZCBzZWxlY3Rvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NDg2LTQ4NwogICAgLy8gIyBHZXQgdGhlIGZpcnN0IHRyYW5zYWN0aW9uIGluIHRoZSBncm91cAogICAgLy8gZmlyc3RfdHhuID0gZ3R4bi5BcHBsaWNhdGlvbkNhbGxUcmFuc2FjdGlvbihncm91cF9pbmRleD0wKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTAzCiAgICAvLyBhc3NlcnQgZmlyc3RfdHhuLmFwcF9hcmdzKDEpID09IFR4bi5hcHBsaWNhdGlvbl9hcmdzKDEpLCBlcnIuSU5WQUxJRF9HQU1FX0lECiAgICBpbnRjXzEgLy8gMQogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIEdhbWUgSUQuIEJveCBHYW1lIFJlZ2lzdGVyIEdhbWUgSUQgbXVzdCBiZSBhIGNlcnRhaW4gdmFsdWUgb3IgbWF0Y2ggR2FtZSBJRCBhcmcuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUwNQogICAgLy8gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlcltUeG4uc2VuZGVyXS5nYW1lX2lkLm5hdGl2ZQogICAgYnl0ZWNfMCAvLyAicl8iCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyIGVudHJ5IGV4aXN0cwogICAgaW50Y18yIC8vIDIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUwNC01MDYKICAgIC8vIGFzc2VydCBmaXJzdF90eG4uYXBwX2FyZ3MoMSkgPT0gb3AuaXRvYigKICAgIC8vICAgICBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdLmdhbWVfaWQubmF0aXZlCiAgICAvLyApCiAgICBpdG9iCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUxMQogICAgLy8gYWNjb3VudD1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MTMKICAgIC8vIHBsYXllcl9jb3VudD1zZWxmLmJveF9nYW1lX3N0YXRlW2dhbWVfaWRdLm1heF9wbGF5ZXJzLm5hdGl2ZSwKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ib3hfZ2FtZV9zdGF0ZSBlbnRyeSBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICBnZXRieXRlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUwOS01MTUKICAgIC8vIHNydC5jaGVja19hY2NfaW5fZ2FtZSggICMgbm9xYTogRTcxMgogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PXNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0ubWF4X3BsYXllcnMubmF0aXZlLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1UcnVlLAogICAgLy8gKQogICAgZnJhbWVfZGlnIC0xCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTEyCiAgICAvLyBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIGJ5dGVjXzMgLy8gInBfIgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MDktNTE1CiAgICAvLyBzcnQuY2hlY2tfYWNjX2luX2dhbWUoICAjIG5vcWE6IEU3MTIKICAgIC8vICAgICBnYW1lX2lkPWdhbWVfaWQsCiAgICAvLyAgICAgYWNjb3VudD1UeG4uc2VuZGVyLAogICAgLy8gICAgIGJveF9nYW1lX3BsYXllcnM9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLAogICAgLy8gICAgIHBsYXllcl9jb3VudD1zZWxmLmJveF9nYW1lX3N0YXRlW2dhbWVfaWRdLm1heF9wbGF5ZXJzLm5hdGl2ZSwKICAgIC8vICAgICBjbGVhcl9wbGF5ZXI9VHJ1ZSwKICAgIC8vICkKICAgIHVuY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MTQKICAgIC8vIGNsZWFyX3BsYXllcj1UcnVlLAogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTA5LTUxNQogICAgLy8gc3J0LmNoZWNrX2FjY19pbl9nYW1lKCAgIyBub3FhOiBFNzEyCiAgICAvLyAgICAgZ2FtZV9pZD1nYW1lX2lkLAogICAgLy8gICAgIGFjY291bnQ9VHhuLnNlbmRlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICAgICBwbGF5ZXJfY291bnQ9c2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXS5tYXhfcGxheWVycy5uYXRpdmUsCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPVRydWUsCiAgICAvLyApCiAgICBjYWxsc3ViIGNoZWNrX2FjY19pbl9nYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUxNgogICAgLy8gPT0gVHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTA5LTUxNgogICAgLy8gc3J0LmNoZWNrX2FjY19pbl9nYW1lKCAgIyBub3FhOiBFNzEyCiAgICAvLyAgICAgZ2FtZV9pZD1nYW1lX2lkLAogICAgLy8gICAgIGFjY291bnQ9VHhuLnNlbmRlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICAgICBwbGF5ZXJfY291bnQ9c2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXS5tYXhfcGxheWVycy5uYXRpdmUsCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPVRydWUsCiAgICAvLyApCiAgICAvLyA9PSBUcnVlCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MDgtNTE3CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNydC5jaGVja19hY2NfaW5fZ2FtZSggICMgbm9xYTogRTcxMgogICAgLy8gICAgICAgICBnYW1lX2lkPWdhbWVfaWQsCiAgICAvLyAgICAgICAgIGFjY291bnQ9VHhuLnNlbmRlciwKICAgIC8vICAgICAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgICAgIHBsYXllcl9jb3VudD1zZWxmLmJveF9nYW1lX3N0YXRlW2dhbWVfaWRdLm1heF9wbGF5ZXJzLm5hdGl2ZSwKICAgIC8vICAgICAgICAgY2xlYXJfcGxheWVyPVRydWUsCiAgICAvLyAgICAgKQogICAgLy8gICAgID09IFRydWUKICAgIC8vICksIGVyci5QTEFZRVJfTk9UX0ZPVU5ECiAgICBhc3NlcnQgLy8gQWNjb3VudCBpcyBub3QgcmVjb2duaXplZCBhcyBhbiBhY3RpdmUgcGxheWVyIGZvciB0aGlzIGdhbWUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUxOS01MjIKICAgIC8vICMgUmV0cmlldmUgdGhlIGdhbWUgc3RhdGUgZGF0YSBmcm9tIGl0cyBjb3JyZXNwb25kaW5nIGJveCB1c2luZyB0aGUgZ2FtZSBpZCBwYXJhbWV0ZXIKICAgIC8vIGdhbWVfc3RhdGUgPSBzZWxmLmJveF9nYW1lX3N0YXRlWwogICAgLy8gICAgIGdhbWVfaWQKICAgIC8vIF0uY29weSgpICAjIE1ha2UgYSBjb3B5IG9mIHRoZSBnYW1lIHN0YXRlIGVsc2UgaW1tdXRhYmxlCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgNAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfc3RhdGUgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUyNC01MjUKICAgIC8vICMgUmV0cmlldmUgdGhlIGdhbWUgcmVnaXN0ZXIgZGF0YSBmcm9tIGl0cyBjb3JyZXNwb25kaW5nIGJveCB1c2luZyB0aGUgZ2FtZSBpZCBwYXJhbWV0ZXIKICAgIC8vIGdhbWVfcmVnaXN0ZXIgPSBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyWwogICAgYnl0ZWNfMCAvLyAicl8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUyNgogICAgLy8gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MjQtNTI3CiAgICAvLyAjIFJldHJpZXZlIHRoZSBnYW1lIHJlZ2lzdGVyIGRhdGEgZnJvbSBpdHMgY29ycmVzcG9uZGluZyBib3ggdXNpbmcgdGhlIGdhbWUgaWQgcGFyYW1ldGVyCiAgICAvLyBnYW1lX3JlZ2lzdGVyID0gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlclsKICAgIC8vICAgICBUeG4uc2VuZGVyCiAgICAvLyBdLmNvcHkoKSAgIyBNYWtlIGEgY29weSBvZiB0aGUgZ2FtZSBzdGF0ZSBlbHNlIGltbXV0YWJsZQogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MjktNTMwCiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb25zIGJlbG93IGV2YWx1YXRlIFRydWUKICAgIC8vIGFzc2VydCBnYW1lX3N0YXRlLnN0YWtpbmdfZmluYWxpemVkLm5hdGl2ZSwgZXJyLlNUQUtJTkdfRklOQUxfRkxBRwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYXNzZXJ0IC8vIEdhbWUgc3RhdGUgc3Rha2luZyBmaW5hbGl6ZWQgYm9vbGVhbiB2YWx1ZSBtaXNtYXRjaC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTMyCiAgICAvLyBnYW1lX3N0YXRlLmV4cGlyeV90cyA+PSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZXh0cmFjdCA5IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICBiPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTMxLTUzMwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBnYW1lX3N0YXRlLmV4cGlyeV90cyA+PSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgLy8gKSwgZXJyLlRJTUVfQ09OU1RSQUlOVF9WSU9MQVRJT04KICAgIGFzc2VydCAvLyBJbnZhbGlkIHRpbWUgZnJhbWUuIENhbGwgbWFkZSBvdXRzaWRlIHRoZSBwZXJtaXR0ZWQgYmxvY2sgb3IgdGltZXN0YW1wIHJhbmdlLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MzUKICAgIC8vIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbVHhuLnNlbmRlcl0uZ2FtZV9pZC5uYXRpdmUgPT0gZ2FtZV9pZAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyIGVudHJ5IGV4aXN0cwogICAgaW50Y18yIC8vIDIKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjUzNC01MzYKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5ib3hfZ2FtZV9yZWdpc3RlcltUeG4uc2VuZGVyXS5nYW1lX2lkLm5hdGl2ZSA9PSBnYW1lX2lkCiAgICAvLyApLCBlcnIuSU5WQUxJRF9HQU1FX0lECiAgICBhc3NlcnQgLy8gSW52YWxpZCBHYW1lIElELiBCb3ggR2FtZSBSZWdpc3RlciBHYW1lIElEIG11c3QgYmUgYSBjZXJ0YWluIHZhbHVlIG9yIG1hdGNoIEdhbWUgSUQgYXJnLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1MzgKICAgIC8vIEdsb2JhbC5yb3VuZCA+PSBzZWxmLmJveF9nYW1lX3JlZ2lzdGVyW1R4bi5zZW5kZXJdLmNvbW1pdF9yYW5kX3JvdW5kLm5hdGl2ZQogICAgZ2xvYmFsIFJvdW5kCiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTM3LTUzOQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBHbG9iYWwucm91bmQgPj0gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlcltUeG4uc2VuZGVyXS5jb21taXRfcmFuZF9yb3VuZC5uYXRpdmUKICAgIC8vICksIGVyci5DT01NSVRfUkFORF9ST1VORF9OT1RfUkVBQ0hFRAogICAgYXNzZXJ0IC8vIFJhbmRvbW5lc3MgY29tbWl0IHJvdW5kIG5vdCByZWFjaGVkIHlldC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTU0CiAgICAvLyBwbGF5ZXI9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2J1cnkgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1NTUKICAgIC8vIHNlZWQ9VHhuLnNlbmRlci5ieXRlcywgICMgTk9URTogSU1QT1JBTlQ6IFVzZSBWUkYgb3V0cHV0IGFzIHNlZWQgb3V0c2lkZSBMb2NhbE5ldCBlbnYKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTQzLTE0NAogICAgLy8gIyBJbml0aWFsaXplIHRoZSBQQ0cgcHNldWRvLXJhbmRvbSBnZW5lcmF0b3Igc3RhdGUgdXNpbmcgOCBieXRlcyBmcm9tIHRoZSBnaXZlbiBzZWVkCiAgICAvLyBzdGF0ZSA9IHBjZzE2X2luaXQoc2VlZD1vcC5leHRyYWN0KHNlZWQsIDE2LCA4KSkKICAgIGR1cAogICAgZXh0cmFjdCAxNiA4CiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIxCiAgICAvLyBhc3NlcnQgc2VlZC5sZW5ndGggPT0gOAogICAgbGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPT0KICAgIGFzc2VydAogICAgcHVzaGludCAxNiAvLyAxNgogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyMwogICAgLy8gcmV0dXJuIF9fcGNnMzJfaW5pdChvcC5idG9pKHNlZWQpLCBVSW50NjQoUENHX0ZJUlNUX0lOQ1JFTUVOVCkpCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToxNTUKICAgIC8vIHN0YXRlID0gX19wY2czMl9zdGVwKFVJbnQ2NCgwKSwgaW5jcikKICAgIGludGNfMCAvLyAwCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI2OQogICAgLy8gX2hpZ2hfbXVsLCBsb3dfbXVsID0gb3AubXVsdyhzdGF0ZSwgUENHX01VTFRJUExJRVIpCiAgICBpbnRjIDggLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIzCiAgICAvLyByZXR1cm4gX19wY2czMl9pbml0KG9wLmJ0b2koc2VlZCksIFVJbnQ2NChQQ0dfRklSU1RfSU5DUkVNRU5UKSkKICAgIGludGMgOSAvLyAxNDQyNjk1MDQwODg4OTYzNDA3CiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI3MAogICAgLy8gX2hpZ2hfYWRkLCBsb3dfYWRkID0gb3AuYWRkdyhsb3dfbXVsLCBpbmNyKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjE1NgogICAgLy8gX2hpZ2hfYWRkdywgc3RhdGUgPSBvcC5hZGR3KHN0YXRlLCBpbml0aWFsX3N0YXRlKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI2OQogICAgLy8gX2hpZ2hfbXVsLCBsb3dfbXVsID0gb3AubXVsdyhzdGF0ZSwgUENHX01VTFRJUExJRVIpCiAgICBpbnRjIDggLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIzCiAgICAvLyByZXR1cm4gX19wY2czMl9pbml0KG9wLmJ0b2koc2VlZCksIFVJbnQ2NChQQ0dfRklSU1RfSU5DUkVNRU5UKSkKICAgIGludGMgOSAvLyAxNDQyNjk1MDQwODg4OTYzNDA3CiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI3MAogICAgLy8gX2hpZ2hfYWRkLCBsb3dfYWRkID0gb3AuYWRkdyhsb3dfbXVsLCBpbmNyKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjE5OAogICAgLy8gcmVzdWx0ICs9IGFyYzQuVUludDE2KGxlbmd0aCkuYnl0ZXMKICAgIHB1c2hieXRlcyAweDAwZmYKICAgIGZyYW1lX2J1cnkgOQogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyOTIKICAgIC8vIF9hZGR3X2hpZ2gsIGFkZHdfbG93ID0gb3AuYWRkdyh+dmFsdWUsIDEpCiAgICBwdXNoaW50IDE4NDQ2NzQ0MDczNzA5NDg2MDgwIC8vIDE4NDQ2NzQ0MDczNzA5NDg2MDgwCiAgICBpbnRjXzEgLy8gMQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjMwMAogICAgLy8gcmV0dXJuIHZhbHVlICYgKCgxIDw8IDMyKSAtIDEpCiAgICBpbnRjIDEwIC8vIDQyOTQ5NjcyOTUKICAgICYKICAgIC8vIC52ZW52L0xpYi9zaXRlLXBhY2thZ2VzL2xpYl9wY2cvcGNnMzIucHk6MjE5CiAgICAvLyBhYnNvbHV0ZV9ib3VuZCA9ICgxIDw8IGJpdF9zaXplKSAtIGxvd2VyX2JvdW5kCiAgICBpbnRjIDEyIC8vIDY1NTM1CiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIyMQogICAgLy8gdGhyZXNob2xkID0gX19tYXNrX3RvX3VpbnQzMihfX3VpbnQ2NF90d29zKGFic29sdXRlX2JvdW5kKSkgJSBhYnNvbHV0ZV9ib3VuZAogICAgJQogICAgZnJhbWVfYnVyeSAxNgogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyMjMKICAgIC8vIGZvciBpIGluIHVyYW5nZShsZW5ndGgpOiAgIyBub3FhOiBCMDA3CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxMwogICAgZnJhbWVfYnVyeSAxNQoKcGxheV9nYW1lX2Zvcl9oZWFkZXJAMjA6CiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIyMwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKGxlbmd0aCk6ICAjIG5vcWE6IEIwMDcKICAgIGZyYW1lX2RpZyAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxNTEKICAgIC8vIGxlbmd0aD1VSW50NjQoMjU1KSwgICMgTnVtYmVyIG9mIHZhbHVlcyBnZW5lcmF0ZWQgaXMgMjU1CiAgICBwdXNoaW50IDI1NSAvLyAyNTUKICAgIC8vIC52ZW52L0xpYi9zaXRlLXBhY2thZ2VzL2xpYl9wY2cvcGNnMzIucHk6MjIzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UobGVuZ3RoKTogICMgbm9xYTogQjAwNwogICAgPAogICAgYnogcGxheV9nYW1lX2FmdGVyX2ZvckAyNQoKcGxheV9nYW1lX3doaWxlX3RvcEAyMjoKICAgIC8vIC52ZW52L0xpYi9zaXRlLXBhY2thZ2VzL2xpYl9wY2cvcGNnMzIucHk6MjY5CiAgICAvLyBfaGlnaF9tdWwsIGxvd19tdWwgPSBvcC5tdWx3KHN0YXRlLCBQQ0dfTVVMVElQTElFUikKICAgIGZyYW1lX2RpZyAxNQogICAgZHVwCiAgICBpbnRjIDggLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI1NAogICAgLy8gcmV0dXJuIF9fcGNnMzJfc3RlcChzdGF0ZSwgVUludDY0KFBDR19GSVJTVF9JTkNSRU1FTlQpKSwgX19wY2czMl9vdXRwdXQoc3RhdGUpCiAgICBpbnRjIDkgLy8gMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyNzAKICAgIC8vIF9oaWdoX2FkZCwgbG93X2FkZCA9IG9wLmFkZHcobG93X211bCwgaW5jcikKICAgIGFkZHcKICAgIGNvdmVyIDIKICAgIHBvcAogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyNzkKICAgIC8vIF9fbWFza190b191aW50MzIoKChzdGF0ZSA+PiAxOCkgXiBzdGF0ZSkgPj4gMjcpLCBzdGF0ZSA+PiA1OQogICAgZHVwCiAgICBwdXNoaW50IDE4IC8vIDE4CiAgICBzaHIKICAgIGRpZyAxCiAgICBeCiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBzaHIKICAgIC8vIC52ZW52L0xpYi9zaXRlLXBhY2thZ2VzL2xpYl9wY2cvcGNnMzIucHk6MzAwCiAgICAvLyByZXR1cm4gdmFsdWUgJiAoKDEgPDwgMzIpIC0gMSkKICAgIGludGMgMTAgLy8gNDI5NDk2NzI5NQogICAgJgogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyNzkKICAgIC8vIF9fbWFza190b191aW50MzIoKChzdGF0ZSA+PiAxOCkgXiBzdGF0ZSkgPj4gMjcpLCBzdGF0ZSA+PiA1OQogICAgc3dhcAogICAgcHVzaGludCA1OSAvLyA1OQogICAgc2hyCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI4NgogICAgLy8gcmV0dXJuICh2YWx1ZSA+PiByb3QpIHwgX19tYXNrX3RvX3VpbnQzMih2YWx1ZSA8PCAoX191aW50NjRfdHdvcyhyb3QpICYgMzEpKQogICAgZHVwMgogICAgc2hyCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI5MgogICAgLy8gX2FkZHdfaGlnaCwgYWRkd19sb3cgPSBvcC5hZGR3KH52YWx1ZSwgMSkKICAgIHN3YXAKICAgIH4KICAgIGludGNfMSAvLyAxCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIC52ZW52L0xpYi9zaXRlLXBhY2thZ2VzL2xpYl9wY2cvcGNnMzIucHk6Mjg2CiAgICAvLyByZXR1cm4gKHZhbHVlID4+IHJvdCkgfCBfX21hc2tfdG9fdWludDMyKHZhbHVlIDw8IChfX3VpbnQ2NF90d29zKHJvdCkgJiAzMSkpCiAgICBwdXNoaW50IDMxIC8vIDMxCiAgICAmCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIHNobAogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weTozMDAKICAgIC8vIHJldHVybiB2YWx1ZSAmICgoMSA8PCAzMikgLSAxKQogICAgaW50YyAxMCAvLyA0Mjk0OTY3Mjk1CiAgICAmCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjI4NgogICAgLy8gcmV0dXJuICh2YWx1ZSA+PiByb3QpIHwgX19tYXNrX3RvX3VpbnQzMih2YWx1ZSA8PCAoX191aW50NjRfdHdvcyhyb3QpICYgMzEpKQogICAgfAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEyCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIyNgogICAgLy8gaWYgY2FuZGlkYXRlID49IHRocmVzaG9sZDoKICAgIGZyYW1lX2RpZyAxNgogICAgPj0KICAgIGJ6IHBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDI0CiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIyOAogICAgLy8gb3AuaXRvYigoY2FuZGlkYXRlICUgYWJzb2x1dGVfYm91bmQpICsgbG93ZXJfYm91bmQpLAogICAgZnJhbWVfZGlnIDEyCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIxOQogICAgLy8gYWJzb2x1dGVfYm91bmQgPSAoMSA8PCBiaXRfc2l6ZSkgLSBsb3dlcl9ib3VuZAogICAgaW50YyAxMiAvLyA2NTUzNQogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyMjgKICAgIC8vIG9wLml0b2IoKGNhbmRpZGF0ZSAlIGFic29sdXRlX2JvdW5kKSArIGxvd2VyX2JvdW5kKSwKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTQ5CiAgICAvLyBsb3dlcl9ib3VuZD1VSW50NjQoMSksICAjIExvd2VyIGJvdW5kIGlzIDEgKHRvIGRpc2FsbG93IDAgYXMgYSB2YWx1ZSkKICAgIGludGNfMSAvLyAxCiAgICAvLyAudmVudi9MaWIvc2l0ZS1wYWNrYWdlcy9saWJfcGNnL3BjZzMyLnB5OjIyOAogICAgLy8gb3AuaXRvYigoY2FuZGlkYXRlICUgYWJzb2x1dGVfYm91bmQpICsgbG93ZXJfYm91bmQpLAogICAgKwogICAgaXRvYgogICAgLy8gLnZlbnYvTGliL3NpdGUtcGFja2FnZXMvbGliX3BjZy9wY2czMi5weToyMjctMjMxCiAgICAvLyByZXN1bHQgKz0gb3AuZXh0cmFjdCgKICAgIC8vICAgICBvcC5pdG9iKChjYW5kaWRhdGUgJSBhYnNvbHV0ZV9ib3VuZCkgKyBsb3dlcl9ib3VuZCksCiAgICAvLyAgICAgdHJ1bmNhdGVfc3RhcnRfY2FjaGVkLAogICAgLy8gICAgIGJ5dGVfc2l6ZSwKICAgIC8vICkKICAgIGV4dHJhY3QgNiAyCiAgICBmcmFtZV9kaWcgOQogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDkKICAgIC8vIC52ZW52L0xpYi9zaXRlLXBhY2thZ2VzL2xpYl9wY2cvcGNnMzIucHk6MjIzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UobGVuZ3RoKTogICMgbm9xYTogQjAwNwogICAgZnJhbWVfZGlnIDEzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAxMwogICAgZnJhbWVfYnVyeSAxNQogICAgYiBwbGF5X2dhbWVfZm9yX2hlYWRlckAyMAoKcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMjQ6CiAgICBmcmFtZV9idXJ5IDE1CiAgICBiIHBsYXlfZ2FtZV93aGlsZV90b3BAMjIKCnBsYXlfZ2FtZV9hZnRlcl9mb3JAMjU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE1NC0xNTUKICAgIC8vICMgSW5pdGlhbGl6ZSB0aGUgcGxheWVyJ3Mgc2NvcmUKICAgIC8vIHNjb3JlID0gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxNTctMTU4CiAgICAvLyAjIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc2VxdWVuY2UgYXMgYSBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IGJ5dGUgaW5kZXggMiAoc2tpcCBhcnJheSBoZWFkZXIgYnl0ZXMpCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMiwgc2VxdWVuY2UuYnl0ZXMubGVuZ3RoLCAyKToKICAgIGZyYW1lX2RpZyA5CiAgICBsZW4KICAgIGZyYW1lX2J1cnkgMTcKICAgIGludGNfMiAvLyAyCiAgICBmcmFtZV9idXJ5IDEzCgpwbGF5X2dhbWVfZm9yX2hlYWRlckAyNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTU3LTE1OAogICAgLy8gIyBJdGVyYXRlIHRocm91Z2ggdGhlIHNlcXVlbmNlIGFzIGEgYnl0ZSBhcnJheSBzdGFydGluZyBhdCBieXRlIGluZGV4IDIgKHNraXAgYXJyYXkgaGVhZGVyIGJ5dGVzKQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKDIsIHNlcXVlbmNlLmJ5dGVzLmxlbmd0aCwgMik6CiAgICBmcmFtZV9kaWcgMTMKICAgIGZyYW1lX2RpZyAxNwogICAgPAogICAgYnogcGxheV9nYW1lX2FmdGVyX2ZvckAzMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxNTktMTYwCiAgICAvLyAjIEV4dHJhY3QgYSAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciBmcm9tIHRoZSBieXRlIHNlcXVlbmNlCiAgICAvLyByb2xsID0gb3AuZXh0cmFjdF91aW50MTYoc2VxdWVuY2UuYnl0ZXNbMjpdLCBpKQogICAgaW50Y18yIC8vIDIKICAgIGZyYW1lX2RpZyAxNwogICAgZHVwCiAgICBjb3ZlciAyCiAgICA+PQogICAgaW50Y18yIC8vIDIKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgZnJhbWVfZGlnIDkKICAgIHN3YXAKICAgIHVuY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgZnJhbWVfZGlnIDEzCiAgICBleHRyYWN0X3VpbnQxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxNjItMTYzCiAgICAvLyAjIFN0b3AgYWNjdW11bGF0aW5nIHNjb3JlIGlmIHRoZSByb2xsIGlzIGJlbG93IG9yIGVxdWFsIHRvIHRoZSBlbGltaW5hdGlvbiB0aHJlc2hvbGQKICAgIC8vIGlmIHJvbGwgPD0gY3N0LkVMSU1fVEhSRVNIT0xEOgogICAgcHVzaGludCAxMDk5MiAvLyAxMDk5MgogICAgPD0KICAgIGJueiBwbGF5X2dhbWVfYWZ0ZXJfZm9yQDMwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE2Ni0xNjcKICAgIC8vICMgSW5jcmVtZW50IHNjb3JlIGZvciBlYWNoIHJvbGwgYWJvdmUgdGhlIHRocmVzaG9sZAogICAgLy8gc2NvcmUgKz0gMQogICAgZnJhbWVfZGlnIDE0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxNTctMTU4CiAgICAvLyAjIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc2VxdWVuY2UgYXMgYSBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IGJ5dGUgaW5kZXggMiAoc2tpcCBhcnJheSBoZWFkZXIgYnl0ZXMpCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoMiwgc2VxdWVuY2UuYnl0ZXMubGVuZ3RoLCAyKToKICAgIGZyYW1lX2RpZyAxMwogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGZyYW1lX2J1cnkgMTMKICAgIGIgcGxheV9nYW1lX2Zvcl9oZWFkZXJAMjcKCnBsYXlfZ2FtZV9hZnRlcl9mb3JAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE3NAogICAgLy8gYXJjNC5VSW50OChzY29yZSksCiAgICBmcmFtZV9kaWcgMTQKICAgIGR1cAogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE2OS0xNzUKICAgIC8vICMgRW1pdCBBUkMtMjggZXZlbnQgZm9yIG9mZi1jaGFpbiB0cmFja2luZwogICAgLy8gYXJjNC5lbWl0KAogICAgLy8gICAgICJwbGF5ZXJfc2NvcmUodWludDY0LGFkZHJlc3MsdWludDgpIiwKICAgIC8vICAgICBnYW1lX2lkLAogICAgLy8gICAgIHBsYXllciwKICAgIC8vICAgICBhcmM0LlVJbnQ4KHNjb3JlKSwKICAgIC8vICkKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgNwogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweGRlMjI0NGQ2IC8vIG1ldGhvZCAicGxheWVyX3Njb3JlKHVpbnQ2NCxhZGRyZXNzLHVpbnQ4KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE3Ny0xNzgKICAgIC8vICMgQ2hlY2sgaWYgc2NvcmUgaXMgZ3JlYXRlciB0aGFuIHRoZSBnYW1lIHN0YXRlJ3MgdG9wIHNjb3JlCiAgICAvLyBpZiBzY29yZSA+IGdhbWVfc3RhdGUudG9wX3Njb3JlLm5hdGl2ZToKICAgIGZyYW1lX2RpZyA0CiAgICBkdXAKICAgIHB1c2hpbnQgNiAvLyA2CiAgICBnZXRieXRlCiAgICB1bmNvdmVyIDIKICAgIDwKICAgIHN3YXAKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICBmcmFtZV9idXJ5IDUKICAgIGJ6IHBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE3OQogICAgLy8gZ2FtZV9zdGF0ZS50b3Bfc2NvcmUgPSBhcmM0LlVJbnQ4KHNjb3JlKSAgIyBVcGRhdGUgdG9wIHNjb3JlCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIDEwCiAgICByZXBsYWNlMiA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE4MAogICAgLy8gZ2FtZV9zdGF0ZS50b3BzY29yZXJfYWRkcmVzcyA9IGFyYzQuQWRkcmVzcyhwbGF5ZXIpICAjIFVwZGF0ZSB0b3BzY29yZXIgYWRkcmVzcwogICAgZnJhbWVfZGlnIDcKICAgIHJlcGxhY2UyIDE1MwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDYKICAgIGZyYW1lX2J1cnkgNQoKcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMzI6CiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE4Mi0xODMKICAgIC8vICMgQ2hlY2sgaWYgc2NvcmUgaXMgZ3JlYXRlciB0aGFuIHRoZSBnYW1lIHJlZ2lzdGVyIGFjY291bnQncyBiZXN0IHNjb3JlIGFjcm9zcyBldmVyeSBnYW1lIHBsYXllZAogICAgLy8gaWYgc2NvcmUgPiBnYW1lX3JlZ2lzdGVyLmJlc3Rfc2NvcmUubmF0aXZlOgogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgIGdldGJ5dGUKICAgIGZyYW1lX2RpZyAxNAogICAgPAogICAgc3dhcAogICAgZnJhbWVfYnVyeSAzCiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAzNAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxODQKICAgIC8vIGdhbWVfcmVnaXN0ZXIuYmVzdF9zY29yZSA9IGFyYzQuVUludDgoc2NvcmUpICAjIFVwZGF0ZSBwZXJzb25hbCB0b3Agc2NvcmUKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgMTAKICAgIHJlcGxhY2UyIDEKICAgIGZyYW1lX2J1cnkgMwoKcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMzQ6CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE4OC0xODkKICAgIC8vICMgRmlyc3QgUGxhY2UKICAgIC8vIGdhbWVfc3RhdGUuZmlyc3RfcGxhY2VfYWRkcmVzcyA9PSBhcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcykKICAgIGZyYW1lX2RpZyA0CiAgICBleHRyYWN0IDU3IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxODgtMTkwCiAgICAvLyAjIEZpcnN0IFBsYWNlCiAgICAvLyBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX2FkZHJlc3MgPT0gYXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpCiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUuZmlyc3RfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBibnogcGxheV9nYW1lX2lmX2JvZHlAMzYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTkwCiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUuZmlyc3RfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBmcmFtZV9kaWcgNAogICAgcHVzaGludCAzIC8vIDMKICAgIGdldGJ5dGUKICAgIGZyYW1lX2RpZyAxNAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxODgtMTkwCiAgICAvLyAjIEZpcnN0IFBsYWNlCiAgICAvLyBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX2FkZHJlc3MgPT0gYXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpCiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUuZmlyc3RfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBieiBwbGF5X2dhbWVfZWxzZV9ib2R5QDM3CgpwbGF5X2dhbWVfaWZfYm9keUAzNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTkyLTE5MwogICAgLy8gIyBBc3NpZ246IFNlY29uZCAtPiBUaGlyZAogICAgLy8gZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9zY29yZSA9IGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX3Njb3JlCiAgICBmcmFtZV9kaWcgNAogICAgZHVwCiAgICBleHRyYWN0IDQgMSAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHJlcGxhY2UyIDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTk0CiAgICAvLyBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MgPSBnYW1lX3N0YXRlLnNlY29uZF9wbGFjZV9hZGRyZXNzCiAgICBkdXAKICAgIGV4dHJhY3QgODkgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICByZXBsYWNlMiAxMjEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MTk1LTE5NgogICAgLy8gIyBBc3NpZ246IEZpcnN0IC0+IFNlY29uZAogICAgLy8gZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2Vfc2NvcmUgPSBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX3Njb3JlCiAgICBkdXAKICAgIGV4dHJhY3QgMyAxIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgcmVwbGFjZTIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToxOTcKICAgIC8vIGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX2FkZHJlc3MgPSBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX2FkZHJlc3MKICAgIGR1cAogICAgZXh0cmFjdCA1NyAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHJlcGxhY2UyIDg5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjE5OC0xOTkKICAgIC8vICMgQXNzaWduOiBTY29yZSAtPiBGaXJzdAogICAgLy8gZ2FtZV9zdGF0ZS5maXJzdF9wbGFjZV9zY29yZSA9IGFyYzQuVUludDgoc2NvcmUpCiAgICBmcmFtZV9kaWcgMTAKICAgIHJlcGxhY2UyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjAwCiAgICAvLyBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX2FkZHJlc3MgPSBhcmM0LkFkZHJlc3MocGxheWVyKQogICAgZnJhbWVfZGlnIDcKICAgIHJlcGxhY2UyIDU3CiAgICBmcmFtZV9idXJ5IDQKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDQ1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1NTgtNTU5CiAgICAvLyAjIElmIGdhbWUgc3RhdGUgZmlyc3QgcGxhY2Ugc2NvcmUgaXMgaGlnaGVyIHRoYW4gYXRoIHNjb3JlCiAgICAvLyBpZiBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX3Njb3JlID4gc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXRoX3Njb3JlOgogICAgZnJhbWVfZGlnIDQKICAgIGV4dHJhY3QgMyAxIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDgKICAgIGJ5dGVjXzIgLy8gInRfIgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfdHJvcGh5IGV4aXN0cwogICAgZXh0cmFjdCA4IDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBiPgogICAgYnogcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VANwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1NjAtNTYxCiAgICAvLyAjIFVwZGF0ZSBhdGggc2NvcmUsIGdhbWUgc3RhdGUgZmlyc3QgcGxhY2Ugc2NvcmUgaXMgdGhlIGF0aCBzY29yZQogICAgLy8gc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXRoX3Njb3JlID0gZ2FtZV9zdGF0ZS5maXJzdF9wbGFjZV9zY29yZQogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ib3hfZ2FtZV90cm9waHkgZXhpc3RzCiAgICBmcmFtZV9kaWcgOAogICAgcmVwbGFjZTIgOAogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBkaWcgMQogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1NjMtNTY0CiAgICAvLyAjIElmIGF0aCBhZGRyZXNzIGlzIG5vdCBlbXB0eQogICAgLy8gaWYgc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXRoX2FkZHJlc3MubmF0aXZlICE9IEdsb2JhbC56ZXJvX2FkZHJlc3M6CiAgICBleHRyYWN0IDkgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjU2NwogICAgLy8gc2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXRoX2FkZHJlc3MubmF0aXZlLAogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ib3hfZ2FtZV90cm9waHkgZXhpc3RzCiAgICBkdXAKICAgIGV4dHJhY3QgOSAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTY4CiAgICAvLyBzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZS5hc3NldF9pZC5uYXRpdmUsCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTY1LTU2OQogICAgLy8gIyBVc2UgYm94IGdhbWUgdHJvcGh5IGRhdGEgdG8gY2hlY2sgYWNjb3VudCBhc3NldCBiYWxhbmNlIGZvciB0cm9waHkKICAgIC8vIGFzc2V0X2JhbGFuY2UsIGFzc2V0X2V4aXN0cyA9IG9wLkFzc2V0SG9sZGluZ0dldC5hc3NldF9iYWxhbmNlKAogICAgLy8gICAgIHNlbGYuYm94X2dhbWVfdHJvcGh5LnZhbHVlLmF0aF9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZS5hc3NldF9pZC5uYXRpdmUsCiAgICAvLyApCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTcxLTU3MgogICAgLy8gIyBJZiBhc3NldCBleGlzdHMgYW5kIGl0cyBiYWxhbmNlIGlzIDEsIHBlcmZvcm0gY2xhd2JhY2sgdmlhIGFzc2V0IHRyYW5zZmVyIGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyBpZiBhc3NldF9leGlzdHMgYW5kIGFzc2V0X2JhbGFuY2UgPT0gMToKICAgIGJ6IHBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDYKICAgIGZyYW1lX2RpZyAxMQogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjU3NAogICAgLy8gYXNzZXRfaWQ9c2VsZi5ib3hfZ2FtZV90cm9waHkudmFsdWUuYXNzZXRfaWQubmF0aXZlLAogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ib3hfZ2FtZV90cm9waHkgZXhpc3RzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1NzUKICAgIC8vIGFzc2V0X3NlbmRlcj1zZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZS5hdGhfYWRkcmVzcy5uYXRpdmUsCiAgICBzd2FwCiAgICBleHRyYWN0IDkgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjU3NgogICAgLy8gYXNzZXRfcmVjZWl2ZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjQzLTQ5CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9YXNzZXRfcmVjZWl2ZXIsCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9zZW5kZXI9YXNzZXRfc2VuZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0xLAogICAgLy8gICAgIG5vdGU9bm90ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTc3LTU3OQogICAgLy8gbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgJ3BpZW91dDpqeyJtZXRob2QiOiJwbGF5X2dhbWUiLCJzdWJyb3V0aW5lOiJjbGF3YmFja19pdHhuIiwiY29uY2VybiI6Iml0eG4uYXNzZXRfdHJhbnNmZXI7Y2xhd2JhY2tfdHJvcGh5X2Fzc2V0In0nCiAgICAvLyApLAogICAgcHVzaGJ5dGVzICJwaWVvdXQ6antcIm1ldGhvZFwiOlwicGxheV9nYW1lXCIsXCJzdWJyb3V0aW5lOlwiY2xhd2JhY2tfaXR4blwiLFwiY29uY2VyblwiOlwiaXR4bi5hc3NldF90cmFuc2ZlcjtjbGF3YmFja190cm9waHlfYXNzZXRcIn0iCiAgICBpdHhuX2ZpZWxkIE5vdGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6NDcKICAgIC8vIGFzc2V0X2Ftb3VudD0xLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBc3NldFNlbmRlcgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6NDMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjQzLTQ5CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9YXNzZXRfcmVjZWl2ZXIsCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9zZW5kZXI9YXNzZXRfc2VuZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0xLAogICAgLy8gICAgIG5vdGU9bm90ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1ODItNTgzCiAgICAvLyAjIFVwZGF0ZSBhdGggYWRkcmVzcywgdHJhbnNhY3Rpb24gc2VuZGVyIGlzIHRoZSBuZXcgYXRoIGFkZHJlc3MKICAgIC8vIHNlbGYuYm94X2dhbWVfdHJvcGh5LnZhbHVlLmF0aF9hZGRyZXNzID0gYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpCiAgICBieXRlY18yIC8vICJ0XyIKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3Ryb3BoeSBleGlzdHMKICAgIHR4biBTZW5kZXIKICAgIHJlcGxhY2UyIDkKICAgIGJ5dGVjXzIgLy8gInRfIgogICAgc3dhcAogICAgYm94X3B1dAoKcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTg1LTU4NgogICAgLy8gIyBEZWNyZW1lbnQgbnVtYmVyIG9mIGFjdGl2ZSBwbGF5ZXJzIGJ5IDEKICAgIC8vIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMgPSBhcmM0LlVJbnQ4KGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMubmF0aXZlIC0gMSkKICAgIGZyYW1lX2RpZyA0CiAgICBkdXAKICAgIGludGNfMiAvLyAyCiAgICBnZXRieXRlCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgcmVwbGFjZTIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1ODgtNTg5CiAgICAvLyAjIFJlc2V0IGdhbWUgY29tbWl0IHZhbHVlcyBpbiBnYW1lIHJlZ2lzdGVyIGJveCBhZnRlciBzY29yZSBpcyBvYnRhaW5lZAogICAgLy8gZ2FtZV9yZWdpc3Rlci5nYW1lX2lkID0gYXJjNC5VSW50NjQoMCkKICAgIGZyYW1lX2RpZyAyCiAgICBieXRlYyA2IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgcmVwbGFjZTIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1OTAKICAgIC8vIGdhbWVfcmVnaXN0ZXIuY29tbWl0X3JhbmRfcm91bmQgPSBhcmM0LlVJbnQ2NCgwKQogICAgYnl0ZWMgNiAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIHJlcGxhY2UyIDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjU5MgogICAgLy8gR2xvYmFsLnJvdW5kICsgVUludDY0KGNzdC5CT1hfUl9FWFBfUk9VTkRfREVMVEEpCiAgICBnbG9iYWwgUm91bmQKICAgIGludGMgNiAvLyAxNTAwMDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NTkxLTU5MwogICAgLy8gZ2FtZV9yZWdpc3Rlci5leHBpcnlfcm91bmQgPSBhcmM0LlVJbnQ2NCgKICAgIC8vICAgICBHbG9iYWwucm91bmQgKyBVSW50NjQoY3N0LkJPWF9SX0VYUF9ST1VORF9ERUxUQSkKICAgIC8vICkKICAgIGl0b2IKICAgIHJlcGxhY2UyIDE4CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjU5NS01OTYKICAgIC8vICMgVXBkYXRlIHRoZSBnYW1lIHJlZ2lzdGVyIGJveCBkYXRhIHdpdGggYSBjb3B5IGNvbnRhaW5pbmcgaXRzIG1vZGlmaWVkIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV9yZWdpc3RlcltUeG4uc2VuZGVyXSA9IGdhbWVfcmVnaXN0ZXIuY29weSgpCiAgICBieXRlY18wIC8vICJyXyIKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1OTgtNjA0CiAgICAvLyAjIENoZWNrIGlmIGdhbWUgaXMgb3ZlciBvbiBldmVyeSBjYWxsCiAgICAvLyBzcnQuaXNfZ2FtZV9vdmVyKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUsCiAgICAvLyAgICAgYm94X2dhbWVfcmVnaXN0ZXI9c2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MDIKICAgIC8vIGJveF9nYW1lX3JlZ2lzdGVyPXNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsCiAgICBieXRlY18wIC8vICJyXyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjAzCiAgICAvLyBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIGJ5dGVjXzMgLy8gInBfIgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo1OTgtNjA0CiAgICAvLyAjIENoZWNrIGlmIGdhbWUgaXMgb3ZlciBvbiBldmVyeSBjYWxsCiAgICAvLyBzcnQuaXNfZ2FtZV9vdmVyKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUsCiAgICAvLyAgICAgYm94X2dhbWVfcmVnaXN0ZXI9c2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICkKICAgIGNhbGxzdWIgaXNfZ2FtZV9vdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYwNi02MDcKICAgIC8vICMgVXBkYXRlIHRoZSBnYW1lIHN0YXRlIGJveCBkYXRhIHdpdGggYSBjb3B5IGNvbnRhaW5pbmcgaXRzIG1vZGlmaWVkIHZhbHVlcwogICAgLy8gc2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXSA9IGdhbWVfc3RhdGUuY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpwbGF5X2dhbWVfZWxzZV9ib2R5QDM3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMDItMjAzCiAgICAvLyAjIFNlY29uZCBQbGFjZQogICAgLy8gZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2VfYWRkcmVzcyA9PSBhcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcykKICAgIGZyYW1lX2RpZyA0CiAgICBleHRyYWN0IDg5IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMDItMjA0CiAgICAvLyAjIFNlY29uZCBQbGFjZQogICAgLy8gZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2VfYWRkcmVzcyA9PSBhcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcykKICAgIC8vIG9yIHNjb3JlID4gZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBibnogcGxheV9nYW1lX2lmX2JvZHlAMzkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjA0CiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX3Njb3JlLm5hdGl2ZQogICAgZnJhbWVfZGlnIDQKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBnZXRieXRlCiAgICBmcmFtZV9kaWcgMTQKICAgIDwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjAyLTIwNAogICAgLy8gIyBTZWNvbmQgUGxhY2UKICAgIC8vIGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX2FkZHJlc3MgPT0gYXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpCiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX3Njb3JlLm5hdGl2ZQogICAgYnogcGxheV9nYW1lX2Vsc2VfYm9keUA0MAoKcGxheV9nYW1lX2lmX2JvZHlAMzk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIwNi0yMDcKICAgIC8vICMgQXNzaWduOiBTZWNvbmQgLT4gVGhpcmQKICAgIC8vIGdhbWVfc3RhdGUudGhpcmRfcGxhY2Vfc2NvcmUgPSBnYW1lX3N0YXRlLnNlY29uZF9wbGFjZV9zY29yZQogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgZXh0cmFjdCA0IDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICByZXBsYWNlMiA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIwOAogICAgLy8gZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9hZGRyZXNzID0gZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2VfYWRkcmVzcwogICAgZHVwCiAgICBleHRyYWN0IDg5IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgcmVwbGFjZTIgMTIxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIwOS0yMTAKICAgIC8vICMgQXNzaWduOiBTY29yZSAtPiBTZWNvbmQKICAgIC8vIGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX3Njb3JlID0gYXJjNC5VSW50OChzY29yZSkKICAgIGZyYW1lX2RpZyAxMAogICAgcmVwbGFjZTIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMTEKICAgIC8vIGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX2FkZHJlc3MgPSBhcmM0LkFkZHJlc3MocGxheWVyKQogICAgZnJhbWVfZGlnIDcKICAgIHJlcGxhY2UyIDg5CiAgICBmcmFtZV9idXJ5IDYKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDQ0OgogICAgZnJhbWVfZGlnIDYKICAgIGZyYW1lX2J1cnkgNAogICAgYiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUA0NQoKcGxheV9nYW1lX2Vsc2VfYm9keUA0MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjEzLTIxNAogICAgLy8gIyBUaGlyZCBQbGFjZQogICAgLy8gZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9hZGRyZXNzID09IGFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKQogICAgZnJhbWVfZGlnIDQKICAgIGV4dHJhY3QgMTIxIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMTMtMjE1CiAgICAvLyAjIFRoaXJkIFBsYWNlCiAgICAvLyBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MgPT0gYXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpCiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUudGhpcmRfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBibnogcGxheV9nYW1lX2lmX2JvZHlANDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjE1CiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUudGhpcmRfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBmcmFtZV9kaWcgNAogICAgcHVzaGludCA1IC8vIDUKICAgIGdldGJ5dGUKICAgIGZyYW1lX2RpZyAxNAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyMTMtMjE1CiAgICAvLyAjIFRoaXJkIFBsYWNlCiAgICAvLyBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MgPT0gYXJjNC5BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpCiAgICAvLyBvciBzY29yZSA+IGdhbWVfc3RhdGUudGhpcmRfcGxhY2Vfc2NvcmUubmF0aXZlCiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUA0NAoKcGxheV9nYW1lX2lmX2JvZHlANDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIxNy0yMTgKICAgIC8vICMgQXNzaWduOiBTY29yZSAtPiBUaGlyZAogICAgLy8gZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9zY29yZSA9IGFyYzQuVUludDgoc2NvcmUpCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIDEwCiAgICByZXBsYWNlMiA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjIxOQogICAgLy8gZ2FtZV9zdGF0ZS50aGlyZF9wbGFjZV9hZGRyZXNzID0gYXJjNC5BZGRyZXNzKHBsYXllcikKICAgIGZyYW1lX2RpZyA3CiAgICByZXBsYWNlMiAxMjEKICAgIGZyYW1lX2J1cnkgNgogICAgYiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUA0NAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LnRyaWdnZXJfZ2FtZV9ldmVudChnYW1lX2lkOiB1aW50NjQsIHRyaWdnZXJfaWQ6IGJ5dGVzKSAtPiB2b2lkOgp0cmlnZ2VyX2dhbWVfZXZlbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYwOS02MTEKICAgIC8vICMgQWxsb3cgYW55IHZhbGlkIGFjY291bnQgdG8gY2hlY2sgYW5kIHRyaWdnZXIgZ2FtZSBldmVudCBwcm9ncmVzc2lvbgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgdHJpZ2dlcl9nYW1lX2V2ZW50KHNlbGYsIGdhbWVfaWQ6IFVJbnQ2NCwgdHJpZ2dlcl9pZDogYXJjNC5VSW50OCkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjEyLTYxMwogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgR2xvYmFsLmdyb3VwX3NpemUgPT0gMSwgZXJyLlNUQU5EQUxPTkVfVFhOX09OTFkKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZ3JvdXAgc2l6ZS4gVGhpcyBhcHAgY2FsbCBjYW4gb25seSB0YWtlIHN0YW5kYWxvbmUgdHJhbnNhY3Rpb25zLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MTQKICAgIC8vIGFzc2VydCBnYW1lX2lkIGluIHNlbGYuYm94X2dhbWVfc3RhdGUsIGVyci5HQU1FX0lEX05PVF9GT1VORAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICBieXRlYyA0IC8vICJzXyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwbiAyCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggZ2FtZSBzdGF0ZSBub3QgZm91bmQuIENoZWNrIGlmIGdhbWUgSUQgZXhpc3RzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MTYtNjE5CiAgICAvLyAjIFJldHJpZXZlIGN1cnJlbnQgZ2FtZSBzdGF0ZSBkYXRhIGZyb20gaXRzIGNvcnJlc3BvbmRpbmcgYm94IHVzaW5nIHRoZSBnYW1lIGlkIHBhcmFtZXRlcgogICAgLy8gZ2FtZV9zdGF0ZSA9IHNlbGYuYm94X2dhbWVfc3RhdGVbCiAgICAvLyAgICAgZ2FtZV9pZAogICAgLy8gXS5jb3B5KCkgICMgTWFrZSBhIGNvcHkgb2YgdGhlIGdhbWUgc3RhdGUgZWxzZSBpbW11dGFibGUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJveF9nYW1lX3N0YXRlIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MjEtNjIyCiAgICAvLyAjIFRyaWdnZXIgSUQgMCBjb3JyZXNwb25kcyB3LyBldmVudDogR2FtZSBMaXZlCiAgICAvLyBpZiB0cmlnZ2VyX2lkLm5hdGl2ZSA9PSAwOgogICAgZnJhbWVfZGlnIC0xCiAgICBidG9pCiAgICBkdXAKICAgIGJueiB0cmlnZ2VyX2dhbWVfZXZlbnRfZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjIzLTYyNAogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgbm90IGdhbWVfc3RhdGUuc3Rha2luZ19maW5hbGl6ZWQubmF0aXZlLCBlcnIuU1RBS0lOR19GSU5BTF9GTEFHCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIEdhbWUgc3RhdGUgc3Rha2luZyBmaW5hbGl6ZWQgYm9vbGVhbiB2YWx1ZSBtaXNtYXRjaC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjI2LTYyNwogICAgLy8gIyBTcGVjaWFsIGNhc2U6IENoZWNrIGlmIHRoZSBhZG1pbiBpcyB0aGUgb25seSBhY3RpdmUgcGxheWVyLCBpZiB0cnVlLCBqdXN0IGVuZCB0aGUgZ2FtZQogICAgLy8gaWYgZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgPT0gMSBhbmQgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgaW50Y18yIC8vIDIKICAgIGdldGJ5dGUKICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MjYtNjMzCiAgICAvLyAjIFNwZWNpYWwgY2FzZTogQ2hlY2sgaWYgdGhlIGFkbWluIGlzIHRoZSBvbmx5IGFjdGl2ZSBwbGF5ZXIsIGlmIHRydWUsIGp1c3QgZW5kIHRoZSBnYW1lCiAgICAvLyBpZiBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzLm5hdGl2ZSA9PSAxIGFuZCBzcnQuY2hlY2tfYWNjX2luX2dhbWUoCiAgICAvLyAgICAgZ2FtZV9pZD1nYW1lX2lkLAogICAgLy8gICAgIGFjY291bnQ9Z2FtZV9zdGF0ZS5hZG1pbl9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICAgICBwbGF5ZXJfY291bnQ9VUludDY0KDEpLAogICAgLy8gICAgIGNsZWFyX3BsYXllcj1GYWxzZSwKICAgIC8vICk6CiAgICBieiB0cmlnZ2VyX2dhbWVfZXZlbnRfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYyOQogICAgLy8gYWNjb3VudD1nYW1lX3N0YXRlLmFkbWluX2FkZHJlc3MubmF0aXZlLAogICAgZnJhbWVfZGlnIDIKICAgIGV4dHJhY3QgMjUgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYyNi02MzMKICAgIC8vICMgU3BlY2lhbCBjYXNlOiBDaGVjayBpZiB0aGUgYWRtaW4gaXMgdGhlIG9ubHkgYWN0aXZlIHBsYXllciwgaWYgdHJ1ZSwganVzdCBlbmQgdGhlIGdhbWUKICAgIC8vIGlmIGdhbWVfc3RhdGUuYWN0aXZlX3BsYXllcnMubmF0aXZlID09IDEgYW5kIHNydC5jaGVja19hY2NfaW5fZ2FtZSgKICAgIC8vICAgICBnYW1lX2lkPWdhbWVfaWQsCiAgICAvLyAgICAgYWNjb3VudD1nYW1lX3N0YXRlLmFkbWluX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGJveF9nYW1lX3BsYXllcnM9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLAogICAgLy8gICAgIHBsYXllcl9jb3VudD1VSW50NjQoMSksCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKToKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MzAKICAgIC8vIGJveF9nYW1lX3BsYXllcnM9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLAogICAgYnl0ZWNfMyAvLyAicF8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYzMQogICAgLy8gcGxheWVyX2NvdW50PVVJbnQ2NCgxKSwKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYzMgogICAgLy8gY2xlYXJfcGxheWVyPUZhbHNlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjI2LTYzMwogICAgLy8gIyBTcGVjaWFsIGNhc2U6IENoZWNrIGlmIHRoZSBhZG1pbiBpcyB0aGUgb25seSBhY3RpdmUgcGxheWVyLCBpZiB0cnVlLCBqdXN0IGVuZCB0aGUgZ2FtZQogICAgLy8gaWYgZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgPT0gMSBhbmQgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PWdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyAgICAgcGxheWVyX2NvdW50PVVJbnQ2NCgxKSwKICAgIC8vICAgICBjbGVhcl9wbGF5ZXI9RmFsc2UsCiAgICAvLyApOgogICAgY2FsbHN1YiBjaGVja19hY2NfaW5fZ2FtZQogICAgYnogdHJpZ2dlcl9nYW1lX2V2ZW50X2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2MzQtNjM5CiAgICAvLyBzcnQuaXNfZ2FtZV9vdmVyKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUsCiAgICAvLyAgICAgYm94X2dhbWVfcmVnaXN0ZXI9c2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjM3CiAgICAvLyBib3hfZ2FtZV9yZWdpc3Rlcj1zZWxmLmJveF9nYW1lX3JlZ2lzdGVyLAogICAgYnl0ZWNfMCAvLyAicl8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjYzOAogICAgLy8gYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICBieXRlY18zIC8vICJwXyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjM0LTYzOQogICAgLy8gc3J0LmlzX2dhbWVfb3ZlcigKICAgIC8vICAgICBnYW1lX2lkPWdhbWVfaWQsCiAgICAvLyAgICAgZ2FtZV9zdGF0ZT1nYW1lX3N0YXRlLAogICAgLy8gICAgIGJveF9nYW1lX3JlZ2lzdGVyPXNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyApCiAgICBjYWxsc3ViIGlzX2dhbWVfb3ZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2NDEtNjQyCiAgICAvLyAjIFVwZGF0ZSB0aGUgZ2FtZSBzdGF0ZSBib3ggZGF0YSB3aXRoIGEgY29weSBjb250YWluaW5nIGl0cyBtb2RpZmllZCB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0gPSBnYW1lX3N0YXRlLmNvcHkoKQogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjQ0LTY0NQogICAgLy8gIyBNYWtlIGFuIGVhcmx5IHJldHVybgogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCnRyaWdnZXJfZ2FtZV9ldmVudF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjY0OQogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMKICAgIGZyYW1lX2RpZyAyCiAgICBkdXAKICAgIGV4dHJhY3QgOSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2NTAKICAgIC8vIDwgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgICMgR2FtZSBsaXZlIHRpbWVyIG11c3QgZXhwaXJlZCwgT1IKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjQ5LTY1MAogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMKICAgIC8vIDwgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgICMgR2FtZSBsaXZlIHRpbWVyIG11c3QgZXhwaXJlZCwgT1IKICAgIGl0b2IKICAgIGI8CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjQ5LTY1MwogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMKICAgIC8vIDwgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgICMgR2FtZSBsaXZlIHRpbWVyIG11c3QgZXhwaXJlZCwgT1IKICAgIC8vIG9yIHNydC5jYW5fcXVpY2tfcGxheSgKICAgIC8vICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUKICAgIC8vICkgICMgUXVpY2sgcGxheSBjb25kaXRpb25zIGFyZSBtZXQKICAgIGJueiB0cmlnZ2VyX2dhbWVfZXZlbnRfYm9vbF90cnVlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjUxLTY1MwogICAgLy8gb3Igc3J0LmNhbl9xdWlja19wbGF5KAogICAgLy8gICAgIGdhbWVfc3RhdGU9Z2FtZV9zdGF0ZQogICAgLy8gKSAgIyBRdWljayBwbGF5IGNvbmRpdGlvbnMgYXJlIG1ldAogICAgZnJhbWVfZGlnIDIKICAgIGNhbGxzdWIgY2FuX3F1aWNrX3BsYXkKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSAyCiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjQ5LTY1MwogICAgLy8gZ2FtZV9zdGF0ZS5leHBpcnlfdHMKICAgIC8vIDwgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgICMgR2FtZSBsaXZlIHRpbWVyIG11c3QgZXhwaXJlZCwgT1IKICAgIC8vIG9yIHNydC5jYW5fcXVpY2tfcGxheSgKICAgIC8vICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUKICAgIC8vICkgICMgUXVpY2sgcGxheSBjb25kaXRpb25zIGFyZSBtZXQKICAgIGJ6IHRyaWdnZXJfZ2FtZV9ldmVudF9ib29sX2ZhbHNlQDcKCnRyaWdnZXJfZ2FtZV9ldmVudF9ib29sX3RydWVANjoKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9idXJ5IDIKICAgIGludGNfMSAvLyAxCgp0cmlnZ2VyX2dhbWVfZXZlbnRfYm9vbF9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2NDctNjU0CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb24gYmVsb3cgZXZhbHVhdGVzIFRydWUKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgZ2FtZV9zdGF0ZS5leHBpcnlfdHMKICAgIC8vICAgICA8IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wICAjIEdhbWUgbGl2ZSB0aW1lciBtdXN0IGV4cGlyZWQsIE9SCiAgICAvLyAgICAgb3Igc3J0LmNhbl9xdWlja19wbGF5KAogICAgLy8gICAgICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUKICAgIC8vICAgICApICAjIFF1aWNrIHBsYXkgY29uZGl0aW9ucyBhcmUgbWV0CiAgICAvLyApLCBlcnIuSU5WQUxJRF9UUklHR0VSX0NPTkRJVElPTlMKICAgIGFzc2VydCAvLyBDb25kaXRpb25zIHJlcXVpcmVkIHRvIHRyaWdnZXIgdGhpcyBnYW1lIGV2ZW50IGNoZWNrIHdlcmUgaW52YWxpZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjU2LTY1NwogICAgLy8gIyBDaGVjayBpZiBnYW1lIGlzIGxpdmUKICAgIC8vIHNydC5pc19nYW1lX2xpdmUoZ2FtZV9pZD1nYW1lX2lkLCBnYW1lX3N0YXRlPWdhbWVfc3RhdGUpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAyCiAgICBjYWxsc3ViIGlzX2dhbWVfbGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2ODUtNjg2CiAgICAvLyAjIFVwZGF0ZSB0aGUgZ2FtZSBzdGF0ZSBib3ggZGF0YSB3aXRoIGEgY29weSBjb250YWluaW5nIGl0cyBtb2RpZmllZCB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0gPSBnYW1lX3N0YXRlLmNvcHkoKQogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIHJldHN1YgoKdHJpZ2dlcl9nYW1lX2V2ZW50X2Jvb2xfZmFsc2VANzoKICAgIGludGNfMCAvLyAwCiAgICBiIHRyaWdnZXJfZ2FtZV9ldmVudF9ib29sX21lcmdlQDgKCnRyaWdnZXJfZ2FtZV9ldmVudF9lbHNlX2JvZHlAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjU5LTY2MAogICAgLy8gIyBUcmlnZ2VyIElEIDIgY29ycmVzcG9uZHMgdy8gZXZlbnQ6IEdhbWUgT3ZlcgogICAgLy8gZWxpZiB0cmlnZ2VyX2lkLm5hdGl2ZSA9PSAyOgogICAgZnJhbWVfZGlnIDMKICAgIGludGNfMiAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIEdhbWUgZXZlbnQgbm90IGZvdW5kLiBDaGVjayBpZiBnYW1lIGV2ZW50IFRyaWdnZXIgSUQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjY2MS02NjIKICAgIC8vICMgRmFpbCB0cmFuc2FjdGlvbiB1bmxlc3MgdGhlIGFzc2VydGlvbiBiZWxvdyBldmFsdWF0ZXMgVHJ1ZQogICAgLy8gYXNzZXJ0IGdhbWVfc3RhdGUuc3Rha2luZ19maW5hbGl6ZWQubmF0aXZlLCBlcnIuU1RBS0lOR19GSU5BTF9GTEFHCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYXNzZXJ0IC8vIEdhbWUgc3RhdGUgc3Rha2luZyBmaW5hbGl6ZWQgYm9vbGVhbiB2YWx1ZSBtaXNtYXRjaC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjY0CiAgICAvLyBnYW1lX3N0YXRlLmV4cGlyeV90cyA8IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wCiAgICBkdXAKICAgIGV4dHJhY3QgOSA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgYjwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjYzLTY2NQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBnYW1lX3N0YXRlLmV4cGlyeV90cyA8IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wCiAgICAvLyApLCBlcnIuVElNRV9DT05TVFJBSU5UX1ZJT0xBVElPTgogICAgYXNzZXJ0IC8vIEludmFsaWQgdGltZSBmcmFtZS4gQ2FsbCBtYWRlIG91dHNpZGUgdGhlIHBlcm1pdHRlZCBibG9jayBvciB0aW1lc3RhbXAgcmFuZ2UuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjY2Ny02NzMKICAgIC8vICMgQ2hlY2sgaWYgZ2FtZSBpcyBvdmVyCiAgICAvLyBzcnQuaXNfZ2FtZV9vdmVyKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBnYW1lX3N0YXRlPWdhbWVfc3RhdGUsCiAgICAvLyAgICAgYm94X2dhbWVfcmVnaXN0ZXI9c2VsZi5ib3hfZ2FtZV9yZWdpc3RlciwKICAgIC8vICAgICBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2NzEKICAgIC8vIGJveF9nYW1lX3JlZ2lzdGVyPXNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsCiAgICBieXRlY18wIC8vICJyXyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NjcyCiAgICAvLyBib3hfZ2FtZV9wbGF5ZXJzPXNlbGYuYm94X2dhbWVfcGxheWVycywKICAgIGJ5dGVjXzMgLy8gInBfIgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2NjctNjczCiAgICAvLyAjIENoZWNrIGlmIGdhbWUgaXMgb3ZlcgogICAgLy8gc3J0LmlzX2dhbWVfb3ZlcigKICAgIC8vICAgICBnYW1lX2lkPWdhbWVfaWQsCiAgICAvLyAgICAgZ2FtZV9zdGF0ZT1nYW1lX3N0YXRlLAogICAgLy8gICAgIGJveF9nYW1lX3JlZ2lzdGVyPXNlbGYuYm94X2dhbWVfcmVnaXN0ZXIsCiAgICAvLyAgICAgYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICAvLyApCiAgICBjYWxsc3ViIGlzX2dhbWVfb3ZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo2NzUtNjc2CiAgICAvLyAjIFVwZGF0ZSB0aGUgZ2FtZSBzdGF0ZSBib3ggZGF0YSB3aXRoIGEgY29weSBjb250YWluaW5nIGl0cyBtb2RpZmllZCB2YWx1ZXMKICAgIC8vIHNlbGYuYm94X2dhbWVfc3RhdGVbZ2FtZV9pZF0gPSBnYW1lX3N0YXRlLmNvcHkoKQogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Njc4LTY3OQogICAgLy8gIyBNYWtlIGFuIGVhcmx5IHJldHVybgogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucGllb3V0LmNvbnRyYWN0LlBpZW91dC5yZXNldF9nYW1lKGdhbWVfaWQ6IHVpbnQ2NCwgY2hhbmdlX3F1aWNrX3BsYXk6IHVpbnQ2NCwgY2hhbmdlX21heF9wbGF5ZXJzOiB1aW50NjQsIG5ld19tYXhfcGxheWVyczogdWludDY0LCBzdGFrZV9wYXk6IHVpbnQ2NCkgLT4gdm9pZDoKcmVzZXRfZ2FtZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Njg4LTY5NwogICAgLy8gIyBBbGxvdyBhZG1pbiB0byByZXNldCBhbiBleGlzdGluZyBnYW1lIGluc3RhbmNlCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiByZXNldF9nYW1lKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZ2FtZV9pZDogVUludDY0LAogICAgLy8gICAgIGNoYW5nZV9xdWlja19wbGF5OiBib29sLCAgIyBub3FhOiBGQlQwMDEKICAgIC8vICAgICBjaGFuZ2VfbWF4X3BsYXllcnM6IGJvb2wsICAjIG5vcWE6IEZCVDAwMQogICAgLy8gICAgIG5ld19tYXhfcGxheWVyczogVUludDY0LAogICAgLy8gICAgIHN0YWtlX3BheTogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA1IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Njk4LTY5OQogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9ucyBiZWxvdyBldmFsdWF0ZSBUcnVlCiAgICAvLyBhc3NlcnQgR2xvYmFsLmdyb3VwX3NpemUgPT0gMiwgZXJyLklOVkFMSURfR1JPVVBfU0laRQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18yIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBncm91cCBzaXplLiBFbnN1cmUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGluIGdyb3VwIGlzIHdpdGhpbiB2YWxpZCBib3VuZHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjcwMAogICAgLy8gYXNzZXJ0IGdhbWVfaWQgaW4gc2VsZi5ib3hfZ2FtZV9zdGF0ZSwgZXJyLkdBTUVfSURfTk9UX0ZPVU5ECiAgICBmcmFtZV9kaWcgLTUKICAgIGl0b2IKICAgIGJ5dGVjIDQgLy8gInNfIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEJveCBnYW1lIHN0YXRlIG5vdCBmb3VuZC4gQ2hlY2sgaWYgZ2FtZSBJRCBleGlzdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjcwMgogICAgLy8gYXNzZXJ0IHN0YWtlX3BheS5zZW5kZXIgPT0gVHhuLnNlbmRlciwgZXJyLklOVkFMSURfU1RBS0VfUEFZX1NFTkRFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gU3Rha2UgcGF5bWVudCBzZW5kZXIgYWRkcmVzcyBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlciBhZGRyZXNzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3MDQKICAgIC8vIHN0YWtlX3BheS5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzAzLTcwNQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzdGFrZV9wYXkucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLklOVkFMSURfU1RBS0VfUEFZX1JFQ0VJVkVSCiAgICBhc3NlcnQgLy8gU3Rha2UgcGF5bWVudCByZWNlaXZlciBhZGRyZXNzIG11c3QgbWF0Y2ggYXBwbGljYXRpb24gYWRkcmVzcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzA2CiAgICAvLyBhc3NlcnQgc3Rha2VfcGF5LmFtb3VudCA+PSBjc3QuU1RBS0VfQU1PVU5ULCBlcnIuSU5WQUxJRF9TVEFLRV9QQVlfRkVFCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgaW50YyA0IC8vIDEwMDAwMDAKICAgID49CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IGZ1bmRzLiBTdGFrZSBwYXkgYW1vdW50IGlzIG5vdCBlbm91Z2ggdG8gY292ZXIgc3Rha2luZyByZXF1aXJlbWVudHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjcwOC03MTEKICAgIC8vICMgUmV0cmlldmUgY3VycmVudCBnYW1lIHN0YXRlIGRhdGEgZnJvbSBpdHMgY29ycmVzcG9uZGluZyBib3ggdXNpbmcgdGhlIGdhbWUgaWQgcGFyYW1ldGVyCiAgICAvLyBnYW1lX3N0YXRlID0gc2VsZi5ib3hfZ2FtZV9zdGF0ZVsKICAgIC8vICAgICBnYW1lX2lkCiAgICAvLyBdLmNvcHkoKSAgIyBNYWtlIGEgY29weSBvZiB0aGUgZ2FtZSBzdGF0ZSBlbHNlIGltbXV0YWJsZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfc3RhdGUgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjcxMy03MTQKICAgIC8vICMgRmFpbCB0cmFuc2FjdGlvbiB1bmxlc3MgdGhlIGFzc2VydGlvbiBiZWxvdyBldmFsdWF0ZXMgVHJ1ZQogICAgLy8gYXNzZXJ0IGdhbWVfc3RhdGUuYWRtaW5fYWRkcmVzcyA9PSBUeG4uc2VuZGVyLCBlcnIuSU5WQUxJRF9BRE1JTgogICAgZHVwCiAgICBleHRyYWN0IDI1IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIGFzc2VydCAvLyBBY2NvdW50IGlzIG5vdCByZWNvZ25pemVkIGFzIHRoZSBhZG1pbiBhZGRyZXNzIGZvciB0aGlzIGdhbWUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjcxNQogICAgLy8gYXNzZXJ0IGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgPT0gMCwgZXJyLk5PTl9aRVJPX1BSSVpFX1BPT0wKICAgIGR1cAogICAgcHVzaGludCAxNyAvLyAxNwogICAgZXh0cmFjdF91aW50NjQKICAgICEKICAgIGFzc2VydCAvLyBQcml6ZSBwb29sIG5vdCBlbXB0eS4gQW1vdW50IGluIHByaXplIHBvb2wgbXVzdCBiZSB6ZXJvLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3MTYKICAgIC8vIGFzc2VydCBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzLm5hdGl2ZSA9PSAwLCBlcnIuTk9OX1pFUk9fQUNUSVZFX1BMQVlFUlMKICAgIGR1cAogICAgaW50Y18yIC8vIDIKICAgIGdldGJ5dGUKICAgICEKICAgIGFzc2VydCAvLyBHYW1lIGxvYmJ5IG5vdCBlbXB0eS4gTnVtYmVyIG9mIGFjdGl2ZSBwbGF5ZXJzIG11c3QgYmUgemVyby4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzIwCiAgICAvLyBrZXk9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLmtleV9wcmVmaXggKyBvcC5pdG9iKGdhbWVfaWQpCiAgICBieXRlY18zIC8vICJwXyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzE4LTcyMQogICAgLy8gIyBGb3IgZ2FtZSBwbGF5ZXJzIGJveCwgcmVwbGFjZSB0aGUgc2VuZGVyJ3MgYWRkcmVzcyBhdCBzdGFydCBpbmRleCAwCiAgICAvLyBnYW1lX3BsYXllcnNfYnJlZiA9IEJveFJlZigKICAgIC8vICAgICBrZXk9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLmtleV9wcmVmaXggKyBvcC5pdG9iKGdhbWVfaWQpCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzIwCiAgICAvLyBrZXk9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLmtleV9wcmVmaXggKyBvcC5pdG9iKGdhbWVfaWQpCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzIyCiAgICAvLyBnYW1lX3BsYXllcnNfYnJlZi5yZXBsYWNlKDAsIFR4bi5zZW5kZXIuYnl0ZXMpCiAgICBpbnRjXzAgLy8gMAogICAgdHhuIFNlbmRlcgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzI0LTcyNQogICAgLy8gIyBSZXNldCBnYW1lIHN0YXRlIHByb3BlcnRpZXMgYmFjayB0byB0aGVpciBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlcwogICAgLy8gZ2FtZV9zdGF0ZS5zdGFraW5nX2ZpbmFsaXplZCA9IGFyYzQuQm9vbChGYWxzZSkgICMgbm9xYTogRkJUMDAzCiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzI2CiAgICAvLyBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzID0gYXJjNC5VSW50OCgxKQogICAgcHVzaGJ5dGVzIDB4MDEKICAgIHJlcGxhY2UyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzI3CiAgICAvLyBnYW1lX3N0YXRlLmZpcnN0X3BsYWNlX3Njb3JlID0gYXJjNC5VSW50OCgwKQogICAgYnl0ZWNfMSAvLyAweDAwCiAgICByZXBsYWNlMiAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjcyOAogICAgLy8gZ2FtZV9zdGF0ZS5zZWNvbmRfcGxhY2Vfc2NvcmUgPSBhcmM0LlVJbnQ4KDApCiAgICBieXRlY18xIC8vIDB4MDAKICAgIHJlcGxhY2UyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzI5CiAgICAvLyBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX3Njb3JlID0gYXJjNC5VSW50OCgwKQogICAgYnl0ZWNfMSAvLyAweDAwCiAgICByZXBsYWNlMiA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjczMAogICAgLy8gZ2FtZV9zdGF0ZS5ib3hfcF9zdGFydF9wb3MgPSBhcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFKQogICAgYnl0ZWMgMTEgLy8gMHgwMDIwCiAgICByZXBsYWNlMiA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjczMgogICAgLy8gR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBjc3QuUEhBU0VfRVhQSVJZX0lOVEVSVkFMCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjIDUgLy8gMjAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjczMS03MzMKICAgIC8vIGdhbWVfc3RhdGUuZXhwaXJ5X3RzID0gYXJjNC5VSW50NjQoCiAgICAvLyAgICAgR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBjc3QuUEhBU0VfRVhQSVJZX0lOVEVSVkFMCiAgICAvLyApCiAgICBpdG9iCiAgICByZXBsYWNlMiA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjczNQogICAgLy8gZ2FtZV9zdGF0ZS5wcml6ZV9wb29sLm5hdGl2ZSArIGNzdC5TVEFLRV9BTU9VTlQKICAgIGR1cAogICAgcHVzaGludCAxNyAvLyAxNwogICAgZXh0cmFjdF91aW50NjQKICAgIGludGMgNCAvLyAxMDAwMDAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjczNC03MzYKICAgIC8vIGdhbWVfc3RhdGUucHJpemVfcG9vbCA9IGFyYzQuVUludDY0KAogICAgLy8gICAgIGdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUgKyBjc3QuU1RBS0VfQU1PVU5UCiAgICAvLyApCiAgICBpdG9iCiAgICByZXBsYWNlMiAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3MzcKICAgIC8vIGdhbWVfc3RhdGUuZmlyc3RfcGxhY2VfYWRkcmVzcyA9IGFyYzQuQWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXBsYWNlMiA1NwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3MzgKICAgIC8vIGdhbWVfc3RhdGUuc2Vjb25kX3BsYWNlX2FkZHJlc3MgPSBhcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcykKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmVwbGFjZTIgODkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzM5CiAgICAvLyBnYW1lX3N0YXRlLnRoaXJkX3BsYWNlX2FkZHJlc3MgPSBhcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcykKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmVwbGFjZTIgMTIxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzQxLTc0MgogICAgLy8gIyBJZiBjYWxsZXIgc2V0cyBjaGFuZ2VfcXVpY2tfcGxheSBib29sIGFzIFRydWUKICAgIC8vIGlmIGNoYW5nZV9xdWlja19wbGF5OgogICAgZnJhbWVfZGlnIC00CiAgICBieiByZXNldF9nYW1lX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NDUKICAgIC8vIG5vdCBnYW1lX3N0YXRlLnF1aWNrX3BsYXlfZW5hYmxlZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICBnZXRiaXQKICAgIGJ5dGVjXzEgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc0My03NDYKICAgIC8vICMgRmxpcCB0aGUgcXVpY2sgcGxheSBib29sIHZhbHVlCiAgICAvLyBnYW1lX3N0YXRlLnF1aWNrX3BsYXlfZW5hYmxlZCA9IGFyYzQuQm9vbCgKICAgIC8vICAgICBub3QgZ2FtZV9zdGF0ZS5xdWlja19wbGF5X2VuYWJsZWQubmF0aXZlCiAgICAvLyApCiAgICBieXRlY18xIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgaW50Y18xIC8vIDEKICAgIHN3YXAKICAgIHNldGJpdAogICAgZnJhbWVfYnVyeSAyCgpyZXNldF9nYW1lX2FmdGVyX2lmX2Vsc2VAMjoKICAgIGZyYW1lX2RpZyAyCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc0OC03NDkKICAgIC8vICMgSWYgY2FsbGVyIHNldHMgY2hhbmdlX21heF9wbGF5ZXJzIGJvb2wgYXMgVHJ1ZQogICAgLy8gaWYgY2hhbmdlX21heF9wbGF5ZXJzOgogICAgZnJhbWVfZGlnIC0zCiAgICBieiByZXNldF9nYW1lX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NTIKICAgIC8vIG5ld19tYXhfcGxheWVycyA+PSBjc3QuTUFYX1BMQVlFUlNfQk9UX0JPVU5ECiAgICBmcmFtZV9kaWcgLTIKICAgIHB1c2hpbnQgMyAvLyAzCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NTItNzUzCiAgICAvLyBuZXdfbWF4X3BsYXllcnMgPj0gY3N0Lk1BWF9QTEFZRVJTX0JPVF9CT1VORAogICAgLy8gYW5kIG5ld19tYXhfcGxheWVycyA8PSBjc3QuTUFYX1BMQVlFUlNfVE9QX0JPVU5ECiAgICBieiByZXNldF9nYW1lX2Jvb2xfZmFsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NTMKICAgIC8vIGFuZCBuZXdfbWF4X3BsYXllcnMgPD0gY3N0Lk1BWF9QTEFZRVJTX1RPUF9CT1VORAogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NTItNzUzCiAgICAvLyBuZXdfbWF4X3BsYXllcnMgPj0gY3N0Lk1BWF9QTEFZRVJTX0JPVF9CT1VORAogICAgLy8gYW5kIG5ld19tYXhfcGxheWVycyA8PSBjc3QuTUFYX1BMQVlFUlNfVE9QX0JPVU5ECiAgICBieiByZXNldF9nYW1lX2Jvb2xfZmFsc2VANgogICAgaW50Y18xIC8vIDEKCnJlc2V0X2dhbWVfYm9vbF9tZXJnZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NTAtNzU0CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gaWYgbmV3IG1heCBwbGF5ZXJzIGFyZ3VtZW50IGlzIG91dHNpZGUgcGVybWl0dGVkIGJvdW5kcwogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBuZXdfbWF4X3BsYXllcnMgPj0gY3N0Lk1BWF9QTEFZRVJTX0JPVF9CT1VORAogICAgLy8gICAgIGFuZCBuZXdfbWF4X3BsYXllcnMgPD0gY3N0Lk1BWF9QTEFZRVJTX1RPUF9CT1VORAogICAgLy8gKSwgZXJyLklOVkFMSURfTUFYX1BMQVlFUlMKICAgIGFzc2VydCAvLyBUaGUgbnVtYmVyIG9mIG1heCBwbGF5ZXJzIG11c3QgYmUgd2l0aGluIGJvdW5kcy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6NzU2LTc1NwogICAgLy8gIyBVcGRhdGUgdGhlIG9sZCBtYXggcGxheWVycyB2YWx1ZSB3aXRoIHRoZSBuZXcgdmFsdWUKICAgIC8vIGdhbWVfc3RhdGUubWF4X3BsYXllcnMgPSBhcmM0LlVJbnQ4KG5ld19tYXhfcGxheWVycykKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIHJlcGxhY2UyIDEKICAgIGZyYW1lX2J1cnkgMgoKcmVzZXRfZ2FtZV9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc1OS03NjAKICAgIC8vICMgQ29weSB0aGUgbW9kaWZpZWQgZ2FtZSBzdGF0ZSBhbmQgc3RvcmUgaXQgYXMgbmV3IHZhbHVlIG9mIGJveAogICAgLy8gc2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXSA9IGdhbWVfc3RhdGUuY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDIKICAgIGJveF9wdXQKICAgIHJldHN1YgoKcmVzZXRfZ2FtZV9ib29sX2ZhbHNlQDY6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZXNldF9nYW1lX2Jvb2xfbWVyZ2VANwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LmRlbGV0ZV9nYW1lKGdhbWVfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKZGVsZXRlX2dhbWU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc2Mi03NjcKICAgIC8vICMgQWxsb3cgYXBwbGljYXRpb24gY3JlYXRvciBvciBhZG1pbiB0byBkZWxldGUgYW4gZXhpc3RpbmcgZ2FtZSBpbnN0YW5jZQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgZGVsZXRlX2dhbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2lkOiBVSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3NjgtNzY5CiAgICAvLyAjIEZhaWwgdHJhbnNhY3Rpb24gdW5sZXNzIHRoZSBhc3NlcnRpb25zIGJlbG93IGV2YWx1YXRlIFRydWUKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSAxLCBlcnIuU1RBTkRBTE9ORV9UWE5fT05MWQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBncm91cCBzaXplLiBUaGlzIGFwcCBjYWxsIGNhbiBvbmx5IHRha2Ugc3RhbmRhbG9uZSB0cmFuc2FjdGlvbnMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc3MAogICAgLy8gYXNzZXJ0IGdhbWVfaWQgaW4gc2VsZi5ib3hfZ2FtZV9zdGF0ZSwgZXJyLkdBTUVfSURfTk9UX0ZPVU5ECiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGR1cAogICAgYnl0ZWMgNCAvLyAic18iCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQm94IGdhbWUgc3RhdGUgbm90IGZvdW5kLiBDaGVjayBpZiBnYW1lIElEIGV4aXN0cy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Nzc3LTc4MAogICAgLy8gIyBSZXRyaWV2ZSBjdXJyZW50IGdhbWUgc3RhdGUgZGF0YSBmcm9tIGl0cyBjb3JyZXNwb25kaW5nIGJveCB1c2luZyB0aGUgZ2FtZSBpZCBwYXJhbWV0ZXIKICAgIC8vIGdhbWVfc3RhdGUgPSBzZWxmLmJveF9nYW1lX3N0YXRlWwogICAgLy8gICAgIGdhbWVfaWQKICAgIC8vIF0uY29weSgpICAjIE1ha2UgYSBjb3B5IG9mIHRoZSBnYW1lIHN0YXRlIGVsc2UgaW1tdXRhYmxlCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfc3RhdGUgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc4Mi03ODMKICAgIC8vICMgR2V0IHRoZSBhZG1pbiBhY2NvdW50IGFkZHJlc3MgZnJvbSB0aGUgZ2FtZSBzdGF0ZSBib3gKICAgIC8vIGFkbWluID0gc2VsZi5ib3hfZ2FtZV9zdGF0ZVtnYW1lX2lkXS5hZG1pbl9hZGRyZXNzLm5hdGl2ZQogICAgZXh0cmFjdCAyNSAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3ODcKICAgIC8vIFR4bi5zZW5kZXIgPT0gYWRtaW4gb3IgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgYm56IGRlbGV0ZV9nYW1lX2Jvb2xfdHJ1ZUAyCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBieiBkZWxldGVfZ2FtZV9ib29sX2ZhbHNlQDMKCmRlbGV0ZV9nYW1lX2Jvb2xfdHJ1ZUAyOgogICAgaW50Y18xIC8vIDEKCmRlbGV0ZV9nYW1lX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Nzg1LTc4OAogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9ucyBiZWxvdyBldmFsdWF0ZSBUcnVlCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT0gYWRtaW4gb3IgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzCiAgICAvLyApLCBlcnIuSU5WQUxJRF9DQUxMRVIKICAgIGFzc2VydCAvLyBBY2NvdW50IGlzIG5vdCBhdXRob3JpemVkIHRvIG1ha2UgdGhpcyBjYWxsLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3OTAtNzkxCiAgICAvLyAjIEVuc3VyZSBnYW1lIGhhcyB6ZXJvIGFjdGl2ZSBwbGF5ZXJzIE9SIG9ubHkgcGxheWVyIGxlZnQgaXMgdGhlIGFkbWluCiAgICAvLyBpZiBnYW1lX3N0YXRlLmFjdGl2ZV9wbGF5ZXJzLm5hdGl2ZSA9PSAxOgogICAgZnJhbWVfZGlnIDMKICAgIGludGNfMiAvLyAyCiAgICBnZXRieXRlCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBieiBkZWxldGVfZ2FtZV9lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3OTItNzk4CiAgICAvLyBhc3NlcnQgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PWFkbWluLAogICAgLy8gICAgIGJveF9nYW1lX3BsYXllcnM9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLAogICAgLy8gICAgIHBsYXllcl9jb3VudD1VSW50NjQoMSksCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKSwgZXJyLkFETUlOX1NPTEVfUExBWUVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2RpZyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojc5NQogICAgLy8gYm94X2dhbWVfcGxheWVycz1zZWxmLmJveF9nYW1lX3BsYXllcnMsCiAgICBieXRlY18zIC8vICJwXyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Nzk2CiAgICAvLyBwbGF5ZXJfY291bnQ9VUludDY0KDEpLAogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6Nzk3CiAgICAvLyBjbGVhcl9wbGF5ZXI9RmFsc2UsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo3OTItNzk4CiAgICAvLyBhc3NlcnQgc3J0LmNoZWNrX2FjY19pbl9nYW1lKAogICAgLy8gICAgIGdhbWVfaWQ9Z2FtZV9pZCwKICAgIC8vICAgICBhY2NvdW50PWFkbWluLAogICAgLy8gICAgIGJveF9nYW1lX3BsYXllcnM9c2VsZi5ib3hfZ2FtZV9wbGF5ZXJzLAogICAgLy8gICAgIHBsYXllcl9jb3VudD1VSW50NjQoMSksCiAgICAvLyAgICAgY2xlYXJfcGxheWVyPUZhbHNlLAogICAgLy8gKSwgZXJyLkFETUlOX1NPTEVfUExBWUVSCiAgICBjYWxsc3ViIGNoZWNrX2FjY19pbl9nYW1lCiAgICBhc3NlcnQgLy8gR2FtZSBhZG1pbiBhZGRyZXNzIG11c3QgYmUgc29sZSByZW1haW5pbmcgYWN0aXZlIHBsYXllciBpbiB0aGUgZ2FtZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODAyCiAgICAvLyByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MDMKICAgIC8vIGFtb3VudD1nYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlLAogICAgZnJhbWVfZGlnIDMKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgwNC04MDYKICAgIC8vIG5vdGU9U3RyaW5nKAogICAgLy8gICAgICdwaWVvdXQ6ansibWV0aG9kIjoiZGVsZXRlX2dhbWUiLCJjb25jZXJuIjoiaXR4bi5wYXk7cHJpemVfcG9vbF9hZG1pbl9zdGFrZSJ9JwogICAgLy8gKSwKICAgIHB1c2hieXRlcyAicGllb3V0Omp7XCJtZXRob2RcIjpcImRlbGV0ZV9nYW1lXCIsXCJjb25jZXJuXCI6XCJpdHhuLnBheTtwcml6ZV9wb29sX2FkbWluX3N0YWtlXCJ9IgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MDAtODA3CiAgICAvLyAjIElzc3VlIHByaXplIHBvb2wgcGF5b3V0cyBlcXVhbCB0byBhZG1pbiBzdGFrZQogICAgLy8gc3J0LnBheW91dF9pdHhuKAogICAgLy8gICAgIHJlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYW1vdW50PWdhbWVfc3RhdGUucHJpemVfcG9vbC5uYXRpdmUsCiAgICAvLyAgICAgbm90ZT1TdHJpbmcoCiAgICAvLyAgICAgICAgICdwaWVvdXQ6ansibWV0aG9kIjoiZGVsZXRlX2dhbWUiLCJjb25jZXJuIjoiaXR4bi5wYXk7cHJpemVfcG9vbF9hZG1pbl9zdGFrZSJ9JwogICAgLy8gICAgICksCiAgICAvLyApCiAgICBjYWxsc3ViIHBheW91dF9pdHhuCgpkZWxldGVfZ2FtZV9hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgxNC04MTUKICAgIC8vICMgRGVsZXRlIGJveCBnYW1lIHN0YXRlIGFuZCBib3ggZ2FtZSBwbGF5ZXJzIGZyb20gdGhlIHNtYXJ0IGNvbnRyYWN0IHN0b3JhZ2UKICAgIC8vIGRlbCBzZWxmLmJveF9nYW1lX3N0YXRlW2dhbWVfaWRdCiAgICBmcmFtZV9kaWcgMgogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgxNgogICAgLy8gZGVsIHNlbGYuYm94X2dhbWVfcGxheWVyc1tnYW1lX2lkXQogICAgYnl0ZWNfMyAvLyAicF8iCiAgICBmcmFtZV9kaWcgMQogICAgY29uY2F0CiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODE4LTgxOQogICAgLy8gIyBTZXQgdGhlIGhvc3RpbmcgZ2FtZSBmbGFnIGluIGFkbWluJ3MgZ2FtZSByZWdpc3RlciBib3ggdG8gRmFsc2UKICAgIC8vIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXJbYWRtaW5dLmhvc3RpbmdfZ2FtZSA9IGFyYzQuQm9vbChGYWxzZSkgICMgbm9xYTogRkJUMDAzCiAgICBieXRlY18wIC8vICJyXyIKICAgIGZyYW1lX2RpZyA0CiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfcmVnaXN0ZXIgZW50cnkgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICBzZXRiaXQKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODI0CiAgICAvLyB2YWx1ZV9zaXplPWFyYzQuVUludDE2KGNzdC5BRERSRVNTX1NJWkUgKiBnYW1lX3N0YXRlLm1heF9wbGF5ZXJzLm5hdGl2ZSksCiAgICBmcmFtZV9kaWcgMwogICAgaW50Y18xIC8vIDEKICAgIGdldGJ5dGUKICAgIGludGNfMyAvLyAzMgogICAgKgogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgyMwogICAgLy8ga2V5X3NpemU9YXJjNC5VSW50OCgxMCksCiAgICBwdXNoYnl0ZXMgMHgwYQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MjEtODI1CiAgICAvLyAjIENhbGN1bGF0ZSBib3ggZ2FtZSBwbGF5ZXJzIGZlZQogICAgLy8gYm94X3BfY29zdCA9IHNlbGYuY2FsY19zaW5nbGVfYm94X2Nvc3QoCiAgICAvLyAgICAga2V5X3NpemU9YXJjNC5VSW50OCgxMCksCiAgICAvLyAgICAgdmFsdWVfc2l6ZT1hcmM0LlVJbnQxNihjc3QuQUREUkVTU19TSVpFICogZ2FtZV9zdGF0ZS5tYXhfcGxheWVycy5uYXRpdmUpLAogICAgLy8gKQogICAgc3dhcAogICAgY2FsbHN1YiBjYWxjX3NpbmdsZV9ib3hfY29zdAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MjkKICAgIC8vIHJlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgzMAogICAgLy8gYW1vdW50PWNzdC5CT1hfU19DT1NUICsgYm94X3BfY29zdCwKICAgIGludGMgMTEgLy8gODA1MDAKICAgIHVuY292ZXIgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MzEtODMzCiAgICAvLyBub3RlPVN0cmluZygKICAgIC8vICAgICAncGllb3V0Omp7Im1ldGhvZCI6ImRlbGV0ZV9nYW1lIiwiY29uY2VybiI6Iml0eG4ucGF5O2JveF9zX21icl9yZWZ1bmQrYm94X3BfbWJyX3JlZnVuZCJ9JwogICAgLy8gKSwKICAgIHB1c2hieXRlcyAicGllb3V0Omp7XCJtZXRob2RcIjpcImRlbGV0ZV9nYW1lXCIsXCJjb25jZXJuXCI6XCJpdHhuLnBheTtib3hfc19tYnJfcmVmdW5kK2JveF9wX21icl9yZWZ1bmRcIn0iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgyNy04MzQKICAgIC8vICMgSXNzdWUgTUJSIHJlZnVuZCBmb3IgZ2FtZSBzdGF0ZSBib3ggYW5kIGdhbWUgcGxheWVycyBib3ggZGVsZXRpb24gdmlhIGEgcGF5bWVudCBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gc3J0LnBheW91dF9pdHhuKAogICAgLy8gICAgIHJlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgYW1vdW50PWNzdC5CT1hfU19DT1NUICsgYm94X3BfY29zdCwKICAgIC8vICAgICBub3RlPVN0cmluZygKICAgIC8vICAgICAgICAgJ3BpZW91dDpqeyJtZXRob2QiOiJkZWxldGVfZ2FtZSIsImNvbmNlcm4iOiJpdHhuLnBheTtib3hfc19tYnJfcmVmdW5kK2JveF9wX21icl9yZWZ1bmQifScKICAgIC8vICAgICApLAogICAgLy8gKQogICAgY2FsbHN1YiBwYXlvdXRfaXR4bgogICAgcmV0c3ViCgpkZWxldGVfZ2FtZV9lbHNlX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODEwLTgxMQogICAgLy8gIyBGYWlsIHRyYW5zYWN0aW9uIHVubGVzcyB0aGUgYXNzZXJ0aW9uIGJlbG93IGV2YWx1YXRlcyBUcnVlCiAgICAvLyBhc3NlcnQgZ2FtZV9zdGF0ZS5hY3RpdmVfcGxheWVycy5uYXRpdmUgPT0gMCwgZXJyLk5PTl9aRVJPX0FDVElWRV9QTEFZRVJTCiAgICBmcmFtZV9kaWcgMAogICAgIQogICAgYXNzZXJ0IC8vIEdhbWUgbG9iYnkgbm90IGVtcHR5LiBOdW1iZXIgb2YgYWN0aXZlIHBsYXllcnMgbXVzdCBiZSB6ZXJvLgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4MTIKICAgIC8vIGFzc2VydCBnYW1lX3N0YXRlLnByaXplX3Bvb2wubmF0aXZlID09IDAsIGVyci5OT05fWkVST19QUklaRV9QT09MCiAgICBmcmFtZV9kaWcgMwogICAgcHVzaGludCAxNyAvLyAxNwogICAgZXh0cmFjdF91aW50NjQKICAgICEKICAgIGFzc2VydCAvLyBQcml6ZSBwb29sIG5vdCBlbXB0eS4gQW1vdW50IGluIHByaXplIHBvb2wgbXVzdCBiZSB6ZXJvLgogICAgYiBkZWxldGVfZ2FtZV9hZnRlcl9pZl9lbHNlQDcKCmRlbGV0ZV9nYW1lX2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBiIGRlbGV0ZV9nYW1lX2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5waWVvdXQuY29udHJhY3QuUGllb3V0LnRlcm1pbmF0ZSgpIC0+IHZvaWQ6CnRlcm1pbmF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODM2LTgzOAogICAgLy8gIyBBbGxvdyBhcHBsaWNhdGlvbiBjcmVhdG9yIHRvIGRlbGV0ZSB0aGUgc21hcnQgY29udHJhY3QgYXBwbGljYXRpb24KICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiB0ZXJtaW5hdGUoc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5OjgzOS04NDAKICAgIC8vICMgRmFpbCB0cmFuc2FjdGlvbiB1bmxlc3MgdGhlIGFzc2VydGlvbnMgYmVsb3cgZXZhbHVhdGUgVHJ1ZQogICAgLy8gYXNzZXJ0IFRlbXBsYXRlVmFyW2Jvb2xdKCJERUxFVEFCTEUiKSwgZXJyLkRFTEVURUFCTEVfTk9UX1RSVUUKICAgIGludGMgMTQgLy8gVE1QTF9ERUxFVEFCTEUKICAgIGFzc2VydCAvLyBUZW1wbGF0ZSB2YXJpYWJsZSAnREVMRVRBQkxFJyBuZWVkcyB0byBiZSAnVHJ1ZScgYXQgZGVwbG95LXRpbWUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg0MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgZXJyLklOVkFMSURfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIEFjY291bnQgbXVzdCBtYXRjaCBhcHBsaWNhdGlvbiBjcmVhdG9yIGFkZHJlc3MuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg0My04NDQKICAgIC8vICMgQ2hlY2sgaWYgZ2FtZSB0cm9waHkgYm94IGV4aXN0cwogICAgLy8gaWYgc2VsZi5ib3hfZ2FtZV90cm9waHk6CiAgICBieXRlY18yIC8vICJ0XyIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogdGVybWluYXRlX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NDcKICAgIC8vIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NDgKICAgIC8vIHNlbGYuYm94X2dhbWVfdHJvcGh5LnZhbHVlLmFzc2V0X2lkLm5hdGl2ZSwKICAgIGJ5dGVjXzIgLy8gInRfIgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfdHJvcGh5IGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg0NS04NDkKICAgIC8vICMgVXNlIGdhbWUgdHJvcGh5IGJveCBkYXRhIGFzc2V0IGlkIHByb3BlcnR5IHRvIGNoZWNrIGFwcCBhY2NvdW50IGFzc2V0IGJhbGFuY2UgZm9yIHRyb3BoeQogICAgLy8gYXNzZXRfYmFsYW5jZSwgYXNzZXRfZXhpc3RzID0gb3AuQXNzZXRIb2xkaW5nR2V0LmFzc2V0X2JhbGFuY2UoCiAgICAvLyAgICAgR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZS5hc3NldF9pZC5uYXRpdmUsCiAgICAvLyApCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NTAtODUxCiAgICAvLyAjIElmIGFzc2V0IGV4aXN0cyBhbmQgaXRzIGJhbGFuY2UgaXMgMSwgcGVyZm9ybSBidXJuIHZpYSBhc3NldCBjb25maWcgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vIGlmIGFzc2V0X2V4aXN0cyBhbmQgYXNzZXRfYmFsYW5jZSA9PSAxOgogICAgYnogdGVybWluYXRlX2FmdGVyX2lmX2Vsc2VANAogICAgZnJhbWVfZGlnIDAKICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYnogdGVybWluYXRlX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NTMKICAgIC8vIGFzc2V0X2lkPXNlbGYuYm94X2dhbWVfdHJvcGh5LnZhbHVlLmFzc2V0X2lkLm5hdGl2ZSwKICAgIGJ5dGVjXzIgLy8gInRfIgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYm94X2dhbWVfdHJvcGh5IGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L3N1YnJvdXRpbmVzLnB5OjI5LTMyCiAgICAvLyBpdHhuLkFzc2V0Q29uZmlnKAogICAgLy8gICAgIGNvbmZpZ19hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBub3RlPW5vdGUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg1NC04NTYKICAgIC8vIG5vdGU9U3RyaW5nKAogICAgLy8gICAgICdwaWVvdXQ6ansibWV0aG9kIjoidGVybWluYXRlIiwiY29uY2VybiI6Iml0eG4uYXNzZXRfY29uZmlnO2J1cm5fdHJvcGh5X2Fzc2V0In0nCiAgICAvLyApLAogICAgcHVzaGJ5dGVzICJwaWVvdXQ6antcIm1ldGhvZFwiOlwidGVybWluYXRlXCIsXCJjb25jZXJuXCI6XCJpdHhuLmFzc2V0X2NvbmZpZztidXJuX3Ryb3BoeV9hc3NldFwifSIKICAgIGl0eG5fZmllbGQgTm90ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9zdWJyb3V0aW5lcy5weToyOQogICAgLy8gaXR4bi5Bc3NldENvbmZpZygKICAgIHB1c2hpbnQgMyAvLyBhY2ZnCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvc3Vicm91dGluZXMucHk6MjktMzIKICAgIC8vIGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgY29uZmlnX2Fzc2V0PWFzc2V0X2lkLAogICAgLy8gICAgIG5vdGU9bm90ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0Cgp0ZXJtaW5hdGVfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NTgtODU5CiAgICAvLyAjIERlbGV0ZSBib3ggZ2FtZSB0cm9waHkgZnJvbSBjb250cmFjdCBzdG9yYWdlIGlmIGl0IGV4c2lzdHMKICAgIC8vIGRlbCBzZWxmLmJveF9nYW1lX3Ryb3BoeS52YWx1ZQogICAgYnl0ZWNfMiAvLyAidF8iCiAgICBib3hfZGVsCiAgICBwb3AKCnRlcm1pbmF0ZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg2MS04NjcKICAgIC8vICMgSXNzdWUgcGF5bWVudCBpbm5lciB0cmFuc2FjdGlvbiBjbG9zaW5nIGFsbCByZW1haW5pbmcgZnVuZHMgaW4gYXBwbGljYXRpb24gYWNjb3VudCBiYWxhbmNlCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89VHhuLnNlbmRlciwKICAgIC8vICAgICBub3RlPWIncGllb3V0Omp7Im1ldGhvZCI6InRlcm1pbmF0ZSIsImNvbmNlcm4iOiJpdHhuLnBheTtjbG9zZV9yZW1haW5kZXJfdG8ifScsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg2MwogICAgLy8gcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODY1CiAgICAvLyBjbG9zZV9yZW1haW5kZXJfdG89VHhuLnNlbmRlciwKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NjYKICAgIC8vIG5vdGU9YidwaWVvdXQ6ansibWV0aG9kIjoidGVybWluYXRlIiwiY29uY2VybiI6Iml0eG4ucGF5O2Nsb3NlX3JlbWFpbmRlcl90byJ9JywKICAgIHB1c2hieXRlcyAweDcwNjk2NTZmNzU3NDNhNmE3YjIyNmQ2NTc0Njg2ZjY0MjIzYTIyNzQ2NTcyNmQ2OTZlNjE3NDY1MjIyYzIyNjM2ZjZlNjM2NTcyNmUyMjNhMjI2OTc0Nzg2ZTJlNzA2MTc5M2I2MzZjNmY3MzY1NWY3MjY1NmQ2MTY5NmU2NDY1NzI1Zjc0NmYyMjdkCiAgICBpdHhuX2ZpZWxkIE5vdGUKICAgIGl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwogICAgLy8gc21hcnRfY29udHJhY3RzL3BpZW91dC9jb250cmFjdC5weTo4NjQKICAgIC8vIGFtb3VudD0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcGllb3V0L2NvbnRyYWN0LnB5Ojg2MS04NjIKICAgIC8vICMgSXNzdWUgcGF5bWVudCBpbm5lciB0cmFuc2FjdGlvbiBjbG9zaW5nIGFsbCByZW1haW5pbmcgZnVuZHMgaW4gYXBwbGljYXRpb24gYWNjb3VudCBiYWxhbmNlCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9waWVvdXQvY29udHJhY3QucHk6ODYxLTg2NwogICAgLy8gIyBJc3N1ZSBwYXltZW50IGlubmVyIHRyYW5zYWN0aW9uIGNsb3NpbmcgYWxsIHJlbWFpbmluZyBmdW5kcyBpbiBhcHBsaWNhdGlvbiBhY2NvdW50IGJhbGFuY2UKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gICAgIGNsb3NlX3JlbWFpbmRlcl90bz1UeG4uc2VuZGVyLAogICAgLy8gICAgIG5vdGU9YidwaWVvdXQ6ansibWV0aG9kIjoidGVybWluYXRlIiwiY29uY2VybiI6Iml0eG4ucGF5O2Nsb3NlX3JlbWFpbmRlcl90byJ9JywKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "cblocks", "sourceInfo": [{"pc": [4669], "errorMessage": "Account is not authorized to make this call."}, {"pc": [3130, 3405], "errorMessage": "Account is not recognized as an active player for this game."}, {"pc": [4459], "errorMessage": "Account is not recognized as the admin address for this game."}, {"pc": [2097], "errorMessage": "Account must be opted in to asset in order to perform this action."}, {"pc": [1836, 4956], "errorMessage": "Account must match application creator address."}, {"pc": [3200, 3347], "errorMessage": "Application ID mismatch. App ID must be same across all transactions in group."}, {"pc": [2084], "errorMessage": "Asset trophy receiver must match application ATH address."}, {"pc": [1856, 2224], "errorMessage": "Box found. Ensure the box you are trying to access does not exist already."}, {"pc": [1749, 2896, 3090, 3193, 3327, 4246, 4425, 4643], "errorMessage": "Box game state not found. Check if game ID exists."}, {"pc": [2229, 2301, 2452, 2603, 2611, 2904, 2912, 3098, 3335, 3340], "errorMessage": "Box not found. Ensure the box you are trying to access was created and still exists."}, {"pc": [1882, 2253, 2733, 2741], "errorMessage": "Box payment receiver address must match application address."}, {"pc": [1874, 2245, 2709, 2717], "errorMessage": "Box payment sender address must match transaction sender address."}, {"pc": [2329, 2473, 3144], "errorMessage": "Commit Rand Round not empty. Value must be zero to obtain a valid one."}, {"pc": [4345], "errorMessage": "Conditions required to trigger this game event check were invalid."}, {"pc": [4692], "errorMessage": "Game admin address must be sole remaining active player in the game."}, {"pc": [4366], "errorMessage": "Game event not found. Check if game event Trigger ID exists"}, {"pc": [4470, 4928], "errorMessage": "Game lobby not empty. Number of active players must be zero."}, {"pc": [2318, 2467, 2628], "errorMessage": "Game register hosting game boolean value mismatch."}, {"pc": [2969, 3111, 3433, 4269, 4379], "errorMessage": "Game state staking finalized boolean value mismatch."}, {"pc": [827, 859, 874, 879, 943, 977, 996, 1134, 1139, 1144, 1149, 1159, 1169, 1224, 2078, 2972, 2982, 2987, 3138, 3434, 3804, 3827, 3833, 3839, 3845, 3862, 3871, 3889, 3902, 3930, 4137, 4160, 4166, 4190, 4279, 4311, 4381, 4453, 4650], "errorMessage": "Index access is out of bounds"}, {"pc": [1866, 2237, 2663, 2693], "errorMessage": "Insufficient funds. Box pay amount is not enough to cover application MBR."}, {"pc": [1890], "errorMessage": "Insufficient funds. Mint pay amount is not enough to cover asset creation cost."}, {"pc": [2655, 2921, 4449], "errorMessage": "Insufficient funds. Stake pay amount is not enough to cover staking requirements."}, {"pc": [3224, 3372, 3453], "errorMessage": "Invalid Game ID. Box Game Register Game ID must be a certain value or match Game ID arg."}, {"pc": [3181, 3309], "errorMessage": "Invalid group index. Ensure transaction group index matches the expected value. "}, {"pc": [1850, 2215, 2598, 2883, 3177, 3304, 4409], "errorMessage": "Invalid group size. Ensure number of transaction in group is within valid bounds."}, {"pc": [2071, 2293, 2443, 3077, 4233, 4629], "errorMessage": "Invalid group size. This app call can only take standalone transactions."}, {"pc": [2480, 2979, 3441, 4388], "errorMessage": "Invalid time frame. Call made outside the permitted block or timestamp range."}, {"pc": [1906], "errorMessage": "Mint payment receiver address must match application address."}, {"pc": [1898], "errorMessage": "Mint payment sender address must match transaction sender address."}, {"pc": [2991], "errorMessage": "Number of active players must not exceed number of max players."}, {"pc": [162], "errorMessage": "OnCompletion is not DeleteApplication"}, {"pc": [174, 190, 230, 249, 265, 281, 297, 323, 375, 393, 405, 427, 439, 471, 484, 505, 531, 559, 581, 598], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [2956], "errorMessage": "Player with this address must not be an active game participant in the game."}, {"pc": [3006], "errorMessage": "Players box start position index overflow. Can not store more addresses."}, {"pc": [4465, 4935], "errorMessage": "Prize pool not empty. Amount in prize pool must be zero."}, {"pc": [3466], "errorMessage": "Randomness commit round not reached yet."}, {"pc": [3207, 3354], "errorMessage": "Sender mismatch. Sender must be same address across all transactions in group."}, {"pc": [2725, 2937, 4441], "errorMessage": "Stake payment receiver address must match application address."}, {"pc": [2701, 2929, 4433], "errorMessage": "Stake payment sender address must match transaction sender address."}, {"pc": [4950], "errorMessage": "Template variable 'DELETABLE' needs to be 'True' at deploy-time."}, {"pc": [2646, 4590], "errorMessage": "The number of max players must be within bounds."}, {"pc": [3215, 3362], "errorMessage": "Transaction at this group index must have exact required method selector."}, {"pc": [475], "errorMessage": "can only call when creating"}, {"pc": [165, 177, 193, 233, 252, 268, 284, 300, 326, 378, 396, 408, 430, 442, 487, 508, 534, 562, 584, 601], "errorMessage": "can only call when not creating"}, {"pc": [764, 1085], "errorMessage": "check BoxMap entry exists"}, {"pc": [1051], "errorMessage": "check BoxRef exists"}, {"pc": [1758], "errorMessage": "check self.box_game_players entry exists"}, {"pc": [2307, 2324, 2455, 2617, 2842, 3136, 3230, 3241, 3378, 3422, 3447, 3461, 4797], "errorMessage": "check self.box_game_register entry exists"}, {"pc": [2899, 3100, 3389, 3413, 4248, 4451, 4649], "errorMessage": "check self.box_game_state entry exists"}, {"pc": [2076, 3870, 3880, 3900, 3925, 4071, 4968, 4988], "errorMessage": "check self.box_game_trophy exists"}, {"pc": [2825], "errorMessage": "check self.game_id exists"}, {"pc": [2679, 2755, 3025, 3046, 3716, 4092, 4599, 4814], "errorMessage": "overflow"}, {"pc": [3172, 3299], "errorMessage": "transaction type is appl"}, {"pc": [221, 314, 346, 356, 366, 418, 452, 462], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {"GEN_UNIX": {"type": "AVMUint64"}, "DELETABLE": {"type": "AVMUint64"}}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class GameRegister:
    """Struct for GameRegister"""
    hosting_game: bool
    best_score: int
    game_id: int
    commit_rand_round: int
    expiry_round: int

@dataclasses.dataclass(frozen=True)
class GameState:
    """Struct for GameState"""
    staking_finalized: bool
    quick_play_enabled: bool
    max_players: int
    active_players: int
    first_place_score: int
    second_place_score: int
    third_place_score: int
    top_score: int
    box_p_start_pos: int
    expiry_ts: int
    prize_pool: int
    admin_address: str
    first_place_address: str
    second_place_address: str
    third_place_address: str
    topscorer_address: str

@dataclasses.dataclass(frozen=True)
class GameTrophy:
    """Struct for GameTrophy"""
    asset_id: int
    ath_score: int
    ath_address: str


@dataclasses.dataclass(frozen=True, kw_only=True)
class CalcSingleBoxCostArgs:
    """Dataclass for calc_single_box_cost arguments"""
    key_size: int
    value_size: int

    @property
    def abi_method_signature(self) -> str:
        return "calc_single_box_cost(uint8,uint16)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DoesBoxGameRegisterExistArgs:
    """Dataclass for does_box_game_register_exist arguments"""
    player: str | bytes

    @property
    def abi_method_signature(self) -> str:
        return "does_box_game_register_exist(account)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DoesBoxGameStateExistArgs:
    """Dataclass for does_box_game_state_exist arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "does_box_game_state_exist(uint64)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ReadBoxGamePlayersArgs:
    """Dataclass for read_box_game_players arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "read_box_game_players(uint64)address[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class MintTrophyArgs:
    """Dataclass for mint_trophy arguments"""
    box_t_pay: algokit_utils.AppMethodCallTransactionArgument
    mint_pay: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "mint_trophy(pay,pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetBoxGameRegisterArgs:
    """Dataclass for get_box_game_register arguments"""
    box_r_pay: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "get_box_game_register(pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DelBoxGameRegisterForOtherArgs:
    """Dataclass for del_box_game_register_for_other arguments"""
    player: str | bytes

    @property
    def abi_method_signature(self) -> str:
        return "del_box_game_register_for_other(account)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class NewGameArgs:
    """Dataclass for new_game arguments"""
    quick_play_enabled: bool
    max_players: int
    box_s_pay: algokit_utils.AppMethodCallTransactionArgument
    box_p_pay: algokit_utils.AppMethodCallTransactionArgument
    stake_pay: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "new_game(bool,uint64,pay,pay,pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class JoinGameArgs:
    """Dataclass for join_game arguments"""
    game_id: int
    stake_pay: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "join_game(uint64,pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetGameCommitArgs:
    """Dataclass for set_game_commit arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "set_game_commit(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpRefBudgetForPlayGameArgs:
    """Dataclass for up_ref_budget_for_play_game arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "up_ref_budget_for_play_game(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class PlayGameArgs:
    """Dataclass for play_game arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "play_game(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class TriggerGameEventArgs:
    """Dataclass for trigger_game_event arguments"""
    game_id: int
    trigger_id: int

    @property
    def abi_method_signature(self) -> str:
        return "trigger_game_event(uint64,uint8)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ResetGameArgs:
    """Dataclass for reset_game arguments"""
    game_id: int
    change_quick_play: bool
    change_max_players: bool
    new_max_players: int
    stake_pay: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "reset_game(uint64,bool,bool,uint64,pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DeleteGameArgs:
    """Dataclass for delete_game arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "delete_game(uint64)void"


class _PieoutDelete:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def terminate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppDeleteMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "terminate()void",
        }))


class PieoutParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_PieoutDelete":
        return _PieoutDelete(self.app_client)

    def calc_single_box_cost(
        self,
        args: tuple[int, int] | CalcSingleBoxCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "calc_single_box_cost(uint8,uint16)uint64",
            "args": method_args,
        }))

    def read_gen_unix(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "read_gen_unix()uint64",
        }))

    def does_box_game_trophy_exist(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_trophy_exist()bool",
        }))

    def does_box_game_register_exist(
        self,
        args: tuple[str | bytes] | DoesBoxGameRegisterExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_register_exist(account)bool",
            "args": method_args,
        }))

    def does_box_game_state_exist(
        self,
        args: tuple[int] | DoesBoxGameStateExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_state_exist(uint64)bool",
            "args": method_args,
        }))

    def read_box_game_players(
        self,
        args: tuple[int] | ReadBoxGamePlayersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "read_box_game_players(uint64)address[]",
            "args": method_args,
        }))

    def mint_trophy(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | MintTrophyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_trophy(pay,pay)void",
            "args": method_args,
        }))

    def claim_trophy(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "claim_trophy()void",
        }))

    def get_box_game_register(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | GetBoxGameRegisterArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_box_game_register(pay)void",
            "args": method_args,
        }))

    def del_box_game_register_for_self(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "del_box_game_register_for_self()void",
        }))

    def del_box_game_register_for_other(
        self,
        args: tuple[str | bytes] | DelBoxGameRegisterForOtherArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "del_box_game_register_for_other(account)void",
            "args": method_args,
        }))

    def new_game(
        self,
        args: tuple[bool, int, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | NewGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "new_game(bool,uint64,pay,pay,pay)void",
            "args": method_args,
        }))

    def join_game(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_game(uint64,pay)void",
            "args": method_args,
        }))

    def set_game_commit(
        self,
        args: tuple[int] | SetGameCommitArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_game_commit(uint64)void",
            "args": method_args,
        }))

    def up_ref_budget_for_play_game(
        self,
        args: tuple[int] | UpRefBudgetForPlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "up_ref_budget_for_play_game(uint64)void",
            "args": method_args,
        }))

    def play_game(
        self,
        args: tuple[int] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "play_game(uint64)void",
            "args": method_args,
        }))

    def trigger_game_event(
        self,
        args: tuple[int, int] | TriggerGameEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "trigger_game_event(uint64,uint8)void",
            "args": method_args,
        }))

    def reset_game(
        self,
        args: tuple[int, bool, bool, int, algokit_utils.AppMethodCallTransactionArgument] | ResetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "reset_game(uint64,bool,bool,uint64,pay)void",
            "args": method_args,
        }))

    def delete_game(
        self,
        args: tuple[int] | DeleteGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_game(uint64)void",
            "args": method_args,
        }))

    def generate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "generate()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class _PieoutDeleteTransaction:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def terminate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "terminate()void",
        }))


class PieoutCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_PieoutDeleteTransaction":
        return _PieoutDeleteTransaction(self.app_client)

    def calc_single_box_cost(
        self,
        args: tuple[int, int] | CalcSingleBoxCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "calc_single_box_cost(uint8,uint16)uint64",
            "args": method_args,
        }))

    def read_gen_unix(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "read_gen_unix()uint64",
        }))

    def does_box_game_trophy_exist(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_trophy_exist()bool",
        }))

    def does_box_game_register_exist(
        self,
        args: tuple[str | bytes] | DoesBoxGameRegisterExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_register_exist(account)bool",
            "args": method_args,
        }))

    def does_box_game_state_exist(
        self,
        args: tuple[int] | DoesBoxGameStateExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_state_exist(uint64)bool",
            "args": method_args,
        }))

    def read_box_game_players(
        self,
        args: tuple[int] | ReadBoxGamePlayersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "read_box_game_players(uint64)address[]",
            "args": method_args,
        }))

    def mint_trophy(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | MintTrophyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_trophy(pay,pay)void",
            "args": method_args,
        }))

    def claim_trophy(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "claim_trophy()void",
        }))

    def get_box_game_register(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | GetBoxGameRegisterArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_box_game_register(pay)void",
            "args": method_args,
        }))

    def del_box_game_register_for_self(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "del_box_game_register_for_self()void",
        }))

    def del_box_game_register_for_other(
        self,
        args: tuple[str | bytes] | DelBoxGameRegisterForOtherArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "del_box_game_register_for_other(account)void",
            "args": method_args,
        }))

    def new_game(
        self,
        args: tuple[bool, int, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | NewGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "new_game(bool,uint64,pay,pay,pay)void",
            "args": method_args,
        }))

    def join_game(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_game(uint64,pay)void",
            "args": method_args,
        }))

    def set_game_commit(
        self,
        args: tuple[int] | SetGameCommitArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_game_commit(uint64)void",
            "args": method_args,
        }))

    def up_ref_budget_for_play_game(
        self,
        args: tuple[int] | UpRefBudgetForPlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "up_ref_budget_for_play_game(uint64)void",
            "args": method_args,
        }))

    def play_game(
        self,
        args: tuple[int] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "play_game(uint64)void",
            "args": method_args,
        }))

    def trigger_game_event(
        self,
        args: tuple[int, int] | TriggerGameEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "trigger_game_event(uint64,uint8)void",
            "args": method_args,
        }))

    def reset_game(
        self,
        args: tuple[int, bool, bool, int, algokit_utils.AppMethodCallTransactionArgument] | ResetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "reset_game(uint64,bool,bool,uint64,pay)void",
            "args": method_args,
        }))

    def delete_game(
        self,
        args: tuple[int] | DeleteGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_game(uint64)void",
            "args": method_args,
        }))

    def generate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "generate()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class _PieoutDeleteSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def terminate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "terminate()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)


class PieoutSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_PieoutDeleteSend":
        return _PieoutDeleteSend(self.app_client)

    def calc_single_box_cost(
        self,
        args: tuple[int, int] | CalcSingleBoxCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "calc_single_box_cost(uint8,uint16)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def read_gen_unix(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "read_gen_unix()uint64",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def does_box_game_trophy_exist(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_trophy_exist()bool",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def does_box_game_register_exist(
        self,
        args: tuple[str | bytes] | DoesBoxGameRegisterExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_register_exist(account)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def does_box_game_state_exist(
        self,
        args: tuple[int] | DoesBoxGameStateExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "does_box_game_state_exist(uint64)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def read_box_game_players(
        self,
        args: tuple[int] | ReadBoxGamePlayersArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[list[str]]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "read_box_game_players(uint64)address[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[list[str]], parsed_response)

    def mint_trophy(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | MintTrophyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_trophy(pay,pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def claim_trophy(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "claim_trophy()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def get_box_game_register(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | GetBoxGameRegisterArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_box_game_register(pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def del_box_game_register_for_self(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "del_box_game_register_for_self()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def del_box_game_register_for_other(
        self,
        args: tuple[str | bytes] | DelBoxGameRegisterForOtherArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "del_box_game_register_for_other(account)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def new_game(
        self,
        args: tuple[bool, int, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | NewGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "new_game(bool,uint64,pay,pay,pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def join_game(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_game(uint64,pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def set_game_commit(
        self,
        args: tuple[int] | SetGameCommitArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_game_commit(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def up_ref_budget_for_play_game(
        self,
        args: tuple[int] | UpRefBudgetForPlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "up_ref_budget_for_play_game(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def play_game(
        self,
        args: tuple[int] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "play_game(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def trigger_game_event(
        self,
        args: tuple[int, int] | TriggerGameEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "trigger_game_event(uint64,uint8)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def reset_game(
        self,
        args: tuple[int, bool, bool, int, algokit_utils.AppMethodCallTransactionArgument] | ResetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "reset_game(uint64,bool,bool,uint64,pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def delete_game(
        self,
        args: tuple[int] | DeleteGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_game(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def generate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "generate()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    game_id: int

class BoxStateValue(typing.TypedDict):
    """Shape of box state key values"""
    box_game_trophy: GameTrophy

class PieoutState:
    """Methods to access state for the current Pieout app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def game_id(self) -> int:
        """Get the current value of the game_id key in global_state state"""
        value = self.app_client.state.global_state.get_value("game_id")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "GameTrophy": GameTrophy,
            "GameState": GameState,
            "GameRegister": GameRegister
        }

    def get_all(self) -> BoxStateValue:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return typing.cast(BoxStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(BoxStateValue, converted)

    @property
    def box_game_trophy(self) -> GameTrophy:
        """Get the current value of the box_game_trophy key in box state"""
        value = self.app_client.state.box.get_value("box_game_trophy")
        if isinstance(value, dict) and "GameTrophy" in self._struct_classes:
            return _init_dataclass(self._struct_classes["GameTrophy"], value)  # type: ignore
        return typing.cast(GameTrophy, value)

    @property
    def box_game_state(self) -> "_MapState[int, GameState]":
        """Get values from the box_game_state map in box state"""
        return _MapState(
            self.app_client.state.box,
            "box_game_state",
            self._struct_classes.get("GameState")
        )

    @property
    def box_game_players(self) -> "_MapState[int, bytes]":
        """Get values from the box_game_players map in box state"""
        return _MapState(
            self.app_client.state.box,
            "box_game_players",
            None
        )

    @property
    def box_game_register(self) -> "_MapState[str, GameRegister]":
        """Get values from the box_game_register map in box state"""
        return _MapState(
            self.app_client.state.box,
            "box_game_register",
            self._struct_classes.get("GameRegister")
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class PieoutClient:
    """Client for interacting with Pieout smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = PieoutParams(self.app_client)
        self.create_transaction = PieoutCreateTransactionParams(self.app_client)
        self.send = PieoutSend(self.app_client)
        self.state = PieoutState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "PieoutClient":
        return PieoutClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "PieoutClient":
        return PieoutClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "PieoutClient":
        return PieoutClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "PieoutComposer":
        return PieoutComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["calc_single_box_cost(uint8,uint16)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["read_gen_unix()uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["does_box_game_trophy_exist()bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["does_box_game_register_exist(account)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["does_box_game_state_exist(uint64)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["read_box_game_players(uint64)address[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> list[str] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["mint_trophy(pay,pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["claim_trophy()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_box_game_register(pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["del_box_game_register_for_self()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["del_box_game_register_for_other(account)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["new_game(bool,uint64,pay,pay,pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["join_game(uint64,pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["set_game_commit(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["up_ref_budget_for_play_game(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["play_game(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["trigger_game_event(uint64,uint8)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["reset_game(uint64,bool,bool,uint64,pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["delete_game(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["generate()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["terminate()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | bool | int | list[str]:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class PieoutMethodCallCreateParams(
    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[
        typing.Any,
        str | None,
    ]
):
    """Parameters for creating Pieout contract using ABI"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallCreateParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

@dataclasses.dataclass(frozen=True)
class PieoutMethodCallDeleteParams(
    algokit_utils.BaseAppClientMethodCallParams[
        typing.Any,
        str | None,
    ]
):
    """Parameters for calling Pieout contract using ABI"""
    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

class PieoutFactory(algokit_utils.TypedAppFactoryProtocol[PieoutMethodCallCreateParams, None, PieoutMethodCallDeleteParams]):
    """Factory for deploying and managing PieoutClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = PieoutFactoryParams(self.app_factory)
        self.create_transaction = PieoutFactoryCreateTransaction(self.app_factory)
        self.send = PieoutFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: PieoutMethodCallCreateParams | None = None,
        update_params: None = None,
        delete_params: PieoutMethodCallDeleteParams | None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[PieoutClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return PieoutClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> PieoutClient:
        """Get an app client by creator address and name"""
        return PieoutClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> PieoutClient:
        """Get an app client by app ID"""
        return PieoutClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class PieoutFactoryParams:
    """Parameters for creating transactions for Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = PieoutFactoryCreateParams(app_factory)
        self.update = PieoutFactoryUpdateParams(app_factory)
        self.delete = PieoutFactoryDeleteParams(app_factory)

class PieoutFactoryCreateParams:
    """Parameters for 'create' operations of Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def calc_single_box_cost(
        self,
        args: tuple[int, int] | CalcSingleBoxCostArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the calc_single_box_cost(uint8,uint16)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "calc_single_box_cost(uint8,uint16)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def read_gen_unix(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the read_gen_unix()uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "read_gen_unix()uint64",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def does_box_game_trophy_exist(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the does_box_game_trophy_exist()bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "does_box_game_trophy_exist()bool",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def does_box_game_register_exist(
        self,
        args: tuple[str | bytes] | DoesBoxGameRegisterExistArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the does_box_game_register_exist(account)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "does_box_game_register_exist(account)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def does_box_game_state_exist(
        self,
        args: tuple[int] | DoesBoxGameStateExistArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the does_box_game_state_exist(uint64)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "does_box_game_state_exist(uint64)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def read_box_game_players(
        self,
        args: tuple[int] | ReadBoxGamePlayersArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the read_box_game_players(uint64)address[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "read_box_game_players(uint64)address[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def mint_trophy(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | MintTrophyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the mint_trophy(pay,pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "mint_trophy(pay,pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def claim_trophy(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the claim_trophy()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "claim_trophy()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def get_box_game_register(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | GetBoxGameRegisterArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_box_game_register(pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_box_game_register(pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def del_box_game_register_for_self(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the del_box_game_register_for_self()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "del_box_game_register_for_self()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def del_box_game_register_for_other(
        self,
        args: tuple[str | bytes] | DelBoxGameRegisterForOtherArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the del_box_game_register_for_other(account)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "del_box_game_register_for_other(account)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def new_game(
        self,
        args: tuple[bool, int, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | NewGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the new_game(bool,uint64,pay,pay,pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "new_game(bool,uint64,pay,pay,pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def join_game(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | JoinGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the join_game(uint64,pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "join_game(uint64,pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def set_game_commit(
        self,
        args: tuple[int] | SetGameCommitArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the set_game_commit(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "set_game_commit(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def up_ref_budget_for_play_game(
        self,
        args: tuple[int] | UpRefBudgetForPlayGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the up_ref_budget_for_play_game(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "up_ref_budget_for_play_game(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def play_game(
        self,
        args: tuple[int] | PlayGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the play_game(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "play_game(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def trigger_game_event(
        self,
        args: tuple[int, int] | TriggerGameEventArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the trigger_game_event(uint64,uint8)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "trigger_game_event(uint64,uint8)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def reset_game(
        self,
        args: tuple[int, bool, bool, int, algokit_utils.AppMethodCallTransactionArgument] | ResetGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the reset_game(uint64,bool,bool,uint64,pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "reset_game(uint64,bool,bool,uint64,pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def delete_game(
        self,
        args: tuple[int] | DeleteGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the delete_game(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "delete_game(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def generate(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the generate()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "generate()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def terminate(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the terminate()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "terminate()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class PieoutFactoryUpdateParams:
    """Parameters for 'update' operations of Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class PieoutFactoryDeleteParams:
    """Parameters for 'delete' operations of Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class PieoutFactoryCreateTransaction:
    """Create transactions for Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = PieoutFactoryCreateTransactionCreate(app_factory)


class PieoutFactoryCreateTransactionCreate:
    """Create new instances of Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class PieoutFactorySend:
    """Send calls to Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = PieoutFactorySendCreate(app_factory)


class PieoutFactorySendCreate:
    """Send create calls to Pieout contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[PieoutClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return PieoutClient(result[0]), result[1]

    def generate(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> tuple[PieoutClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:
            """Creates and sends a transaction using the generate()void ABI method"""
            params = params or algokit_utils.CommonAppCallCreateParams()
            client, result = self.app_factory.send.create(
                algokit_utils.AppFactoryCreateMethodCallParams(
                    **{
                    **dataclasses.asdict(params),
                    "method": "generate()void",
                    "args": None,
                    }
                ),
                send_params=send_params,
                compilation_params=compilation_params
            )
            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)
    
            return PieoutClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](
                **{
                    **result.__dict__,
                    "app_id": result.app_id,
                    "abi_return": return_value,
                    "transaction": result.transaction,
                    "confirmation": result.confirmation,
                    "group_id": result.group_id,
                    "tx_ids": result.tx_ids,
                    "transactions": result.transactions,
                    "confirmations": result.confirmations,
                    "app_address": result.app_address,
                }
            )


class _PieoutDeleteComposer:
    def __init__(self, composer: "PieoutComposer"):
        self.composer = composer
    def terminate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self.composer._composer.add_app_delete_method_call(
            self.composer.client.params.delete.terminate(
                
                params=params,
                
            )
        )
        self.composer._result_mappers.append(
            lambda v: self.composer.client.decode_return_value(
                "terminate()void", v
            )
        )
        return self.composer


class PieoutComposer:
    """Composer for creating transaction groups for Pieout contract calls"""

    def __init__(self, client: "PieoutClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    @property
    def delete(self) -> "_PieoutDeleteComposer":
        return _PieoutDeleteComposer(self)

    def calc_single_box_cost(
        self,
        args: tuple[int, int] | CalcSingleBoxCostArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.calc_single_box_cost(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "calc_single_box_cost(uint8,uint16)uint64", v
            )
        )
        return self

    def read_gen_unix(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.read_gen_unix(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "read_gen_unix()uint64", v
            )
        )
        return self

    def does_box_game_trophy_exist(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.does_box_game_trophy_exist(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "does_box_game_trophy_exist()bool", v
            )
        )
        return self

    def does_box_game_register_exist(
        self,
        args: tuple[str | bytes] | DoesBoxGameRegisterExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.does_box_game_register_exist(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "does_box_game_register_exist(account)bool", v
            )
        )
        return self

    def does_box_game_state_exist(
        self,
        args: tuple[int] | DoesBoxGameStateExistArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.does_box_game_state_exist(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "does_box_game_state_exist(uint64)bool", v
            )
        )
        return self

    def read_box_game_players(
        self,
        args: tuple[int] | ReadBoxGamePlayersArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.read_box_game_players(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "read_box_game_players(uint64)address[]", v
            )
        )
        return self

    def mint_trophy(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | MintTrophyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.mint_trophy(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "mint_trophy(pay,pay)void", v
            )
        )
        return self

    def claim_trophy(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.claim_trophy(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "claim_trophy()void", v
            )
        )
        return self

    def get_box_game_register(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | GetBoxGameRegisterArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_box_game_register(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_box_game_register(pay)void", v
            )
        )
        return self

    def del_box_game_register_for_self(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.del_box_game_register_for_self(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "del_box_game_register_for_self()void", v
            )
        )
        return self

    def del_box_game_register_for_other(
        self,
        args: tuple[str | bytes] | DelBoxGameRegisterForOtherArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.del_box_game_register_for_other(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "del_box_game_register_for_other(account)void", v
            )
        )
        return self

    def new_game(
        self,
        args: tuple[bool, int, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | NewGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.new_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "new_game(bool,uint64,pay,pay,pay)void", v
            )
        )
        return self

    def join_game(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.join_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "join_game(uint64,pay)void", v
            )
        )
        return self

    def set_game_commit(
        self,
        args: tuple[int] | SetGameCommitArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.set_game_commit(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "set_game_commit(uint64)void", v
            )
        )
        return self

    def up_ref_budget_for_play_game(
        self,
        args: tuple[int] | UpRefBudgetForPlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.up_ref_budget_for_play_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "up_ref_budget_for_play_game(uint64)void", v
            )
        )
        return self

    def play_game(
        self,
        args: tuple[int] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.play_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "play_game(uint64)void", v
            )
        )
        return self

    def trigger_game_event(
        self,
        args: tuple[int, int] | TriggerGameEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.trigger_game_event(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "trigger_game_event(uint64,uint8)void", v
            )
        )
        return self

    def reset_game(
        self,
        args: tuple[int, bool, bool, int, algokit_utils.AppMethodCallTransactionArgument] | ResetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.reset_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "reset_game(uint64,bool,bool,uint64,pay)void", v
            )
        )
        return self

    def delete_game(
        self,
        args: tuple[int] | DeleteGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.delete_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "delete_game(uint64)void", v
            )
        )
        return self

    def generate(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "PieoutComposer":
        self._composer.add_app_call_method_call(
            self.client.params.generate(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "generate()void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "PieoutComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "PieoutComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
