# tests/pieout_localnet_test.py
import logging
from datetime import datetime
import time

import pytest
from algokit_subscriber import SubscribedTransaction
from algokit_utils import (
    AppCallMethodCallParams,
    AppClientCompilationParams,
    CommonAppCallParams,
    FundAppAccountParams,
    OnSchemaBreak,
    OnUpdate,
    PaymentParams,
    SendParams,
    TealTemplateParams,
    micro_algo,
)
from algokit_utils.algorand import AlgorandClient
from algokit_utils.models import SigningAccount
from algosdk.abi.method import Method
from algosdk.transaction import wait_for_confirmation

from smart_contracts.artifacts.pieout.pieout_client import (
    PieoutClient,
    PieoutFactory,
    PieoutMethodCallCreateParams,
    PieoutMethodCallDeleteParams,
)
from smart_contracts.pieout import constants as cst

from .helpers import create_payment_txn, send_app_call_txn
from .subscriber import (
    AlgorandSubscriber,
    create_subscriber,
)

# Setup the logging.Logger
logger = logging.getLogger(__name__)


# Return an instance of the AlgorandSubscriber object to listen for network events
@pytest.fixture(scope="session")
def subscriber(algorand: AlgorandClient) -> AlgorandSubscriber:
    return create_subscriber(
        algod_client=algorand.client.algod,
        indexer_client=algorand.client.indexer,
        app_id=1002,
        max_rounds_to_sync=100,
    )


# Return an instance of the AlgorandClient object from the environment config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    algorand = AlgorandClient.from_environment()
    algorand.set_default_validity_window(validity_window=1000)
    return algorand


# Return a dispenser account as SigningAccount object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> SigningAccount:
    return algorand.account.dispenser_from_environment()  # LocalNet


# Generate a random account that will act as the default creator account for testing
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: SigningAccount) -> SigningAccount:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Send signed payment transaction using the Algorand client
    algorand.send.payment(
        PaymentParams(
            sender=dispenser.address,
            signer=dispenser.signer,
            receiver=creator.address,
            amount=micro_algo(50_000_000),
        )
    )
    # Return the creator account
    return creator


# Return a typed smart contract factory with default sender and signer
@pytest.fixture(scope="session")
def app_factory(
    algorand: AlgorandClient,
    creator: SigningAccount,
) -> PieoutFactory:
    # Define the on-deployment/compilation parameters
    template_params: TealTemplateParams = {
        "GEN_UNIX": int(datetime.now().timestamp()),
    }

    # Return typed app factory object
    return algorand.client.get_typed_app_factory(
        PieoutFactory,
        default_sender=creator.address,
        default_signer=creator.signer,
        compilation_params=AppClientCompilationParams(
            deploy_time_params=template_params,
            updatable=None,
            deletable=True,
        ),
    )


# Create a factory that can generate an arbitrary amount of random localnet test accounts called Randy
@pytest.fixture(scope="session")
def randy_factory(algorand: AlgorandClient, dispenser: SigningAccount) -> dict:
    # Define the number of randy accounts that will be created and used for testing
    randy_accounts = 9

    # Create a list to store all the randy accounts that were randomly generated by the Algorand client
    randies = [algorand.account.random() for _ in range(randy_accounts)]

    # Create a list to store all the funding amounts (first randy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(randy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for randy, amount in zip(randies, funding_amounts):
        algorand.send.payment(
            PaymentParams(
                sender=dispenser.address,
                signer=dispenser.signer,
                receiver=randy.address,
                amount=micro_algo(amount),
            )
        )

    # Return a dict with all randy accounts (output: dict[str, AddressAndSigner])
    return {f"randy_{i+1}": randy for i, randy in enumerate(randies)}


# Create smart contract client using factory deploy method
@pytest.fixture(scope="session")
def sc_client(app_factory: PieoutFactory) -> PieoutClient:
    # Provide deployment requirements and extract the smart contract client from the app factory
    sc_client = app_factory.deploy(
        on_update=OnUpdate.ReplaceApp,
        on_schema_break=OnSchemaBreak.ReplaceApp,
        create_params=PieoutMethodCallCreateParams(
            method="generate",
            max_fee=micro_algo(5_000),
            note=b'pieout:j{"concern":"txn.app_call;generate"}',
        ),
        delete_params=PieoutMethodCallDeleteParams(
            method="terminate",
            max_fee=micro_algo(5_000),
            note=b'pieout:j{"concern":"txn.app_call;terminate"}',
        ),
    )[0]

    # Return the smart contract client w/ creator account as default sender and signer
    return sc_client


# Create a dict called apps that stores as many smart contract clients as needed
@pytest.fixture(scope="session")
def apps(
    sc_client: PieoutClient,
) -> dict:
    # Initialize new dict that stores the creator smart contract as its first element
    apps = {"pieout_client_1": PieoutClient(app_client=sc_client.app_client)}

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {apps['pieout_client_1'].app_id}"
    )  #  Check client 1 app ID

    # Return apps dict with app clients (output: dict[str, PieoutClient])
    return apps


# Fund smart contract app account (app creator is account doing the funding, implied by use of their client instance)
def test_fund_app_mbr(apps: dict[str, PieoutClient]) -> None:
    # Get smart contract application client from from apps dict
    app_client = apps["pieout_client_1"].app_client
    # Send a payment transaction to make the app account operable by funding its base minimum balance requirement
    fund_app_txn = app_client.fund_app_account(
        FundAppAccountParams(
            note=b'pieout:j{"method":"fund_app_account","concern":"txn.pay;fund_base_mbr"}',
            amount=micro_algo(100_000),
        )
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(app_client.algorand.client.algod, fund_app_txn.tx_id, 3)
    assert (
        fund_app_txn.confirmation
    ), "fund_app_txn.confirmation transaction failed confirmation."


# Test case for sending an app call transaction to the `mint_trophy` method of the smart contract
def test_mint_trophy(
    creator: SigningAccount,
    apps: dict[str, PieoutClient],
) -> None:
    # Get smart contract application from from apps dict
    app = apps["pieout_client_1"]

    read_box_game_trophy_before_txn = app.send.does_box_game_trophy_exist(
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
        )
    )

    # Define nested function that attemps to call the `mint_trophy` method
    def try_mint_trophy_txn(
        sender: SigningAccount, note: bytes | str | None = None
    ) -> None:
        # Create the required payment transactions
        box_t_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=cst.BOX_T_COST,
            note=b'pieout:j{"concern":"txn.pay;box_t_mbr_pay"}',
        )  # Box game trophy MBR cost payment

        mint_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=100_000,
            note=b'pieout:j{"concern":"txn.pay;asset_create_pay"}',
        )  # Asset creation payment

        # Send app call transaction to execute smart contract method `mint_trophy`
        send_app_call_txn(
            logger=logger,
            app=app,
            sender=sender,
            method=app.send.mint_trophy,
            args=(box_t_pay, mint_pay),
            max_fee=micro_algo(100_000),
            note=note,
            send_params=SendParams(cover_app_call_inner_transaction_fees=True),
            description="Mint Trophy App Call",
        )

    # Call `try_mint_trophy_txn`
    try_mint_trophy_txn(
        sender=creator,
        note=b'pieout:j{"method":"mint_trophy","concern":"txn.app_call;asset_cfg_create"}',
    )

    # Second call should trip assert error cause trophy already exists
    # try_mint_trophy_txn(
    #     sender=creator,
    #     note=b'pieout:j{"method":"mint_trophy","concern":"txn.app_call;mint_trophy_asset2"}',
    #     )

    read_box_game_trophy_after_txn = app.send.does_box_game_trophy_exist(
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
        )
    )

    # Log
    logger.info(f"Before mint: {read_box_game_trophy_before_txn.abi_return}")
    logger.info(f"After mint: {read_box_game_trophy_after_txn.abi_return}")


# Test case for app call transaction to call `get_box_commit_rand` method of the smart contract
def test_get_box_game_register(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
) -> None:
    # Get smart contract application from from apps dict
    app = apps["pieout_client_1"]

    # Define nested function that attemps to call the `get_box_game_register` method
    def try_get_box_game_register_txn(
        sender: SigningAccount, note: bytes | str | None = None
    ) -> None:
        # Create the required payment transactions
        box_r_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=cst.BOX_R_COST,
            note=b'pieout:j{"concern":"txn.pay;box_r_mbr_pay"}',
        )  # Box game register MBR cost payment

        # Send app call transaction to execute smart contract method `get_box_game_register`
        send_app_call_txn(
            logger=logger,
            app=app,
            sender=sender,
            method=app.send.get_box_game_register,
            args=(box_r_pay,),
            max_fee=micro_algo(50_000),
            note=note,
            description="Get Box Game Register App Call",
        )

    # Call `try_get_box_game_register_txn` for creator
    try_get_box_game_register_txn(
        sender=creator,
        note=b'pieout:j{"method":"get_box_game_register","concern":"txn.app_call;get_box_game_register_creator"}',
    )

    # Randies to get box game register
    randies_reg_list = [
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        "randy_9",
    ]

    # For every randy in `randies_reg_list`
    for randy in randies_reg_list:
        # Call `try_get_box_game_register_txn`
        try_get_box_game_register_txn(
            sender=randy_factory[randy],
            note=b'pieout:j{"method":"get_box_game_register","concern":"txn.app_call;get_box_game_register_randy_enum"}',
        )


# Test case for app call transaction to call `new_game` method of the smart contract
def test_new_game(
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
) -> None:
    # Log
    logger.info("Testing new_game()")

    # Get smart contract applicationfrom from apps dict
    app = apps["pieout_client_1"]

    # Define nested function that attemps to call the `new_game` method
    def try_new_game_txn(
        sender: SigningAccount,
        quick_play_enabled: bool,  # noqa: FBT001
        max_players: int,
        note: bytes | str | None = None
    ) -> None:
        # Define payment amounts
        box_p_cost = (
            apps["pieout_client_1"]
            .send.calc_single_box_cost((10, max_players * 32))
            .abi_return
        )

        # Create the required payment transactions
        box_s_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=cst.BOX_S_COST,
            note=b'pieout:j{"concern":"txn.pay;box_s_mbr_pay"}',
        )  # Box game state MBR cost payment
        box_p_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=box_p_cost,
            note=b'pieout:j{"concern":"txn.pay;box_p_mbr_pay"}',
        )  # Box game players MBR cost payment
        stake_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=cst.STAKE_AMOUNT,
            note=b'pieout:j{"concern":"txn.pay;admin_stake_deposit_pay"}',
        )  # Admin stake deposit for prize pool payment

        # Send app call transaction to execute smart contract method `new_game`
        send_app_call_txn(
            logger=logger,
            app=app,
            sender=sender,
            method=app.send.new_game,
            args=(quick_play_enabled, max_players, box_s_pay, box_p_pay, stake_pay),
            max_fee=micro_algo(3_000),
            note=note,
            description="New Game App Call",
        )

    # Call `try_new_game_txn`
    try_new_game_txn(
        sender=randy_factory["randy_1"],
        quick_play_enabled=True,
        max_players=8,
        note=b'pieout:j{"method":"new_game","concern":"txn.app_call;new_game_randy_1_admin"}',
    )
    try_new_game_txn(
        sender=randy_factory["randy_2"],
        quick_play_enabled=False,
        max_players=10,
        note=b'pieout:j{"method":"new_game","concern":"txn.app_call;new_game_randy_2_admin"}',
    )

    # Another call from randy_2 should trip assert error cause only one game instance per account allowed
    # try_new_game_txn(
    #     sender=randy_factory["randy_2"],
    #     max_players=12,
    #     note=b'pieout:j{"method":"new_game","concern":"txn.app_call;new_game_randy_2_admin"}'
    #     )

    # Log
    game_1_state = app.app_client.state.box.get_map_value(
        map_name="box_game_state",
        key=int.to_bytes(1, length=8, byteorder="big"))

    game_2_state = app.app_client.state.box.get_map_value(
        map_name="box_game_state",
        key=int.to_bytes(2, length=8, byteorder="big"))

    logger.info(game_1_state)
    logger.info(game_2_state)


# Test case for app call transaction to call `join_game` method of the smart contract
def test_join_game(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # subscriber: AlgorandSubscriber,
) -> None:
    # Log
    logger.info("Testing join_game()")

    # Get smart contract applicationfrom from apps dict
    app = apps["pieout_client_1"]

    # Define the event listener for the app subscriber
    def batch_handler(txns: list[SubscribedTransaction], filter_name: str) -> None:
        logger.info(f"[{filter_name}] Received batch of {len(txns)} transactions")

        for txn in txns:
            txn_id = txn.get("id", "<no-id>")
            arc28_events = txn.get("arc28_events", [])

            for event in arc28_events:
                if isinstance(event, dict):
                    event_name = event.get("event_name", "<no-event-name>")
                    args = event.get("args_by_name", {})
                    logger.info(
                        f"[{filter_name}] Event: {event_name} | Txn ID: {txn_id}"
                    )
                    for arg_name, arg_value in args.items():
                        logger.info(f"  - {arg_name}: {arg_value}")
                else:
                    logger.warning(f"[{filter_name}] Unexpected event format: {event}")

    # subscriber.on_batch("pieout_filter", batch_handler)

    # Define nested function that attemps to call the `join_game` method
    def try_join_game_txn(
        sender: SigningAccount, game_id: int, note: bytes | str | None = None
    ) -> None:
        # Create the required payment transactions
        stake_pay = create_payment_txn(
            app=app,
            sender=sender,
            amount=cst.STAKE_AMOUNT,
            note=b'pieout:j{"concern":"txn.pay;player_stake_deposit_pay"}',
        )  # Player stake deposit for prize pool payment

        # Send app call transaction to execute smart contract method `join_game`
        send_app_call_txn(
            logger=logger,
            app=app,
            sender=sender,
            method=app.send.join_game,
            args=(game_id, stake_pay),
            max_fee=micro_algo(50_000),
            note=note,
            description="Join Game App Call",
        )

    # Call `try_join_game_txn` as creator for game_id=1
    # try_join_game_txn(
    #     sender=creator,
    #     game_id=1,
    #     note=b'pieout:j{"method":"join_game","concern":"txn.app_call;join_game_id_1_creator"}',
    # )

    # Randies list joining Game 1
    # Since they are admin of Game 1, randy_1 acc is already a player by default
    randies_game_1_list = [
        # "randy_2",
        # "randy_3",
        # "randy_4",
        # "randy_5",
        # "randy_6",
        # "randy_7",
    ]

    # For every randy in `randies_game_1_list`
    for randy in randies_game_1_list:
        # Call `try_join_game_txn` as randy for Game 1
        try_join_game_txn(
            sender=randy_factory[randy],
            game_id=1,
            note=b'pieout:j{"method":"join_game","concern":"txn.app_call;join_game_id_1_randy_enum"}',
        )

    # Call `try_join_game_txn` as creator for Game 2
    try_join_game_txn(
        sender=creator,
        game_id=2,
        note=b'pieout:j{"method":"join_game","concern":"txn.app_call;join_game_id_2_creator"}',
    )

    # Randies list joining Game 2
    # Since they are admin of Game 2, randy_2 acc is already a player by default
    randies_game_2_list = [
        "randy_1",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        # "randy_9",
    ]

    # For every randy in `randies_game_2_list`
    for randy in randies_game_2_list:
        # Call `try_join_game_txn` as randy for Game 2
        try_join_game_txn(
            sender=randy_factory[randy],
            game_id=2,
            note=b'pieout:j{"method":"join_game","concern":"txn.app_call;join_game_id_2_enum"}',
        )

    # Log
    game_1_state = app.app_client.state.box.get_map_value(
        map_name="box_game_state",
        key=int.to_bytes(1, length=8, byteorder="big"))

    game_1_players = app.app_client.state.box.get_map_value(
        map_name="box_game_players",
        key=int.to_bytes(1, length=8, byteorder="big"))

    game_2_state = app.app_client.state.box.get_map_value(
        map_name="box_game_state",
        key=int.to_bytes(2, length=8, byteorder="big"))

    logger.info(game_1_state)
    logger.info(game_1_players)
    logger.info(game_2_state)

    # Poll subscriber
    # subscriber.poll_once()

# Test case for app call transaction to call `trigger_game_event` method of the smart contract
def test_trigger_game_event(
    # creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
) -> None:
    # Log
    logger.info("Testing trigger_game_event()")

    # Get smart contract application from from apps dict
    app = apps["pieout_client_1"]

    # Define nested function that attemps to call the `trigger_game_event` method
    def try_trigger_game_event_txn(
        sender: SigningAccount,
        game_id: int,
        trigger_id: int,
        note: bytes | str | None = None
    ) -> None:

        # Send app call transaction to execute smart contract method `trigger_game_event`
        send_app_call_txn(
            logger=logger,
            app=app,
            sender=sender,
            method=app.send.trigger_game_event,
            args=(game_id, trigger_id),
            max_fee=micro_algo(2_000),
            note=note,
            send_params=SendParams(cover_app_call_inner_transaction_fees=True),
            description="Trigger Game Event App Call",
        )

    # Call `try_trigger_game_event_txn` for Game 1 and Game Event w/ trigger id 2
    try_trigger_game_event_txn(
        sender=randy_factory["randy_1"],  # Should fail when 'sender' is not admin
        game_id=1,  # Should fail when 'game_id=2', it has quick play mode disabled
        trigger_id=0,
        note=b'pieout:j{"method":"trigger_game_prog","concern":"txn.app_call;trigger_game_1_event_0_admin"}',
    )

    # Log
    game_1_state = app.app_client.state.box.get_map_value(
        map_name="box_game_state",
        key=int.to_bytes(1, length=8, byteorder="big"))

    game_1_players = app.app_client.state.box.get_map_value(
        map_name="box_game_players",
        key=int.to_bytes(1, length=8, byteorder="big"))

    game_2_state = app.app_client.state.box.get_map_value(
        map_name="box_game_state",
        key=int.to_bytes(2, length=8, byteorder="big"))

    logger.info(game_1_state)
    logger.info(game_1_players)
    logger.info(game_2_state)

    logger.info(f"Global State: {app.state.global_state.get_all()}")

# # Test case for app call transaction to call `set_game_commit` method of the smart contract
# def test_set_game_commit(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get smart contract applicationfrom from apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function to try `set_game_commit` method call
#     def try_set_game_commit_txn(
#         sender: SigningAccount, game_id: int, note: bytes | str | None = None
#     ) -> None:
#         # Send app call transaction to execute smart contract method `set_game_commit`
#         send_app_call_txn(
#             logger=logger,
#             app=app,
#             sender=sender,
#             method=app.send.set_game_commit,
#             args=(game_id,),
#             note=note,
#             description="Set Game Commit App Call",
#         )

#     # Randies to set_game_commit
#     randies_set_list = [
#         "randy_1",
#         "randy_2",
#         "randy_3",
#         "randy_4",
#         "randy_5",
#         "randy_6",
#         "randy_7",
#         # "randy_8",
#         # "randy_9",
#     ]

#     # Call `try_set_game_commit_txn` for creator
#     try_set_game_commit_txn(
#         sender=creator,
#         game_id=1,
#         note=b'pieout:j{"method":"set_game_commit","concern":"txn.app_call;set_game_commit_creator"}',
#     )

#     # For every randy in `randies_set_list`
#     for randy in randies_set_list:
#         # Call `try_set_game_commit_txn`
#         try_set_game_commit_txn(
#             sender=randy_factory[randy],
#             game_id=1,
#             note=b'pieout:j{"method":"set_game_commit","concern":"txn.app_call;set_game_commit_randy_enum"}',
#         )

#     # Log App Global State
#     logger.info(f"Global State: {apps["pieout_client_1"].state.global_state.get_all()}")


# # Test case for app call transaction to call `play_game` method of the smart contract
# def test_play_game(
#     subscriber: AlgorandSubscriber,
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get smart contract application from from apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function that attemps to call the `play_game` method
#     def try_play_game_txn(
#         sender: SigningAccount,
#         game_id: int,
#         note_1: bytes | str | None = None,
#         note_2: bytes | str | None = None,
#     ) -> None:
#         # Create a new atomic group composer
#         composer = app.new_group().composer()

#         # Add `add_resource_budget_play_game` abimethod as first transaction of group
#         composer.add_app_call_method_call(
#             params=AppCallMethodCallParams(
#                 sender=sender.address,
#                 signer=sender.signer,
#                 app_id=app.app_id,
#                 max_fee=micro_algo(100_000),
#                 method=Method.from_signature(
#                     s="up_ref_budget_for_play_game(uint64)void"
#                 ),
#                 args=[game_id],
#                 note=note_1,
#             )
#         )

#         # Add `play_game` abimethod as second transaction of group
#         composer.add_app_call_method_call(
#             params=AppCallMethodCallParams(
#                 sender=sender.address,
#                 signer=sender.signer,
#                 app_id=app.app_id,
#                 max_fee=micro_algo(31_000),
#                 method=Method.from_signature(s="play_game(uint64)void"),
#                 args=[game_id],
#                 note=note_2,
#             )
#         )

#         # Use composer to send group transaction for sender
#         composer.send(params=SendParams(cover_app_call_inner_transaction_fees=True))

#     # Randies to play Game 1
#     randies_game_1 = [
#         "randy_1",
#         "randy_2",
#         "randy_3",
#         "randy_4",
#         "randy_5",
#         "randy_6",
#         "randy_7",
#         # "randy_8",
#         # "randy_9",
#     ]

#     # Call `try_play_game` for creator
#     try_play_game_txn(
#         sender=creator,
#         game_id=1,
#         note_1=b'pieout:j{"method":"up_ref_budget_for_play_game","concern":"txn.app_call;up_ref_budget_for_play_game_creator"}',
#         note_2=b'pieout:j{"method":"play_game","concern":"txn.app_call;play_game_creator"}',
#     )

#     # For every randy in `randies_game_1`
#     for randy in randies_game_1:
#         # Call `try_play_game`
#         try_play_game_txn(
#             sender=randy_factory[randy],
#             game_id=1,
#             note_1=b'pieout:j{"method":"up_ref_budget_for_play_game","concern":"txn.app_call;up_ref_budget_for_play_game_randy_enum"}',
#             note_2=b'pieout:j{"method":"play_game","concern":"txn.app_call;play_game_randy_enum"}',
#         )

#     # Send read-only transaction to read the game state of Game 1
#     read_game_1_state_txn = app.send.read_box_game_state(
#         args=(1,),
#         params=CommonAppCallParams(
#             sender=creator.address,
#             signer=creator.signer,
#         ),
#     )

#     # Send read-only transaction to read the game register box from creator and randy 1 accounts
#     read_creator_reg_txn = app.send.read_box_game_register(
#         args=(creator.address,),
#         params=CommonAppCallParams(
#             sender=creator.address,
#             signer=creator.signer,
#         ),
#     )
#     read_randy_1_reg_txn = app.send.read_box_game_register(
#         args=(randy_factory["randy_1"].address,),
#         params=CommonAppCallParams(
#             sender=creator.address,
#             signer=creator.signer,
#         ),
#     )

#     # Log
#     logger.info(read_game_1_state_txn.abi_return)
#     logger.info(read_creator_reg_txn.abi_return)
#     logger.info(read_randy_1_reg_txn.abi_return)

#     # Run subscriber in poll once mode
#     subscriber.poll_once()


# # Test case for app call transaction to call `trigger_game_event` method of the smart contract
# def test_trigger_game_event(
#     creator: SigningAccount,
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get smart contract application from from apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function that attemps to call the `trigger_game_event` method
#     def try_trigger_game_event_txn(
#         sender: SigningAccount,
#         game_id: int,
#         trigger_id: int,
#         note: bytes | str | None = None
#     ) -> None:

#         # Send app call transaction to execute smart contract method `trigger_game_event`
#         send_app_call_txn(
#             logger=logger,
#             app=app,
#             sender=sender,
#             method=app.send.trigger_game_event,
#             args=(game_id, trigger_id),
#             max_fee=micro_algo(2_000),
#             note=note,
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Trigger Game Event App Call",
#         )

#     # Call `try_trigger_game_event_txn` for Game 1 and Game Event w/ trigger id 2
#     try_trigger_game_event_txn(
#         sender=creator,
#         game_id=1,
#         trigger_id=2,
#         note=b'pieout:j{"method":"trigger_game_prog","concern":"txn.app_call;trigger_game_1_event_2_prog"}',
#     )

#     # Send read-only transaction to read the game register box from creator and randy 1 accounts
#     read_game_1_state_txn = app.send.read_box_game_state(
#         args=(1,),
#         params=CommonAppCallParams(
#             sender=creator.address,
#             signer=creator.signer
#         ),
#     )

#     # Log
#     logger.info(read_game_1_state_txn.abi_return)
#     logger.info(f"Global State: {app.state.global_state.get_all()}")

# # Test case for app call transaction to call `del_box_game_register_for_self` method of the smart contract
# def test_del_box_game_register_for_self(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get smart contract application from from apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function that attemps to call the `del_box_game_register_for_self` method
#     def try_del_box_game_register_for_self_txn(
#         sender: SigningAccount,
#         game_id: int,
#         note: bytes | str | None = None
#     ) -> None:

#         # Send app call transaction to execute smart contract method `del_box_game_register_for_self`
#         send_app_call_txn(
#             logger=logger,
#             app=app,
#             sender=sender,
#             method=app.send.del_box_game_register_for_self,
#             args=(game_id, ),
#             max_fee=micro_algo(20_000),
#             note=note,
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Del Box Commit Rand For Self App Call",
#         )

#     # Randies to self delete box game register
#     randies_to_del_list = [
#         "randy_1",
#         "randy_2",
#         "randy_3",
#         "randy_4",
#         "randy_5",
#         "randy_6",
#         "randy_7",
#         # "randy_8",
#         # "randy_9",
#     ]

#     # Call `try_del_box_game_register_for_self_txn` for creator
#     try_del_box_game_register_for_self_txn(
#         sender=creator,
#         game_id=1,
#         note=b'pieout:j{"method":"del_box_game_register_for_self","concern":"txn.app_call;del_box_game_register_for_self_creator"}',
#     )

#     # For every randy in `randies_to_del_list`
#     for randy in randies_to_del_list:
#         # Call `try_del_box_game_register_for_self_txn`
#         try_del_box_game_register_for_self_txn(
#             sender=randy_factory[randy],
#             game_id=1,
#             note=b'pieout:j{"method":"del_box_game_register_for_self","concern":"txn.app_call;del_box_game_register_for_self_randy_enum"}',
#         )

#     # Log App Global State
#     logger.info(f"Global State: {app.state.global_state.get_all()}")


# # Test case for app call transaction to call `del_box_game_register_for_other` method of the smart contract
# def test_del_box_game_register_for_other(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get the app client from the apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function to try `del_box_game_register_for_other` method call
#     def try_del_box_game_register_for_other_txn(
#         sender: SigningAccount,
#         player: SigningAccount,
#         note: bytes | str | None = None
#     ) -> None:

#         # Send app call transaction to execute smart contract method `del_box_game_register_for_other`
#         send_app_call_txn(
#             logger=logger,
#             app=app,
#             sender=sender,
#             method=app.send.del_box_game_register_for_other,
#             args=(player, ),
#             max_fee=micro_algo(2_000),
#             note=note,
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Del Box Game Register For Other App Call",
#         )

#     # Call `try_del_box_game_register_for_other_txn` for creator
#     try_del_box_game_register_for_other_txn(
#         sender=randy_factory["randy_1"],
#         player=creator.address,
#         note=b'pieout:j{"method":"del_box_game_register_for_other","concern":"txn.app_call;del_box_game_register_for_other_admin1_creator"}'
#     )

#     # Log App Global State
#     logger.info(f"Global State: {app.state.global_state.get_all()}")

# # Test case for app call transaction to call `reset_game` method of the smart contract
# def test_reset_game(
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get smart contract application from from apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function that attemps to call the `reset_game` method
#     def try_reset_game_txn(
#         sender: SigningAccount,
#         game_id: int,
#         note: bytes | str | None = None
#     ) -> None:
#         # Create the required payment transactions
#         stake_pay = create_payment_txn(
#             app=app,
#             sender=sender,
#             amount=cst.STAKE_AMOUNT_MANAGER,
#             note=b'pieout:j{"concern":"txn.pay;admin_stake_deposit_pay"}'
#         )  # Admin stake deposit for prize pool payment

#         # Send app call transaction to execute smart contract method `reset_game`
#         send_app_call_txn(
#             logger=logger,
#             app=app,
#             sender=sender,
#             method=app.send.reset_game,
#             args=(game_id, stake_pay),
#             note=note,
#             description="Reset Game App Call",
#         )

#     # Call `try_reset_game_txn` for Game 1
#     try_reset_game_txn(
#         sender=randy_factory["randy_1"],
#         game_id=1,
#         note=b'pieout:j{"method":"reset_game","concern":"txn.app_call;reset_game_id_1"}',
#     )

# # Test case for app call transaction to call `delete_game` method of the smart contract
# def test_delete_game(
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:
#     # Get the app client from the apps dict
#     app = apps["pieout_client_1"]

#     # Define nested function that attemps to call the `delete_game` method
#     def try_delete_game_txn(
#         sender: SigningAccount,
#         game_id: int,
#         note: bytes | str | None = None
#     ) -> None:

#         # Send app call transaction to execute smart contract method `delete_game`
#         send_app_call_txn(
#             logger=logger,
#             app=app,
#             sender=sender,
#             method=app.send.delete_game,
#             args=(game_id,),
#             max_fee=micro_algo(5_000),
#             note=note,
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Delete Game App Call",
#         )

#     # Call `try_delete_game_txn` for Game 1
#     try_delete_game_txn(
#         sender=randy_factory["randy_1"],
#         game_id=1,
#         note=b'pieout:j{"method":"delete_game","concern":"txn.app_call;delete_game_id_1"}',
#     )
