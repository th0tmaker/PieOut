# tests/opal_test.py
import json
import logging
from datetime import datetime

import pytest
from algokit_utils import (
    AppClientCompilationParams,
    FundAppAccountParams,
    OnSchemaBreak,
    OnUpdate,
    PaymentParams,
    TealTemplateParams,
    micro_algo,
)
from algokit_utils.algorand import AlgorandClient
from algokit_utils.models import SigningAccount
from algosdk.abi import Contract
from algosdk.transaction import wait_for_confirmation
from artifacts.pieout.pieout_client import (
    PieoutClient,
    PieoutFactory,
    PieoutMethodCallCreateParams,
    PieoutMethodCallDeleteParams,
)

# Setup the logging.Logger
logger = logging.getLogger(__name__)


# Return an instance of the Algorand client from the default localnet config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    return AlgorandClient.from_environment()


# Create a dispenser account as SigningAccount object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> SigningAccount:
    return algorand.account.dispenser_from_environment()


# Generate a creator account for testing and fund it with some ALGO via the dispenser account
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: SigningAccount) -> SigningAccount:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Send signed payment transaction using the Algorand client
    algorand.send.payment(
        PaymentParams(
            sender=dispenser.address,
            signer=dispenser.signer,
            validity_window=100,
            receiver=creator.address,
            amount=micro_algo(50_000_000),
        )
    )
    # Return the creator account
    return creator


# Fixture that provides a typed smart contract factory with default sender and signer
@pytest.fixture(scope="session")
def app_factory(algorand: AlgorandClient, creator: SigningAccount) -> PieoutFactory:
    return algorand.client.get_typed_app_factory(
        PieoutFactory,
        default_sender=creator.address,
        default_signer=creator.signer,
    )


# Create a factory that can generate an arbitrary amount of random accounts called Randy
@pytest.fixture(scope="session")
def randy_factory(algorand: AlgorandClient, dispenser: SigningAccount) -> dict:
    # Define the number of randy accounts that will be created and used for testing
    randy_accounts = 1

    # Create a list to store all the randy accounts that were randomly generated by the Algorand client
    randies = [algorand.account.random() for _ in range(randy_accounts)]

    # Create a list to store all the funding amounts (first randy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(randy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for randy, amount in zip(randies, funding_amounts):
        algorand.send.payment(
            PaymentParams(
                sender=dispenser.address,
                signer=dispenser.signer,
                validity_window=100,
                receiver=randy.address,
                amount=micro_algo(amount),
            )
        )  # Send signed txn through the Algorand client

    # Return a dict with all randy accounts (output: dict[str, AddressAndSigner])
    return {f"randy_{i+1}": randy for i, randy in enumerate(randies)}


# Create smart contract client using factory deploy method
@pytest.fixture(scope="session")
def sc_client(app_factory: PieoutFactory) -> PieoutClient:

    # Define the on-deployment/compilation parameters
    template_params: TealTemplateParams = {
        "GEN_UNIX": int(datetime.now().timestamp()),
    }

    # Extract the app_client from the factory deploy method transaction
    sc_client = app_factory.deploy(
        on_update=OnUpdate.ReplaceApp,
        on_schema_break=OnSchemaBreak.ReplaceApp,
        create_params=PieoutMethodCallCreateParams(method="generate"),
        delete_params=PieoutMethodCallDeleteParams(method="terminate"),
        compilation_params=AppClientCompilationParams(
            deploy_time_params=template_params,
            updatable=None,
            deletable=True,
        ),
    )[0]

    # Return the deployed OpalTokenClient with creator as default sender and signer
    return sc_client


# Create a dict called apps that stores as many smart contract clients as needed
@pytest.fixture(scope="session")
def apps(
    sc_client: PieoutClient,
    randy_factory: dict[str, SigningAccount],
) -> dict:
    # Initialize new dict with creator app client (named "app_client_1") as its first element
    apps = {"pieout_client_1": PieoutClient(app_client=sc_client.app_client)}

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {apps['pieout_client_1'].app_id}"
    )  #  Check client 1 app ID
    # logger.info(  # Check client 1 Global State
    #     f"App Client 1 Global State: {apps['opal_token_client_1'].state.global_state.get_all()}"
    # )

    # Return apps dict with app clients (output: dict[str, OpalTokenClient])
    return apps


# Return an ABI compliant Contract object made from the smart contract json file
@pytest.fixture(scope="session")
def sc() -> Contract:
    with open("./smart_contracts/artifacts/pieout/Pieout.arc56.json") as f:
        js = json.load(f)

    # return Contract.from_json(json.dumps(js["methods"])) <- if you want specific key
    return Contract.from_json(json.dumps(js))


# Helper method to retrieve the latest asset ID (if needed) from a JSON file
@pytest.fixture(scope="session")
def latest_asset_id() -> int:
    try:
        with open("latest_asset_id.json") as f:
            data = json.load(f)
        return data["latest_asset_id"]
    except (FileNotFoundError, KeyError):
        return None


# # Fund smart contract app account (app creator is account doing the funding, implied by use of their client instance)
# def test_fund_app_mbr(apps: dict[str, PieoutClient]) -> None:
#     # Send transaction to fund smart contract app account minimum balance requirement
#     fund_app_txn = apps["pieout_client_1"].app_client.fund_app_account(
#         FundAppAccountParams(
#             amount=micro_algo(100_000),
#         )
#     )

#     # Verify transaction was confirmed by the network
#     wait_for_confirmation(
#         apps["pieout_client_1"].algorand.client.algod, fund_app_txn.tx_id, 3
#     )
#     assert (
#         fund_app_txn.confirmation
#     ), "fund_app_txn.confirmation transaction failed confirmation."
