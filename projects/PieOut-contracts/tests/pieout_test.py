# tests/opal_test.py
import base64
import json
import logging
from datetime import datetime

import pytest
from algokit_utils import (
    AppClientCompilationParams,
    CommonAppCallParams,
    FundAppAccountParams,
    OnSchemaBreak,
    OnUpdate,
    PaymentParams,
    TealTemplateParams,
    micro_algo,
)
from algokit_utils.algorand import AlgorandClient
from algokit_utils.models import SigningAccount
from algosdk.abi import Contract
from algosdk.transaction import wait_for_confirmation

from smart_contracts.artifacts.pieout.pieout_client import (
    PieoutClient,
    PieoutFactory,
    PieoutMethodCallCreateParams,
    PieoutMethodCallDeleteParams,
)

# Setup the logging.Logger
logger = logging.getLogger(__name__)


# Return an instance of the Algorand client from the default localnet config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    return AlgorandClient.from_environment()


# Create a dispenser account as SigningAccount object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> SigningAccount:
    return algorand.account.dispenser_from_environment()


# Generate a creator account for testing and fund it with some ALGO via the dispenser account
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: SigningAccount) -> SigningAccount:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Send signed payment transaction using the Algorand client
    algorand.send.payment(
        PaymentParams(
            sender=dispenser.address,
            signer=dispenser.signer,
            validity_window=100,
            receiver=creator.address,
            amount=micro_algo(50_000_000),
        )
    )
    # Return the creator account
    return creator


# Fixture that provides a typed smart contract factory with default sender and signer
@pytest.fixture(scope="session")
def app_factory(algorand: AlgorandClient, creator: SigningAccount) -> PieoutFactory:
    return algorand.client.get_typed_app_factory(
        PieoutFactory,
        default_sender=creator.address,
        default_signer=creator.signer,
    )


# Create a factory that can generate an arbitrary amount of random accounts called Randy
@pytest.fixture(scope="session")
def randy_factory(algorand: AlgorandClient, dispenser: SigningAccount) -> dict:
    # Define the number of randy accounts that will be created and used for testing
    randy_accounts = 9

    # Create a list to store all the randy accounts that were randomly generated by the Algorand client
    randies = [algorand.account.random() for _ in range(randy_accounts)]

    # Create a list to store all the funding amounts (first randy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(randy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for randy, amount in zip(randies, funding_amounts):
        algorand.send.payment(
            PaymentParams(
                sender=dispenser.address,
                signer=dispenser.signer,
                validity_window=100,
                receiver=randy.address,
                amount=micro_algo(amount),
            )
        )  # Send signed txn through the Algorand client

    # Return a dict with all randy accounts (output: dict[str, AddressAndSigner])
    return {f"randy_{i+1}": randy for i, randy in enumerate(randies)}


# Create smart contract client using factory deploy method
@pytest.fixture(scope="session")
def sc_client(app_factory: PieoutFactory) -> PieoutClient:

    # Define the on-deployment/compilation parameters
    template_params: TealTemplateParams = {
        "GEN_UNIX": int(datetime.now().timestamp()),
    }

    # Extract the app_client from the factory deploy method transaction
    sc_client = app_factory.deploy(
        on_update=OnUpdate.ReplaceApp,
        on_schema_break=OnSchemaBreak.ReplaceApp,
        create_params=PieoutMethodCallCreateParams(method="generate"),
        delete_params=PieoutMethodCallDeleteParams(method="terminate"),
        compilation_params=AppClientCompilationParams(
            deploy_time_params=template_params,
            updatable=None,
            deletable=True,
        ),
    )[0]

    # Return the deployed OpalTokenClient with creator as default sender and signer
    return sc_client


# Create a dict called apps that stores as many smart contract clients as needed
@pytest.fixture(scope="session")
def apps(
    sc_client: PieoutClient,
) -> dict:
    # Initialize new dict with creator app client (named "app_client_1") as its first element
    apps = {"pieout_client_1": PieoutClient(app_client=sc_client.app_client)}

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {apps['pieout_client_1'].app_id}"
    )  #  Check client 1 app ID
    # logger.info(  # Check client 1 Global State
    #     f"App Client 1 Global State: {apps['opal_token_client_1'].state.global_state.get_all()}"
    # )

    # Return apps dict with app clients (output: dict[str, OpalTokenClient])
    return apps


# Return an ABI compliant Contract object made from the smart contract json file
@pytest.fixture(scope="session")
def sc() -> Contract:
    with open("./smart_contracts/artifacts/pieout/Pieout.arc56.json") as f:
        js = json.load(f)

    # return Contract.from_json(json.dumps(js["methods"])) <- if you want specific key
    return Contract.from_json(json.dumps(js))


# Helper method to retrieve the winning player from a JSON file
@pytest.fixture(scope="session")
def winning_player() -> SigningAccount:
    try:
        with open("winning_player.json") as f:
            data = json.load(f)

        private_key = data["private_key"]
        address = data["address"]

        return SigningAccount(private_key=private_key, address=address)
    except (FileNotFoundError, KeyError, json.JSONDecodeError):
        return None


# Fund smart contract app account (app creator is account doing the funding, implied by use of their client instance)
def test_fund_app_mbr(apps: dict[str, PieoutClient]) -> None:
    # Send transaction to fund smart contract app account minimum balance requirement
    fund_app_txn = apps["pieout_client_1"].app_client.fund_app_account(
        FundAppAccountParams(
            amount=micro_algo(100_000),
        )
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(
        apps["pieout_client_1"].algorand.client.algod, fund_app_txn.tx_id, 3
    )
    assert (
        fund_app_txn.confirmation
    ), "fund_app_txn.confirmation transaction failed confirmation."


def test_new_game(creator: SigningAccount, apps: dict[str, PieoutClient]) -> None:
    max_players = 10
    box_g_fee = apps["pieout_client_1"].send.calc_single_box_fee((10, 46)).abi_return
    box_p_fee = (
        apps["pieout_client_1"]
        .send.calc_single_box_fee((10, (max_players * 32)))
        .abi_return
    )

    box_g_pay = apps["pieout_client_1"].algorand.create_transaction.payment(
        PaymentParams(
            sender=creator.address,
            signer=creator.signer,
            validity_window=100,
            receiver=apps["pieout_client_1"].app_address,
            amount=micro_algo(box_g_fee),
        )
    )

    box_p_pay = apps["pieout_client_1"].algorand.create_transaction.payment(
        PaymentParams(
            sender=creator.address,
            signer=creator.signer,
            validity_window=100,
            receiver=apps["pieout_client_1"].app_address,
            amount=micro_algo(box_p_fee),
        )
    )

    new_game_txn = apps["pieout_client_1"].send.new_game(
        args=(max_players, box_g_pay, box_p_pay),
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
            validity_window=100,
        ),
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(
        apps["pieout_client_1"].algorand.client.algod, new_game_txn.tx_id, 3
    )
    assert (
        new_game_txn.confirmation
    ), "new_game_txn.confirmation transaction failed confirmation."

    # Log
    all_boxes = apps["pieout_client_1"].algorand.client.algod.application_boxes(
        application_id=apps["pieout_client_1"].app_id
    )

    for box in all_boxes["boxes"]:
        box_name = base64.b64decode(box["name"])

        # Get box value by name
        box_response = apps[
            "pieout_client_1"
        ].algorand.client.algod.application_box_by_name(
            application_id=apps["pieout_client_1"].app_id, box_name=box_name
        )

        box_value = base64.b64decode(box_response["value"])
        logger.info(f"Box Name: {box_name}, Box Value: {list(box_value)}")


def test_join_game(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
) -> None:

    game_id = 0
    join_game_txn = apps["pieout_client_1"].send.join_game(
        args=(game_id,),
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
            validity_window=100,
        ),
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(
        apps["pieout_client_1"].algorand.client.algod, join_game_txn.tx_id, 3
    )
    assert (
        join_game_txn.confirmation
    ), "join_game_txn.confirmation transaction failed confirmation."

    join_game_txn = apps["pieout_client_1"].send.join_game(
        args=(game_id,),
        params=CommonAppCallParams(
            sender=randy_factory["randy_1"].address,
            signer=randy_factory["randy_1"].signer,
            validity_window=100,
        ),
    )

    # Log
    all_boxes = apps["pieout_client_1"].algorand.client.algod.application_boxes(
        application_id=apps["pieout_client_1"].app_id
    )

    for box in all_boxes["boxes"]:
        box_name = base64.b64decode(box["name"])

        # Get box value by name
        box_response = apps[
            "pieout_client_1"
        ].algorand.client.algod.application_box_by_name(
            application_id=apps["pieout_client_1"].app_id, box_name=box_name
        )

        box_value = base64.b64decode(box_response["value"])
        logger.info(f"Box Name: {box_name}, Box Value: {list(box_value)}")


# def test_stake(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:

#     def stake_call_params(
#         account: SigningAccount,
#     ) -> tuple[BoxReference, Transaction, Transaction]:
#         if account.address == creator.address:
#             stake_amount = 272_000
#         else:
#             stake_amount = 500_000

#         box_fee = apps["pieout_client_1"].send.calc_single_box_fee((34, 2)).abi_return

#         box_pay = apps["pieout_client_1"].algorand.create_transaction.payment(
#             PaymentParams(
#                 sender=account.address,
#                 signer=account.signer,
#                 validity_window=100,
#                 receiver=apps["pieout_client_1"].app_address,
#                 amount=micro_algo(box_fee),
#             )
#         )

#         stake_pay = apps["pieout_client_1"].algorand.create_transaction.payment(
#             PaymentParams(
#                 sender=account.address,
#                 signer=account.signer,
#                 validity_window=100,
#                 receiver=apps["pieout_client_1"].app_address,
#                 amount=micro_algo(stake_amount),
#             )
#         )

#         box_name = b"p_" + decode_address(account.address)
#         box_ref = BoxReference(app_index=apps["pieout_client_1"].app_id, name=box_name)

#         return box_ref, box_pay, stake_pay

#     # Individual stake transactions
#     def try_stake_txn(account: SigningAccount) -> bool:
#         try:
#             _, box_pay, stake_pay = stake_call_params(account)

#             stake_txn = apps["pieout_client_1"].send.stake(
#                 args=(box_pay,),
#                 params=CommonAppCallParams(
#                     sender=account.address,
#                     signer=account.signer,
#                     max_fee=micro_algo(11_000),
#                     validity_window=100,
#                 ),
#                 send_params=SendParams(
#                     populate_app_call_resources=True,
#                     cover_app_call_inner_transaction_fees=True,
#                 ),
#             )

#             # Verify transaction was confirmed by the network
#             wait_for_confirmation(
#                 apps["pieout_client_1"].algorand.client.algod, stake_txn.tx_id, 3
#             )
#             assert (
#                 stake_txn.confirmation
#             ), "stake_txn.confirmation transaction failed confirmation."

#             logger.info(f"Stake TXN INFO: {stake_txn.confirmation}")
#             return True

#         except Exception as e:
#             logger.error(
#                 f"Individual stake transaction failed for {account.address}: {e}"
#             )
#             return False

#     participants = [creator] + [
#         randy_factory[f"randy_{i}"] for i in range(1, len(randy_factory) + 1)
#     ]

#     # Atomic stake transaction
#     def try_stake_atxn() -> None:
#         try:
#             composer = apps["pieout_client_1"].new_group().composer()

#             for account in participants:
#                 box_ref, box_pay, stake_pay = stake_call_params(account)

#                 composer.add_app_call_method_call(
#                     AppCallMethodCallParams(
#                         sender=account.address,
#                         signer=account.signer,
#                         # lease=b"testing-lease",
#                         validity_window=100,
#                         app_id=apps["pieout_client_1"].app_id,
#                         method=Method.from_signature("stake(pay,pay)void"),
#                         args=[box_pay, stake_pay],
#                         box_references=[box_ref],
#                     )
#                 )

#             # atxn_result = composer.send()
#             logger.info(f"atxn group size: {composer.count()}")
#             logger.info(len(participants))
#             # logger.info(f"Atomic group stake transaction sent. Group ID: {atxn_result.group_id}")

#         except Exception as e:
#             logger.error(f"Atomic group stake transaction failed: {e}")

#     try_stake_txn(participants[0])

#     box = apps["pieout_client_1"].algorand.client.algod.application_box_by_name(
#         apps["pieout_client_1"].app_id, b"p_" + decode_address(participants[0].address)
#     )

#     logger.info(list(base64.b64decode(box["value"])))

# logger.info(int.from_bytes(bytes=box_byte_arr[:2], byteorder="big"))

# spread = box_byte_arr[6:]
# numbers = []

# for i in range(0, len(spread), 2):
#     uint16_bytes = spread[i : i + 2]
#     number = int.from_bytes(uint16_bytes, byteorder="big")
#     numbers.append(number)

# logger.info(numbers)

# # Run individual stake in different rounds
# for account in participants:
#     try_stake_txn(account)
# box = apps["pieout_client_1"].algorand.client.algod.application_box_by_name(
#     apps["pieout_client_1"].app_id, b"pa_")
# logger.info(list(base64.b64decode(box["value"])))


#     # Run atomic stake in same round
#     # attempt_atomic_stake()


# def test_gamba(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
# ) -> None:

#     def get_active_players() -> list[SigningAccount]:
#         # Create all_players list once outside the loop
#         all_players = [creator] + [randy_factory[f"randy_{i}"] for i in range(1, 10)]
#         active_addresses = set()

#         # Fetch all boxes
#         current_turn = apps["pieout_client_1"].state.global_state.current_turn
#         boxes = (
#             apps["pieout_client_1"]
#             .algorand.client.algod.application_boxes(apps["pieout_client_1"].app_id)
#             .get("boxes", [])
#         )

#         for box in boxes:
#             box_name_bytes = base64.b64decode(box["name"])
#             box_val = apps[
#                 "pieout_client_1"
#             ].algorand.client.algod.application_box_by_name(
#                 apps["pieout_client_1"].app_id, box_name_bytes
#             )

#             # The value is base64 encoded in the response
#             # box_val_byte_arr = list(base64.b64decode(box_val["value"]))
#             player_turn = int.from_bytes(base64.b64decode(box_val["value"]))
#             # Only process boxes for the current turn and add box names to the set
#             if player_turn == current_turn:
#                 active_addresses.add(encode_address(box_name_bytes[-32:]))

#         # Match players with active addresses
#         active_players = [
#             player for player in all_players if player.address in active_addresses
#         ]
#         return active_players

#     def create_box_refs(accounts: list[SigningAccount]) -> list[BoxReference]:
#         app_id = apps["pieout_client_1"].app_id
#         return [
#             BoxReference(app_id, b"p_" + decode_address(acc.address))
#             for acc in accounts
#         ]

#     def try_gamba_txn(account: SigningAccount) -> bool:
#         try:
#             gamba_txn = apps["pieout_client_1"].send.gamba(
#                 params=CommonAppCallParams(
#                     sender=account.address,
#                     signer=account.signer,
#                     validity_window=100,
#                     # lease=b"testing-lease2"
#                 ),
#                 send_params=SendParams(
#                     populate_app_call_resources=True,
#                 ),
#             )

#             # Verify transaction was confirmed by the network
#             wait_for_confirmation(
#                 apps["pieout_client_1"].algorand.client.algod, gamba_txn.tx_id, 3
#             )
#             assert (
#                 gamba_txn.confirmation
#             ), "gamba_txn.confirmation transaction failed confirmation."

#             # Log
#             logger.info(f"Gamba TXN INFO: {gamba_txn.confirmation}")
#             logger.info(f"Gamba abi return: {gamba_txn.abi_return}")
#             # some_box_name = base64.b64decode(app_boxes["boxes"][0]["name"])

#             # box = algorand.client.algod.application_box_by_name(
#             #     apps["vrf456_client_1"].app_id, some_box_name

#             return True

#         except Exception as e:
#             logger.error(f"Gamba transaction failed for {account.address}: {e}")
#             return False

#     # Atomic gamba transaction
#     def try_gamba_atxn(
#         # account: SigningAccount,
#         accounts: list[SigningAccount],
#     ) -> bool:
#         try:
#             composer = apps["pieout_client_1"].new_group().composer()

#             for acc in accounts:
#                 composer.add_app_call_method_call(
#                     AppCallMethodCallParams(
#                         sender=acc.address,
#                         signer=acc.signer,
#                         note=int(datetime.now().timestamp()).to_bytes(
#                             length=8, byteorder="big"
#                         ),
#                         max_fee=micro_algo(3000),
#                         validity_window=100,
#                         app_id=apps["pieout_client_1"].app_id,
#                         method=Method.from_signature("gamba()uint64"),
#                         # box_references=[],  # First 8 box references
#                     )
#                 )
#                 time.sleep(1)

#             # # Second transaction with remaining 3 box references
#             # composer.add_app_call_method_call(
#             #     AppCallMethodCallParams(
#             #         sender=account.address,
#             #         signer=account.signer,
#             #         validity_window=100,
#             #         app_id=apps["pieout_client_1"].app_id,
#             #         method=Method.from_signature("up_ref_budget()uint64"),
#             #         # box_references=[],  # Remaining 3 box references
#             #     )
#             # )

#             # logger.info(len(box_refs))
#             logger.info(f"Gamba atomic group size: {composer.count()}")

#             result = composer.send(
#                 params=SendParams(
#                     cover_app_call_inner_transaction_fees=True,
#                 )
#             )

#             logger.info(f"Gamba atomic group sent. Group ID: {result.group_id}")
#             for i, r in enumerate(result.returns):
#                 logger.info(
#                     f"TXN {i}: abi return value={r.value}, round={r.tx_info['confirmed-round']}"
#                 )

#             return True

#         except Exception as e:
#             logger.error(f"Atomic gamba group transaction failed: {e}")
#             return False

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     active_players = get_active_players()
#     logger.info(len(active_players))
#     try_gamba_atxn(active_players)

#     if len(active_players) == 1:
#         winning_player = active_players[0]
#         winning_player_data = {
#             "address": winning_player.address,
#             "private_key": winning_player.private_key,
#         }

#         with open("winning_player.json", "w") as f:
#             json.dump(winning_player_data, f)


#     # Log
#     logger.info(
#         f"App Client 1 Global State: {apps['pieout_client_1'].state.global_state.get_all()}"
#     )

#     all_boxes = apps["pieout_client_1"].algorand.client.algod.application_boxes(
#         apps["pieout_client_1"].app_id
#     )

#     # Extract all addresses from the app boxes
#     box_p_dict = {}  # Dictionary to store box values

#     for box in all_boxes.get("boxes", []):
#         box_name_bytes = base64.b64decode(box["name"])
#         if len(box_name_bytes) == 34:
#             box_key_addr = encode_address(box_name_bytes[-32:])

#             # Get the value of this specific box
#             box_val = apps[
#                 "pieout_client_1"
#             ].algorand.client.algod.application_box_by_name(
#                 apps["pieout_client_1"].app_id, box_name_bytes
#             )
#             # The value is base64 encoded in the response
#             box_val_bytes = base64.b64decode(box_val["value"])
#             box_p_dict[box_key_addr] = list(box_val_bytes)

#     logger.info(box_p_dict)  # Log the box value

# def test_claim_stake(
#     # creator: SigningAccount,
#     winning_player: SigningAccount,
#     apps: dict[str, PieoutClient],
# ) -> None:

#     claim_stake_txn = apps["pieout_client_1"].send.claim_prize_pool(
#         params=CommonAppCallParams(
#             sender=winning_player.address,
#             signer=winning_player.signer,
#             # sender=creator.address,
#             # signer=creator.signer,
#             max_fee=micro_algo(2000),
#             validity_window=100,
#         ),
#         send_params=SendParams(
#             cover_app_call_inner_transaction_fees=True,
#         )
#     )

#     # Verify transaction was confirmed by the network
#     wait_for_confirmation(
#         apps["pieout_client_1"].algorand.client.algod, claim_stake_txn.tx_id, 3
#     )
#     assert (
#         claim_stake_txn.confirmation
#     ), "claim_stake_txn.confirmation transaction failed confirmation."

#     # Log
#     logger.info(f"Winning player addr: {winning_player.address}")

#     logger.info(
#         f"App Client 1 Global State: {apps['pieout_client_1'].state.global_state.get_all()}"
#     )
