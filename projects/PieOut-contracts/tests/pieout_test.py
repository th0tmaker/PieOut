# tests/opal_test.py
import base64
import json
import logging
from datetime import datetime

import pytest
from algokit_utils import (
    AppClientCompilationParams,
    BoxReference,
    CommonAppCallParams,
    FundAppAccountParams,
    OnSchemaBreak,
    OnUpdate,
    PaymentParams,
    SendParams,
    TealTemplateParams,
    micro_algo,
)
from algokit_utils.algorand import AlgorandClient
from algokit_utils.models import SigningAccount
from algokit_utils.transactions import AppCallMethodCallParams
from algosdk.abi import Contract, Method
from algosdk.encoding import encode_address
from algosdk.transaction import wait_for_confirmation


# from dotenv import load_dotenv
from smart_contracts.artifacts.pieout.pieout_client import (
    PieoutClient,
    PieoutFactory,
    PieoutMethodCallCreateParams,
    PieoutMethodCallDeleteParams,
)
from smart_contracts.pieout import constants as cst

from .helpers import create_payment_txn, send_app_call_txn, view_app_boxes
from .subscriber import (
    AlgorandSubscriber,
    create_subscriber,
    log_subbed_arc28_events,
)

# Setup the logging.Logger
logger = logging.getLogger(__name__)

# Load TestNet environment variables
# load_dotenv(".env.testnet")


# Return an instance of the AlgorandClient object from the default localnet config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    algorand = AlgorandClient.from_environment()
    algorand.set_default_validity_window(100)
    return algorand


# Return an instance of the AlgorandSubscriber object to listen for network events
@pytest.fixture(scope="session")
def subscriber(algorand: AlgorandClient) -> AlgorandSubscriber:
    return create_subscriber(algod_client=algorand.client.algod, max_rounds_to_sync=30)


# Return a dispenser account as SigningAccount object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> SigningAccount:
    return algorand.account.dispenser_from_environment()  # LocalNet
    # return algorand.client.get_testnet_dispenser()  # TestNet


# Generate a random account that will act as the default creator account for testing
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: SigningAccount) -> SigningAccount:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Send signed payment transaction using the Algorand client
    algorand.send.payment(
        PaymentParams(
            sender=dispenser.address,
            signer=dispenser.signer,
            receiver=creator.address,
            amount=micro_algo(50_000_000),
        )
    )
    # Return the creator account
    return creator


# # Create a dictionary to store any TestNet accounts that were genereated and written to a JSON file
# @pytest.fixture(scope="session")
# def accs() -> dict[str, SigningAccount]:
#     # Load TestNet account data from JSON
#     with open("testnet_accs.json") as f:
#         testnet_accs = json.load(f)

#     # Create a dictionary to store accounts for easy access
#     accs = {
#         name: SigningAccount(
#             private_key=testnet_accs[name]["private_key"],
#             address=testnet_accs[name]["address"],
#         )
#         for name in ["creator"] + [f"randy_{i}" for i in range(1, 8)]
#     }  # Change range `stop` param to add more accounts

#     # NOTE: Don't forget to fund the accounts with TestNet ALGO!
#     # Use a.) `TestNetDispenserApiClient` or b.) `https://bank.testnet.algorand.network/`

#     return accs


# Return a typed smart contract factory with default sender and signer
@pytest.fixture(scope="session")
def app_factory(
    algorand: AlgorandClient,
    creator: SigningAccount,
    # accs: dict[str, SigningAccount],
) -> PieoutFactory:
    # creator = accs["creator"]
    return algorand.client.get_typed_app_factory(
        PieoutFactory,
        default_sender=creator.address,
        default_signer=creator.signer,
    )


# Create a factory that can generate an arbitrary amount of random localnet test accounts called Randy
@pytest.fixture(scope="session")
def randy_factory(algorand: AlgorandClient, dispenser: SigningAccount) -> dict:
    # Define the number of randy accounts that will be created and used for testing
    randy_accounts = 9

    # Create a list to store all the randy accounts that were randomly generated by the Algorand client
    randies = [algorand.account.random() for _ in range(randy_accounts)]

    # Create a list to store all the funding amounts (first randy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(randy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for randy, amount in zip(randies, funding_amounts):
        algorand.send.payment(
            PaymentParams(
                sender=dispenser.address,
                signer=dispenser.signer,
                receiver=randy.address,
                amount=micro_algo(amount),
            )
        )  # Send signed txn through the Algorand client

    # Return a dict with all randy accounts (output: dict[str, AddressAndSigner])
    return {f"randy_{i+1}": randy for i, randy in enumerate(randies)}


# Create smart contract client using factory deploy method
@pytest.fixture(scope="session")
def sc_client(app_factory: PieoutFactory) -> PieoutClient:

    # Define the on-deployment/compilation parameters
    template_params: TealTemplateParams = {
        "GEN_UNIX": int(datetime.now().timestamp()),
    }

    # Extract the app_client from the factory deploy method transaction
    sc_client = app_factory.deploy(
        on_update=OnUpdate.ReplaceApp,
        on_schema_break=OnSchemaBreak.ReplaceApp,
        create_params=PieoutMethodCallCreateParams(method="generate"),
        delete_params=PieoutMethodCallDeleteParams(method="terminate"),
        compilation_params=AppClientCompilationParams(
            deploy_time_params=template_params,
            updatable=None,
            deletable=True,
        ),
    )[0]

    # Return the deployed PieoutClient with creator as default sender and signer
    return sc_client


# Create a dict called apps that stores as many smart contract clients as needed
@pytest.fixture(scope="session")
def apps(
    sc_client: PieoutClient,
) -> dict:
    # Initialize new dict with creator app client (named "app_client_1") as its first element
    apps = {"pieout_client_1": PieoutClient(app_client=sc_client.app_client)}

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {apps['pieout_client_1'].app_id}"
    )  #  Check client 1 app ID

    # Return apps dict with app clients (output: dict[str, PieoutClient])
    return apps


# Return an ABI compliant Contract object made from the smart contract json file
@pytest.fixture(scope="session")
def sc() -> Contract:
    with open("./smart_contracts/artifacts/pieout/Pieout.arc56.json") as f:
        js = json.load(f)

    # return Contract.from_json(json.dumps(js["methods"])) <- if you want specific key
    return Contract.from_json(json.dumps(js))


# Helper method to retrieve the winning player from a JSON file
@pytest.fixture(scope="session")
def winner_account() -> SigningAccount | None:
    try:
        with open("winner_account.json") as f:
            data = json.load(f)

        address = data["address"]
        private_key = data["private_key"]

        return SigningAccount(address=address, private_key=private_key)
    except (FileNotFoundError, KeyError, json.JSONDecodeError):
        return None


# Fund smart contract app account (app creator is account doing the funding, implied by use of their client instance)
def test_fund_app_mbr(apps: dict[str, PieoutClient]) -> None:
    # Send transaction to fund smart contract app account minimum balance requirement
    fund_app_txn = apps["pieout_client_1"].app_client.fund_app_account(
        FundAppAccountParams(
            # Fund 100_000 to cover app MBR + 100_000 to cover TRFY ASA + 6_500 fee for box_t_
            # amount=micro_algo(606_500),
            amount=micro_algo(100_000),  # <- just base MBR
            note="sender:creator_address,reciever:app_address,concern:fund_app_base_mbr",
        )
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(
        apps["pieout_client_1"].algorand.client.algod, fund_app_txn.tx_id, 3
    )
    assert (
        fund_app_txn.confirmation
    ), "fund_app_txn.confirmation transaction failed confirmation."


# Test case for executing an app call transaction to the `mint_trophy` method of the smart contract
def test_mint_trophy(
    creator: SigningAccount,
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]

    def try_mint_trophy_txn(
        account: SigningAccount,
    ) -> None:
        # Create the required payment transactions
        box_t_pay = create_payment_txn(
            app_client, account, cst.BOX_C_T_FEE
        )  # Game box trophy fee
        mint_pay = create_payment_txn(app_client, account, 100_000)  # asset create fee

        # Send app call transaction to smart contract method `mint_trophy`
        send_app_call_txn(
            logger=logger,
            app_client=app_client,
            account=account,
            method=app_client.send.mint_trophy,
            args=(box_t_pay, mint_pay),
            max_fee=micro_algo(2_000),
            send_params=SendParams(cover_app_call_inner_transaction_fees=True),
            description="Mint Trophy App Call",
        )

    # Call try mint trophy transaction function
    try_mint_trophy_txn(account=creator)


# Test case for executing an app call transaction to the `new_game` method of the smart contract
def test_new_game(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]

    # creator = accs["creator"]
    # randy_1 = accs["randy_1"]
    randy_1 = randy_factory["randy_1"]

    # Define nested function to try `new_game` method call
    def try_new_game_txn(
        account: SigningAccount,
        max_players: int,
    ) -> None:
        # Define payment amounts
        box_p_fee = app_client.send.calc_single_box_fee(
            (10, max_players * 32)
        ).abi_return

        # Create the required payment transactions
        box_s_pay = create_payment_txn(
            app_client, account, cst.BOX_S_FEE
        )  # Game box state fee
        box_p_pay = create_payment_txn(
            app_client, account, box_p_fee
        )  # Game box players fee
        stake_pay = create_payment_txn(
            app_client, account, cst.STAKE_AMOUNT_MANAGER
        )  # Manager stake deposit

        # Send app call transaction to smart contract method `new_game`
        send_app_call_txn(
            logger=logger,
            app_client=app_client,
            account=account,
            method=app_client.send.new_game,
            args=(max_players, box_s_pay, box_p_pay, stake_pay),
            description="New Game App Call",
        )

    # Call try new game transaction function
    try_new_game_txn(account=creator, max_players=10)

    # try_new_game_txn(account=randy_factory["randy_1"], max_players=8)  # LocalNet
    try_new_game_txn(account=randy_1, max_players=8)  # TestNet

    # View box data
    view_app_boxes(app_client, {b"s_", b"p_"}, logger)


# Test case for executing an app call transaction to the `join_game` method of the smart contract
def test_join_game(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
    subscriber: AlgorandSubscriber,
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]

    # NOTE: Uncomment to use subscriber for event listening
    # Register the event handler for filtered name `filter1`
    subscriber.on(
        "filter1",
        log_subbed_arc28_events(
            logger, events_to_log=["game_live", "player_score", "game_over"]
        ),
    )

    # Define nested function to try `join_game` method call
    def try_join_txn(
        account: SigningAccount,
        game_id: int,
    ) -> None:
        # Create the required payment transactions
        stake_pay = create_payment_txn(
            app_client, account, cst.STAKE_AMOUNT_OTHER
        )  # Other stake deposit

        # Send app call transaction to smart contract method `join_game`
        send_app_call_txn(
            logger=logger,
            app_client=app_client,
            account=account,
            method=app_client.send.join_game,
            args=(game_id, stake_pay),
            description="Join Game App Call",
        )

    # NOTE: Accounts joining Game 0 for LocalNet testing
    players_game_0 = [
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        "randy_9",
    ]
    for player in players_game_0:
        try_join_txn(account=randy_factory[player], game_id=0)

    # NOTE: Accounts joining Game 1 for LocalNet testing
    try_join_txn(account=creator, game_id=1)
    players_game_1 = ["randy_2", "randy_3", "randy_4", "randy_5", "randy_6", "randy_7"]
    for player in players_game_1:
        try_join_txn(account=randy_factory[player], game_id=1)

    # # NOTE: Accounts joinging Game 1 for TestNet testing
    # players_game_1 = [
    #     "creator",
    #     "randy_2",
    #     "randy_3",
    #     "randy_4",
    #     "randy_5",
    #     "randy_6",
    #     "randy_7",
    # ]
    # for player in players_game_1:
    #     # Since they are creator of Game 1, randy_1 acc is already a player by default
    #     try_join_txn(account=accs[player], game_id=1)

    read_game0_state_txn = app_client.send.read_game_state(
        args=(0,),
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
            # sender=accs["creator"].address,
            # signer=accs["creator"].signer
        ),
    )

    read_game1_state_txn = app_client.send.read_game_state(
        args=(1,),
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
            # sender=accs["creator"].address,
            # signer=accs["creator"].signer
        ),
    )

    # View box data
    view_app_boxes(app_client, {b"s_", b"p_"}, logger)

    # Log read game state transaction abi returns
    logger.info(read_game0_state_txn.abi_return)
    logger.info(read_game1_state_txn.abi_return)

    # Log App Global State
    logger.info(f"Global State: {app_client.state.global_state.get_all()}")


def test_get_box_commit_rand(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]

    # Define nested function to try `commit_rand` method call
    def try_get_box_commit_rand_txn(
        account: SigningAccount,
    ) -> None:
        # Create the required payment transactions
        box_c_pay = create_payment_txn(
            app_client, account, cst.BOX_C_T_FEE
        )  # Commit rand box fee

        # Send app call transaction to smart contract method `commit_rand`
        send_app_call_txn(
            logger=logger,
            app_client=app_client,
            account=account,
            method=app_client.send.get_box_commit_rand,
            args=(box_c_pay,),
            description="Get Box Commit Rand App Call",
        )

    # Accounts commiting rand game 0
    players_game_0 = [
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        "randy_9",
    ]

    try_get_box_commit_rand_txn(creator)
    for player in players_game_0:
        try_get_box_commit_rand_txn(randy_factory[player])


# Test case for executing an app call transaction to the `commit_rand` method of the smart contract
def test_commit_rand(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]

    # Define nested function to try `commit_rand` method call
    def try_commit_rand_txn(
        account: SigningAccount,
        game_id: int,
    ) -> None:
        # Send app call transaction to smart contract method `commit_rand`
        send_app_call_txn(
            logger=logger,
            app_client=app_client,
            account=account,
            method=app_client.send.commit_rand,
            args=(game_id,),
            description="Commit Rand App Call",
        )

    # Accounts commiting rand game 0
    players_game_0 = [
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        "randy_9",
    ]

    try_commit_rand_txn(creator, 0)
    for player in players_game_0:
        try_commit_rand_txn(randy_factory[player], 0)

    # Accounts commiting rand game 1
    players_game_1 = [
        # "creator",
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
    ]

    try_commit_rand_txn(creator, 1)
    for player in players_game_1:
        try_commit_rand_txn(randy_factory[player], 1)
        # try_commit_rand_txn(accs[player], 1)

    # View box data
    view_app_boxes(app_client, {b"s_", b"p_"}, logger)

    # Log App Global State
    logger.info(f"Global State: {app_client.state.global_state.get_all()}")


# Test case for executing an app call transaction to the `play_game` method of the smart contract
def test_play_game(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
    subscriber: AlgorandSubscriber,
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]

    box_t_ = app_client.algorand.client.algod.application_box_by_name(
        app_client.app_id, b"t_"
    )

    box_t_bytes = base64.b64decode(box_t_["value"])
    asset_id = int.from_bytes(box_t_bytes[:8], byteorder="big")
    owner_address = encode_address(box_t_bytes[8:])

    logger.info(f"Box Trophy Raw Bytes: {list(box_t_bytes)}")
    logger.info(f"Box Trophy Asset ID: {asset_id}")
    logger.info(f"Box Trophy Owner Address: {owner_address}")
    logger.info(f"ATH address before play {app_client.state.global_state.ath_address}")


    # Define nested function to try `play_game` method call
    def try_play_txn(
        account: SigningAccount,
        game_id: int,
    ) -> None:

        # Send app call transaction to smart contract method `play_game`
        # send_app_call_txn(
        #     logger=logger,
        #     app_client=app_client,
        #     account=account,
        #     method=app_client.send.play_game,
        #     args=(game_id,),
        #     max_fee=micro_algo(100_000),
        #     send_params=SendParams(cover_app_call_inner_transaction_fees=True),
        #     description="Play Game App Call",
        # )

        # # Create the required payment transactions
        # box_c_pay = create_payment_txn(
        #     app_client, account, cst.BOX_C_T_FEE
        # )  # Commit rand box fee

        read_game_state_sim_result = app_client.send.read_game_state(
            args=(game_id, ),
            params=CommonAppCallParams(
                sender=account.address,
                signer=account.signer
            ),
        )

        read_game_state_sim_return = read_game_state_sim_result.abi_return
        first_place_address = str(read_game_state_sim_return[11])
        second_place_address = str(read_game_state_sim_return[12])
        third_place_address = str(read_game_state_sim_return[13])

        logger.info("/")
        logger.info(f"First place acc: {first_place_address}")
        logger.info(f"Second place acc: {second_place_address}")
        logger.info(f"Third place acc: {third_place_address}")

        play_game_acc_refs = [
            addr for addr in (first_place_address, second_place_address, third_place_address)
            if addr != encode_address(cst.ZERO_ADDR_BYTES)
        ]
        play_game_box_refs = [BoxReference(app_id=app_client.app_id, name=b"t_")]
        # composer = app_client.new_group().composer()

        # composer.add_app_call_method_call(
        #     params=AppCallMethodCallParams(
        #         sender=account.address,
        #         signer=account.signer,
        #         max_fee=micro_algo(2_000),
        #         app_id=app_client.app_id,
        #         method=Method.from_signature("get_box_commit_rand(pay)void"),
        #         args=[box_c_pay],
        #         )
        #     )


        # composer.add_app_call_method_call(
        #     params=AppCallMethodCallParams(
        #         sender=account.address,
        #         signer=account.signer,
        #         max_fee=micro_algo(2_000),
        #         app_id=app_client.app_id,
        #         method=Method.from_signature("commit_rand(uint64)void"),
        #         args=[game_id],
        #         )
        #     )

        # composer.add_app_call_method_call(
        #     params=AppCallMethodCallParams(
        #         sender=account.address,
        #         signer=account.signer,
        #         max_fee=micro_algo(100_000),
        #         app_id=app_client.app_id,
        #         method=Method.from_signature("play_game(uint64)void"),
        #         args=[game_id],
        #         account_references=play_game_acc_refs,
        #         box_references=play_game_box_refs,
        #         )
        #     )

        # logger.info(f"group size: {composer.count()}")

        # result = composer.send(
        #     params=SendParams(cover_app_call_inner_transaction_fees=True))

        # logger.info(f"group id: {result.group_id}")
        # logger.info(f"group txn 0 id: {result.tx_ids[0]}")
        # logger.info(f"group txn 1 id: {result.tx_ids[1]}")
        # logger.info(f"group txn 2 id: {result.tx_ids[2]}")

        app_client.send.play_game(
            args=(game_id,),
            params=CommonAppCallParams(
                # account_references=play_game_acc_refs,
                # asset_references=[asset_id],
                # box_references=play_game_box_refs,
                max_fee=micro_algo(100_000),
                sender=account.address,
                signer=account.signer,
            ),
            send_params=SendParams(
                # populate_app_call_resources=True,
                cover_app_call_inner_transaction_fees=True,
            ),
        )

    # # Accounts playing game 0
    try_play_txn(creator, 0)
    logger.info(
        f"ATH address after creator play {app_client.state.global_state.ath_address}"
    )
    players_game_0 = [
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        "randy_9",
    ]
    for player in players_game_0:
        try_play_txn(randy_factory[player], 0)

    # # Accounts playing game 1
    # players_game_1 = [
    #     # "creator",
    #     "randy_1",
    #     "randy_2",
    #     "randy_3",
    #     "randy_4",
    #     "randy_5",
    #     "randy_6",
    #     "randy_7",
    # ]

    # try_play_txn(creator, 1)
    # for player in players_game_1:
    #     try_play_txn(randy_factory[player], 1)
    #     # try_play_txn(account=accs[player], game_id=1)

    # # try_play_txn(account=randy_factory["randy_8"], game_id=1)  # <- Should trip assert error

    # Run subscriber in poll once mode
    subscriber.poll_once()

    read_game0_state_txn = app_client.send.read_game_state(
        args=(0,),
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
            # sender=accs["creator"].address,
            # signer=accs["creator"].signer
        ),
    )

    read_game1_state_txn = app_client.send.read_game_state(
        args=(1,),
        params=CommonAppCallParams(
            sender=creator.address,
            signer=creator.signer,
            # sender=accs["creator"].address,
            # signer=accs["creator"].signer
        ),
    )

    # View box data
    view_app_boxes(app_client, {b"s_", b"p_"}, logger)

    # Log read game state transaction abi returns
    logger.info(read_game0_state_txn.abi_return)
    logger.info(read_game1_state_txn.abi_return)

    # Log App Global State
    logger.info(f"Global State: {app_client.state.global_state.get_all()}")


# Test case for executing an app call transaction to the `commit_rand` method of the smart contract
def test_del_box_commit_rand(
    creator: SigningAccount,
    randy_factory: dict[str, SigningAccount],
    apps: dict[str, PieoutClient],
    # accs: dict[str, SigningAccount],
) -> None:
    # Get the app client from the apps dict
    app_client = apps["pieout_client_1"]
    # creator = accs["creator"]

    # Define nested function to try `del_box_commit_rand` method call
    def try_del_box_commit_rand_txn(
        account: SigningAccount,
    ) -> None:

        # Send app call transaction to smart contract method `commit_rand`
        send_app_call_txn(
            logger=logger,
            app_client=app_client,
            account=account,
            method=app_client.send.del_box_commit_rand,
            max_fee=micro_algo(2_000),
            send_params=SendParams(cover_app_call_inner_transaction_fees=True),
            description="Del Box Commit Rand App Call",
        )

    # Accounts playing game 0
    try_del_box_commit_rand_txn(creator)
    players_game_0 = [
        "randy_1",
        "randy_2",
        "randy_3",
        "randy_4",
        "randy_5",
        "randy_6",
        "randy_7",
        "randy_8",
        "randy_9",
    ]
    for player in players_game_0:
        try_del_box_commit_rand_txn(randy_factory[player])

    # # Accounts playing game 1
    # players_game_1 = [
    #     # "creator",
    #     "randy_1",
    #     "randy_2",
    #     "randy_3",
    #     "randy_4",
    #     "randy_5",
    #     "randy_6",
    #     "randy_7",
    # ]

    # try_del_box_commit_rand_txn(creator)
    # for player in players_game_1:
    #     try_del_box_commit_rand_txn(randy_factory[player], 1)

    # Log App Global State
    logger.info(f"Global State: {app_client.state.global_state.get_all()}")


# # Test case for executing an app call transaction to the `expiry_payout` method of the smart contract
# def test_check_game_event(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
#     # accs: dict[str, SigningAccount],
# ) -> None:
#     # Get the app client from the apps dict
#     app_client = apps["pieout_client_1"]

#     # Define nested function to try `play_game` method call
#     def try_check_game_event_txn(
#         account: SigningAccount,
#         game_id: int,
#         game_id_event: int,
#     ) -> None:

#         # Send app call transaction to smart contract method `play_game`
#         send_app_call_txn(
#             logger=logger,
#             app_client=app_client,
#             account=account,
#             method=app_client.send.check_game_event,
#             args=(game_id, game_id_event),
#             max_fee=micro_algo(2_000),
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Check Game Event App Call",
#         )


#     try_check_game_event_txn(randy_factory["randy_1"], 1, 2)

#     # # Log box data
#     # log_app_boxes(app_client=app_client, logger=logger)

#     # read_game0_state_txn = app_client.send.read_game_state(
#     #     args=(0,),
#     #     params=CommonAppCallParams(
#     #         sender=creator.address,
#     #         signer=creator.signer
#     #         # sender=accs["creator"].address,
#     #         # signer=accs["creator"].signer
#     #     ),
#     # )

#     # read_game1_state_txn = app_client.send.read_game_state(
#     #     args=(1,),
#     #     params=CommonAppCallParams(
#     #         sender=creator.address,
#     #         signer=creator.signer
#     #         # sender=accs["creator"].address,
#     #         # signer=accs["creator"].signer
#     #     ),
#     # )

#     # logger.info(read_game0_state_txn.abi_return)
#     # logger.info(read_game1_state_txn.abi_return)
#     logger.info(f"Global State: {app_client.state.global_state.get_all()}")

# # Test case for simulating an app call `read_only=True` transaction to read current game state and get winner account
# def test_read_game_get_winner(
#     # creator: SigningAccount,
#     # randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
#     accs: dict[str, SigningAccount],
# ) -> None:
#     # Get the app client from the apps dict
#     app_client = apps["pieout_client_1"]
#     creator = accs["creator"]
#     randy_1 = accs["randy_1"]
#     # Define nested function to try and read game data
#     def try_read_game(account: SigningAccount, game_id: int, data: str) -> str | None:
#         params = CommonAppCallParams(sender=account.address, signer=account.signer)

#         try:
#             if data == "state":
#                 result = app_client.send.read_game_state(args=(game_id,), params=params)
#                 logger.info(result.abi_return)
#                 winner_address = result.abi_return[9]
#                 logger.info(winner_address)
#                 return str(winner_address)
#             elif data == "players":
#                 result = app_client.send.read_game_players(
#                     args=(game_id,), params=params
#                 )
#             else:
#                 logger.info(
#                     f"No readable reference found for: '{data}' data parameter."
#                 )
#                 return

#             logger.info(f"ABI return - {data.upper()} - {result.abi_return}")

#         except Exception as e:
#             logger.error(f"Failed to read '{data}' for game ID {game_id}: {e}")

#     try_read_game(account=randy_1, game_id=0, data="players")
#     # winner_address = try_read_game(account=creator, game_id=0, data="state")

#     try_read_game(account=randy_1, game_id=1, data="players")
#     winner_address = try_read_game(account=creator, game_id=1, data="state")

#     # Combine all accounts
#     accounts = [*list(accs.values())]
#     for acc in accounts:
#         if acc.address == winner_address:
#             winner_acc = {"address": acc.address, "private_key": acc.signer.private_key}

#             # Write the winner account into a json file
#             with open("winner_account.json", "w") as file:
#                 json.dump(winner_acc, file, indent=2)

#             logger.info("Winner data written to winner_account.json")
#             break
#     else:
#         logger.warning("No matching account found for winner address.")


# # Test case for executing an app call transaction to the `claim_prize_pool` method of the smart contract
# def test_claim_prize_pool(
#     # creator: SigningAccount,
#     apps: dict[str, PieoutClient],
#     accs: dict[str, SigningAccount],
#     winner_account: SigningAccount | None,
# ) -> None:
#     # Get the app client from the apps dict
#     app_client = apps["pieout_client_1"]

#     # Exit function with warning if winner account is None
#     if winner_account is None:
#         logger.warning(
#             "Exited test_claim_prize_pool before completion. No winner account found."
#         )
#         return

#     # Define nested function to try `claim_prize_pool` method call
#     def try_claim_prize_pool(
#         account: SigningAccount,
#         game_id: int,
#     ) -> None:

#         # Send app call transaction to smart contract method `claim_prize_pool`
#         send_app_call_txn(
#             app_client=app_client,
#             account=account,
#             method=app_client.send.claim_prize_pool,
#             args=(game_id,),
#             max_fee=micro_algo(2_000),
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Claim Prize Pool App Call"
#         )

#     # try_claim_prize_pool(account=winner_account, game_id=0)
#     try_claim_prize_pool(account=winner_account, game_id=1)

#     read_game_state_txn = app_client.send.read_game_state(
#         args=(1, ),
#         params=CommonAppCallParams(sender=accs["creator"].address, signer=accs["creator"].signer),
#     )

#     logger.info(read_game_state_txn.abi_return)


# # Test case for executing an app call transaction to the `reset_game` method of the smart contract
# def test_reset_game(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
#     # accs: dict[str, SigningAccount],
# ) -> None:
#     # Get the app client from the apps dict
#     app_client = apps["pieout_client_1"]
#     # creator = accs["creator"]
#     # randy_1 = accs["randy_1"]
#     randy_1 = randy_factory["randy_1"]

#     def try_reset_txn(
#         account: SigningAccount,
#         game_id: int,
#     ) -> None:
#         # Create the required payment transactions
#         stake_pay = create_payment_txn(
#             app_client, account, cst.STAKE_AMOUNT_MANAGER
#         )  # Manager stake deposit

#         # Send app call transaction to smart contract method `new_game`
#         send_app_call_txn(
#             logger=logger,
#             app_client=app_client,
#             account=account,
#             method=app_client.send.reset_game,
#             args=(game_id, stake_pay),
#             description="Reset Game App Call",
#         )

#     try_reset_txn(creator, 0)
#     # try_reset_txn(account=creator, game_id=1)
#     try_reset_txn(randy_1, 1)

#     read_game0_state_txn = app_client.send.read_game_state(
#         args=(0,),
#         params=CommonAppCallParams(sender=creator.address, signer=creator.signer),
#     )

#     read_game1_state_txn = app_client.send.read_game_state(
#         args=(1,),
#         params=CommonAppCallParams(sender=creator.address, signer=creator.signer),
#     )

#     read_game0_players_txn = app_client.send.read_game_players(
#         args=(0,),
#         params=CommonAppCallParams(sender=creator.address, signer=creator.signer),
#     )

#     read_game1_players_txn = app_client.send.read_game_players(
#         args=(1,),
#         params=CommonAppCallParams(sender=creator.address, signer=creator.signer),
#     )

#     logger.info(read_game0_state_txn.abi_return)
#     logger.info(read_game1_state_txn.abi_return)
#     logger.info(read_game0_players_txn.abi_return)
#     logger.info(read_game1_players_txn.abi_return)


# # Test case for executing an app call transaction to the `reset_game` method of the smart contract
# def test_get_trophy(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
#     # accs: dict[str, SigningAccount],
# ) -> None:
#     # Get the app client from the apps dict
#     app_client = apps["pieout_client_1"]
#     # creator = accs["creator"]
#     # randy_1 = accs["randy_1"]
#     ath_address = app_client.state.global_state.ath_address

#     # Find the matching SigningAccount
#     ath_account = next(
#         (acc for acc in randy_factory.values() if acc.address == ath_address), None
#     )

#     assert ath_account is not None, "ATH address not found in randy accounts"

#     asset_id_bytes = base64.b64decode(
#         app_client.algorand.client.algod.application_box_by_name(
#             app_client.app_id, b"t_"
#         )["value"]
#     )
#     asset_id = int.from_bytes(bytes=asset_id_bytes, byteorder="big", signed=False)
#     logger.info(asset_id)

#     def try_get_trophy_txn(
#         account: SigningAccount,
#     ) -> None:

#         # Perform asset opt-in using the matched SigningAccount
#         app_client.algorand.send.asset_opt_in(
#             params=AssetOptInParams(
#                 sender=ath_account.address,
#                 signer=ath_account.signer,
#                 asset_id=asset_id,
#             )
#         )

#         # Send app call transaction to smart contract method `new_game`
#         send_app_call_txn(
#             logger=logger,
#             app_client=app_client,
#             account=account,
#             method=app_client.send.get_trophy,
#             max_fee=micro_algo(2_000),
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Get Trophy App Call",
#         )

#     try_get_trophy_txn(ath_account)

#     app_account_trophy = app_client.algorand.client.algod.account_asset_info(
#         address=app_client.app_address, asset_id=asset_id
#     )["asset-holding"]

#     ath_account_trophy = app_client.algorand.client.algod.account_asset_info(
#         address=ath_account.address, asset_id=asset_id
#     )["asset-holding"]

#     logger.info(f"App Account Trophy Asset Holding {app_account_trophy}")
#     logger.info(f"Ath Account Trophy Asset Holding {ath_account_trophy}")

# Perform asset opt-in using the matched SigningAccount
# app_client.algorand.send.asset_opt_in(
#     params=AssetOptInParams(
#         sender=creator.address,
#         signer=creator.signer,
#         asset_id=asset_id,
#     )
# )

# # Perform asset opt-out
# app_client.algorand.send.asset_opt_out(
#     params=AssetOptOutParams(
#         sender=ath_account.address,
#         signer=ath_account.signer,
#         note="sender:ath_address,reciever:app_address,concern:asset_opt_out",
#         asset_id=asset_id,
#         creator=app_client.app_address,
#     ),
#     ensure_zero_balance=False,
# )

# app_account_trophy = app_client.algorand.client.algod.account_asset_info(
#     address=app_client.app_address, asset_id=asset_id
# )["asset-holding"]

# logger.info(f"App Account Trophy Asset Holding {app_account_trophy}")


# # Test case for executing an app call transaction to the `delete_game` method of the smart contract
# def test_delete_game(
#     creator: SigningAccount,
#     randy_factory: dict[str, SigningAccount],
#     apps: dict[str, PieoutClient],
#     # accs: dict[str, SigningAccount],
# ) -> None:
#     # Get the app client from the apps dict
#     app_client = apps["pieout_client_1"]
#     # creator = accs["creator"]
#     # randy_1 = accs["randy_1"]

#     def try_delete_txn(
#         account: SigningAccount,
#         game_id: int,
#     ) -> None:

#         # Send app call transaction to smart contract method `new_game`
#         send_app_call_txn(
#             logger=logger,
#             app_client=app_client,
#             account=account,
#             method=app_client.send.delete_game,
#             args=(game_id,),
#             max_fee=micro_algo(5_000),
#             send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#             description="Delete Game App Call",
#         )

#     read_game0_players_txn = app_client.send.read_game_players(
#         args=(0,),
#         params=CommonAppCallParams(sender=creator.address, signer=creator.signer),
#     )

#     read_game1_players_txn = app_client.send.read_game_players(
#         args=(1,),
#         params=CommonAppCallParams(sender=creator.address, signer=creator.signer),
#     )
#     logger.info(read_game0_players_txn.abi_return)
#     logger.info(read_game1_players_txn.abi_return)

#     try_delete_txn(creator, 0)
#     try_delete_txn(randy_factory["randy_1"], 1)


#     app_client.send.delete.terminate(
#         params=CommonAppCallParams(
#             sender=creator.address, signer=creator.signer, max_fee=micro_algo(2000)
#         ),
#         send_params=SendParams(cover_app_call_inner_transaction_fees=True),
#     )
